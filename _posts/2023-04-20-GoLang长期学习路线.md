---
title: GoLang长期学习路线
author: Yahui
layout: go
category: Go
---

书名:《-》

<pre style="text-align: left;">
go可以做的事情:
	1.服务端开发：以前你使用C或者C++做的那些事情，用Go来做很合适，例如日志处理、文件系统、监控系统等;
	2.DevOps：运维生态中的Docker、K8s、prometheus、grafana、open-falcon等都是使用Go语言开发;
	3.网络编程：大量优秀的Web框架如Echo、Gin、Iris、beego等，而且Go内置的 net/http包十分的优秀;
	4.Paas云平台领域：Kubernetes和Docker Swarm等;
	5.分布式存储领域：etcd、Groupcache、TiDB、Cockroachdb、Influxdb等;
	6.区块链领域：区块链里面有两个明星项目以太坊和fabric都使用Go语言;
	7.容器虚拟化：大名鼎鼎的Docker就是使用Go语言实现的;
	8.爬虫及大数据：Go语言天生支持并发，所以十分适合编写分布式爬虫及大数据处理。
总结
	Go开发核心：深入理解计算机原理、计算机网络协议以及主流协议、数据结构与算法、Linux、MySql、Redis、MQ、RPC、微服务、k8s、docker、架构认识、分布式落地
1.初级
	1.计算机基础(必会)
		1.冯诺伊曼体系(必会)
			1.用二进制进行计算和存储
				高电平低电平主要应用于数字电路。体现在电路上就是只有‘有’和‘无’，没有中间值，这个有在不同电路上的电压值不相同。
			2.基本结构
				输入设备(键盘，鼠标，摄像头，网卡和硬盘等)，输出设备(键盘，鼠标，摄像头，网卡和硬盘等)，存储器(内存)，控制器，运算器。
			3.CPU
				指令由控制单元分配到逻辑单元，经过加工处理之后，再送到存储单元里等待应用程序的使用。
			4.存储器
			5.总线
			6.输入设备
			7.输出设备
		2.计算机网络(必会)
			1.网络协议
				1.物理层:
					解决硬件之间怎么通信的问题,常见的物理媒介有电缆、光纤、无线电波等,实现了相邻计算机节点之间比特流的透明传送,并尽可能地屏蔽掉具体传输介质和物理设备的差异,使其上层(数据链路层)不必关心网络的具体传输介质。
				2.数据链路层:
					接收来自物理层的位流形式的数据,并封装成帧,传送到上一层；同样,也将来自上层的数据帧,拆装为位流形式的数据转发到物理层。由于各种干扰的存在,物理链路是不可靠的,这一层在物理层提供的比特流的基础上通过差错控制、流量控制方法,使有差错的物理线路变为无差错的数据链路,即提供可靠的通过物理介质传输数据的方法。
				3.网络层:IP/ICMP/IGMP
					将网络地址翻译成对应的物理地址,通过路由选择算法,为报文（该层的数据单位,由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址,通过IP地址寻址,所以产生了IP协议。
				4.传输层:TCP/UDP
					当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。
					简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输
				5.会话层:
					建立和管理应用程序之间的通信,用户应用程序和网络之间的接口,建立通信链接,保持会话过程通信链接的畅通,同步两个节点之间的对话,决定通信是否被中断以及通信中断时决定从何处重新发送。
				6.表示层:
					不同系统之间的通信语法问题(比如windows与Linux通信),数据的编码,压缩和解压缩,数据的加密和解密,对来自应用层的命令和数据进行解释,以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
				7.应用层:HTTP/HTTPS/FTP/SSH/SMTP/TELNET
					负责完成网络中应用程序与网络操作系统之间的联系,建立与结束使用者之间的联系,并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外,该层还负责协调各个应用程序间的工作
				<span class="image featured"><img src="{{ 'assets/images/other/osi_netmodel.png' | relative_url }}" alt="" /></span>
			2.序列化协议
				文本类序列化方式,虽然可读性比较好,但是性能较差,一般不会选择
					XML
					JSON
				二进制序列化,跨语言,多语言支持.序列化反序列化效率高,文件体积小,比json小一倍.兼容json数据格式.
					MessagePack
						import "github.com/vmihailenco/msgpack/v5"
						func main() {
						    b, err := msgpack.Marshal(&Item{Foo: "bar"})
						    if err != nil {
						        panic(err)
						    }

						    var item Item
						    err = msgpack.Unmarshal(b, &item)
						    if err != nil {
						        panic(err)
						    }
						    fmt.Println(item.Foo)
						    // Output: bar
						}
			3.七层体系结构
			4.四层体系结构
		3.操作系统(必会)
			1.进程、线程、协程的区别
				进程
					进程是程序一次动态执行的过程，是程序运行的基本单位。
					每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。
					进程占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、页表、文件句柄等）比较大，但相对比较稳定安全。协程切换和协程切换
				线程
					线程又叫做轻量级进程，是CPU调度的最小单位。
					线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。
					多个线程共享所属进程的资源，同时线程也拥有自己的专属资源。
					程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
				协程
					协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
					一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。
					与其让操作系统调度，不如我自己来，这就是协程
			2.进程间常用的通信方式
				进程间常用的通信
					1.管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。通过内核缓冲区实现数据传输
					2.有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。有名管道以磁盘文件的方式存在，在系统中有对应的路径可以实现本机任意两个进程通信。管道的本质是内核维护了一块缓冲区与管道文件相关联，对管道文件的操作被内核转换成对这块缓冲区内存的操作。
					3.信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
					4.消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
					5.信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。
					6.共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
					7.套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。
				线程间常用的通信
					1.互斥量 (锁) 只有拥有互斥量的线程才能执行任务
					2.信号量 (PV)  信号量是一个计数器
					3.事件 目事件机制，允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务.
			3.5种网络IO模型
				同步IO
					阻塞 IO（blocking IO）
						默认情况下所有的 socket 都是 blocking
						当用户进程调用了 read 这个系统调用，kernel 就开始了 IO 的第一个阶段：准备数据。对于 network io 来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的数据包）这个时候 kernel 就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当 kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果，用户进程才解除 block 的状态，重新运行起来
					非阻塞 IO（non-blocking IO）
						当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回，所以，在非阻塞式 IO 中，用户进程其实是需要不断的主动询问 kernel数据准备好了没有。
					多路复用 IO（IO multiplexing）
						select
							调用 select 会把所有要管理的 socket 的 fd (文件描述符，Linux下皆为文件，简单理解就是通过 fd 能找到这个 socket)传到内核中,遍历所有 socket，看看是否有感兴趣的事件发生。如果没有一个 socket 有事件发生，那么 select 的线程就需要让出 cpu 阻塞等待，这个等待可以是不设置超时时间的死等，也可以是设置 timeout 的有超时时间的等待。
							当 socket 接收到网卡的数据后，就会去它的睡眠队列里遍历 entry，调用 entry 设置的 callback 方法，这个 callback 方法里就能唤醒 select ！
							所以 select 在每个被它管理的 socket 的睡眠队列里都塞入一个与它相关的 entry，这样不论哪个 socket 来数据了，它立马就能被唤醒然后干活！
							但是，select 的实现不太好，因为唤醒的 select 此时只知道来活了，并不知道具体是哪个 socket 来数据了，所以只能傻傻地遍历所有 socket ，看看到底是哪个 scoket 来活了，然后把所有来活的 socket 封装成事件返回
							(因为被管理的 socket fd 需要从用户空间拷贝到内核空间，为了控制拷贝的大小而做了限制，即每个 select 能拷贝的 fds 集合大小只有1024)
						poll
							poll 这玩意相比于 select 主要就是优化了 fds 的结构，不再是 bit 数组了，而是一个叫 pollfd 的玩意，反正就是不用管啥 1024 的限制了。(现在也没人用 poll，就不多说了)
						epoll
							select存在的问题
								1.比如，为什么每次 select 需要把监控的 fds 传输到内核里？不能在内核里维护个？
								2.为什么 socket 只唤醒 select，不能告诉它是哪个 socket 来数据了？
								epoll 主要就是基于上面两点做了优化。
							过程
								1.搞了个叫 epoll_ctl 的方法，这方法就是用来管理维护 epoll 所监控的哪些 socket(这个 socket 集合是用红黑树实现的)
								2.然后和 select 类似，每个 socket 的睡眠队列里都会加个 entry，当每个 socket 来数据之后，同样也会调用 entry 对应的 callback。
								3.与 select 不同的是，引入了一个 ready_list 双向链表，callback 里面会把当前的 socket 加入到 ready_list 然后唤醒 epoll。
								4.这样被唤醒的 epoll 只需要遍历 ready_list 即可
					信号驱动 IO（signal driven I/O， SIGIO）
				异步IO
					用户进程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel的角度，当它收到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了
			4.并发与并行的区别
				并发：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。
				并行：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务是同时运行。
			5.同步与异步的区别
				同步：就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。这时程序是阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 因此 简单的说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。
				异步：与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。
			6.阻塞与非阻塞的区别
				阻塞：调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
				非阻塞：调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
			7.常见缓存淘汰算法
				LFU(Least Frequently Used)：最近最不常用算法，根据数据的历史访问频率来淘汰数据。
					1.在缓存中查找客户端需要访问的数据
					2.如果缓存命中，则将访问的数据从队列中取出，并将数据对应的频率计数加1，然后将其放到频率相同的数据队列的头部，比如原来是A(10)->B(9)->C(9)->D(8),D被访问后，它的time变成了9，这时它被提到A和B之间，而不是继续在C后面
					3.如果没有命中，表示缓存穿透，将需要访问的数据从磁盘中取出，加入到缓存队列的尾部，记频率为1，这里也是加入到同为1的那一级的最前面
					4.如果此时缓存满了，则需要先置换出去一个数据，淘汰队列尾部频率最小的数据，然后再在队列尾部加入新数据。
					缺点
						某些数据短时间内被重复引用，并且在很长一段时间内不再被访问。由于它的访问频率计数急剧增加，即使它在相当长的一段时间内不会被再次使用，也不会在短时间内被淘汰。这使得其他可能更频繁使用的块更容易被清除，此外，刚进入缓存的新项可能很快就会再次被删除，因为它们的计数器较低，即使之后可能会频繁使用。
				LRU（Least Recently User） 最近最少使用算法,根据数据的历史访问记录来进行淘汰数据
					1.在缓存中查找客户端需要访问的数据 如果缓存命中，则将访问的数据中队列中取出，重新加入到缓存队列的头部。
					2.如果没有命中，表示缓存穿透，将需要访问的数据从磁盘中取出，加入到缓存队列的尾部；
					3.如果此时缓存满了，淘汰队列尾部的数据，然后再在队列头部加入新数据。
					缺点
						缓存污染：如果某个客户端访问大量历史数据时，可能使缓存中的数据被这些历史数据替换，其他客户端访问数据的命中率大大降低。
				FIFO（First in First out），先进先出算法,最先进入的数据,最先被淘汰。
					最近刚访问的，将来访问的可能性比较大 ,如果一个数据最先进入缓存中，则应该最早淘汰掉。
				2Q（Two queues）
					有两个缓存队列，一个是FIFO队列，一个是LRU队列。当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。
		4.数据结构与算法(必会)
			1.时间/空间复杂度
				一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
				空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。
			2.熟悉常用数据结构
				1.字符串
				2.数组
				3.链表
				4.队列
				5.二叉树
				6.栈
				7.堆
			3.熟悉常用算法
				1.双指针
				2.左右指针
				3.排序
				4.二叉查找
				5.递归
				6.回溯
				7.贪心
				8.动态规划
		5.数据库(必会)
			1.关系型数据库
				1.MariaDB
				2.Mysql(必会)
				3.Oracle
			5.NoSQL
				1.Redis(必会)
				2.MongoDB
				3.LevelDB
				4.Memcache
		6.Internet(必会)
			1.互联网是如何工作的
				IP地址:标识设备和网络寻址
				IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。
				子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。子网掩码不能单独存在，它必须结合IP地址一起使用。
				MAC地址也叫物理地址、硬件地址，由网络设备制造商生产时烧录在网卡(Network lnterface Card)的EPROM(一种闪存芯片，通常可以通过程序擦写)。IP地址与MAC地址在计算机里都是以二进制表示的，IP地址是32位的，而MAC地址则是48位的
			2.HTTP是什么
				HTTP使用TCP作为传输层协议，并采用请求-响应模型来进行通信。
			3.浏览器以及浏览器如何运作
				1. 解析URL：当用户在浏览器中输入URL时，浏览器会将这个URL解析成协议名、主机名、端口号、路径等信息。
				2. 建立连接：浏览器通过解析到的主机名和端口号建立与服务器的连接。
				3. 发送请求：浏览器向服务器发送HTTP请求，请求中包括请求方法、对应的资源路径、HTTP版本、请求头信息等。
				4. 接收响应：服务器接收到请求后，会返回对应的HTTP响应码和响应体。浏览器接收到响应后会根据响应码执行相应的操作。
				5. 渲染页面：如果响应是HTML页面，浏览器会根据HTML解析出DOM树，再根据CSS解析出CSSOM树，最后将两者进行合并形成Render Tree，然后进行页面渲染。
				6. 用户交互和维护：当用户与页面进行交互时，浏览器会触发相应的事件，执行相关的JavaScript代码以更新页面内容。同时，浏览器会维护浏览历史、Cookie、缓存等信息以提高浏览器的使用体验。
			4.域名是什么
			5.hosting是什么
	2.Go编程基础(必会)
		1.开发环境(必会)
			1.go安装
				下载源码包安装
			2.go环境变量
				// 查看
				go env
				// 修改
				go env -w GOOS=windows
			3.go模块
				go mod init ⽣成 go.mod ⽂件
				go mod download 下载 go.mod ⽂件中指明的所有依赖
				go mod tidy 整理现有的依赖
				go mod graph 查看现有的依赖结构
				go mod edit 编辑 go.mod ⽂件
				go mod vendor 导出项⽬所有的依赖到vendor⽬录
				go mod verify 校验⼀个模块是否被篡改过
				go mod why 查看为什么需要依赖某模块
		2.基础(必会)
			1.字面量
			2.常量
			3.变量
			4.类型
			5.操作符
			6.表达式
			7.语句
			8.错误处理
				1.经典 Go 逻辑
					// ZooTour struct
					type ZooTour interface {
					    Enter() error
					    VisitPanda(panda *Panda) error
					    Leave() error
					}

					// 分步处理，每个步骤可以针对具体返回结果进行处理
					func Tour(t ZooTour1, panda *Panda) error {
					    if err := t.Enter(); err != nil {
					        return errors.WithMessage(err, "Enter failed.")
					    }
					    if err := t.VisitPanda(); err != nil {
					        return errors.WithMessage(err, "VisitPanda failed.")
					    }
					    // ...

					    return nil
					}
				2.屏蔽过程中的 error 的处理
					type ZooTour interface {
					    Enter() error
					    VisitPanda(panda *Panda) error
					    Leave() error
					    Err() error
					}

					func Tour(t ZooTour, panda *Panda) error {

					    t.Enter()
					    t.VisitPanda(panda)
					    t.Leave()

					    // 集中编写业务逻辑代码,最后统一处理error
					    if err := t.Err(); err != nil {
					        return errors.WithMessage(err, "ZooTour failed")
					    }
					    return nil
					}
				3. 利用函数式编程延迟运行
					type Walker interface {
					    Next MyFunc
					}
					type SliceWalker struct {
					    index int
					    funs []MyFunc
					}

					func NewEnterFunc() MyFunc {
					    return func(t ZooTour) error {
					        return t.Enter()
					    }
					}

					func BreakOnError(t ZooTour, walker Walker) error {
					    for {
					        f := walker.Next()
					        if f == nil {
					            break
					        }
					        if err := f(t); err := nil {
					          // 遇到错误break或者continue继续执行
					      }
					    }
					}
				case 1: 如果业务逻辑不是很清楚，比较推荐
				case 2: 代码很少去改动，类似标准库，可以使用
				case 3: 比较复杂的场景，复杂到抽象成一种设计模式
		3.代码组织(必会)
			1.工作区
				1.go mod中replace使用
					1.vim go.mod
						module gin_demo
						go 1.20
						require (
							k8s.io/cloud-provider v0.0.0
							...
						)
						// 这里就是将包替换为本地的包
						replace (
							k8s.io/api = ./staging/src/k8s
							...
						)
				2.go work使用
					1.使用场景
						1.Go 1.18中的工作区可以让你同时处理多个模块，而不必为每个模块编辑go.mod文件。在解决依赖关系时，工作区中的每个模块都被视为根模块。
						2.以前，如果要在一个模块中增加一个功能，并在另一个模块中使用，你需要在第一个模块中发布修改，或者编辑依赖模块的go.mod文件，为你的本地未发布的模块变化添加replace指令。为了不出错地发布，你必须在向第一个模块发布本地修改后，从依赖模块的go.mod文件中删除replace指令。
					2.使用方法
						1.go.work文件有use和replace指令，可以覆盖各个go.mod文件，所以不需要单独编辑每个go.mod文件
						2.可以通过运行go work init来创建一个工作区，并将模块目录列表作为空格分隔的参数。工作区不需要包含你正在使用的模块。init命令创建一个go.work文件，列出工作区的模块。如果你在运行go work init时没有参数，该命令会创建一个空的工作区。
						3.要向工作区添加模块，可以运行go work use [moddir] 或手动编辑go.work文件。运行go work use -r来递归添加参数目录中带有go.mod文件的目录到你的工作区。如果一个目录没有go.mod文件，或者不再存在，使用use指令的目录将会从go.work文件中删除。
						4.要在你的工作区中使用一个本地模块或特定版本作为依赖，运行go work use [path-to-module]。
						5.要替换你的模块的go.mod文件中的现有依赖关系，请使用go work replace [path-to-module]。
						6.要添加你的GOPATH或任何目录中的所有模块，运行go work use -r来递归地添加有go.mod文件的目录到你的工作区。如果一个目录没有go.mod文件，或者不再存在，使用use指令的目录将会从 go.work文件中删除。
						7.go work sync：将go.work文件中的依赖关系推回到每个工作区模块的go.mod文件中。
			2.代码包
				所有Go源码都是包得一部分。
				每个Go源文件都起始于一条package语句。
				命名最好是驼峰,不建议使用_(多一位),简短
			3.源码文件
				go build -o 指定文件目录 go文件
			4.代码块
		4.设计模式(推荐)
			1.设计模式六大原则
				1.开闭原则
					对于扩展是开放的，对于更改是封闭的。
					开闭原则被称为面向对象设计的基石，实际上，其他原则都可以看作是实现开闭原则的工具和手段。
				2.里氏替换原则
					子类可以扩展父类的功能，但是不能改变父类原有的功能。
				3.依赖倒转原则
					高层模块不应该依赖底层模块，二者都应该依赖其抽象了；抽象不依赖细节；细节应该依赖抽象、接口编程。
				4.接口隔离原则
					接口尽量细化，同时保证接口中的方法尽量的少。
				5.迪米特法则
					一个类对自己需要耦合或者调用的类知道的最少，你类内部怎么复杂，我不管，那是你的事，我只知道你有那么多公用的方法，我能调用。
				6.单一职责原则
					一个类只负责一个职责
			2.23钟常见设计模式
				1.行为型模式
				2.结构型模式
				3.创建型模式
		5.标准库(必会)
			1.功能型
				1.net
					cn, err := net.Dial("tcp", "localhost:8080")
						// cn中所包含的方法
						Read(b []byte) (n int, err error)
						Write(b []byte) (n int, err error)
						Close() error
						LocalAddr() Addr
						RemoteAddr() Addr
						SetDeadline(t time.Time) error
						SetReadDeadline(t time.Time) error
						SetWriteDeadline(t time.Time) error
					l, err := net.Listen("tcp", ":8080")
						// l中所包含的方法
						Accept() (Conn, error)
						Close() error
						Addr() Addr
				2.errors
					// error是interface类型
					type error interface {
						Error() string
					}
					// error包中New返回的是一个结构体
					func New(text string) error {
						return &errorString{text}
					}
					type errorString struct {
						s string
					}
					func (e *errorString) Error() string {
						return e.s
					}
				3.os
					1. 文件系统
						对于文件系统的访问，在os包中提供了文件操作相关的函数，例如Create和Open函数：Create函数可以创建一个文件并返回一个文件句柄，Open函数可以打开一个文件并返回一个文件句柄。这些函数在不同的操作系统上实现的方式可能不同。
					2. 环境变量
						在os包中，可以使用Environ函数来获取当前进程的环境变量。它会返回一个字符串切片，每个元素都是“键=值”的形式。可以使用Setenv函数来设置环境变量，使用Unsetenv函数来删除环境变量。
					3. 进程管理
						在os包中，StartProcess函数可以用于启动一个新的进程，并返回一个Process类型的值，该类型表示当前进程所在的进程。这个函数在不同的操作系统上的实现方式可能不同，因此Process类型的组成和相关方法可能有所不同。
					4. 信号处理
						在操作系统中，信号是一种异步事件，因此需要使用操作系统提供的相关函数和类型进行处理。在os包中，Signal函数可以用于注册信号处理函数，Wait函数可以用于等待信号的到来并进行处理。
					5. 用户和组管理
						在操作系统中，用户和组是管理系统权限和访问控制的重要部分。在os包中，User和Group类型分别表示用户和组。当前用户可以使用CurrentUser函数获取，Getegid和Geteuid函数可以获取当前用户是属于哪个组。Getgroups函数可以获取当前用户属于哪些组。
				4.sync
					1.锁机制是同步机制中最基本的一种，主要是保证多个goroutine之间对于共享数据的操作能够正确地被执行。一般有两种锁机制：互斥锁和读写锁。
						1.互斥锁被广泛应用于go语言的并发编程当中，其背后的原理就是独占锁。当某个goroutine获取到了锁，其他goroutine就需要等待，直到锁被释放，这时候才能再次尝试获取锁。互斥锁通过Mutex结构体来实现，其主要方法有：
							- Lock：获取并持有锁，如果锁已被持有，则当前goroutine就会被阻塞；
							- Unlock：释放锁，如果当前并没有任何goroutine尝试获取锁，则该操作会非常快速；
							- TryLock：尝试获取锁，如果获取到了，则返回true，否则返回false。
						2读写锁是另一种锁机制，其主要用于读多写少场景。在读写锁中，读锁是共享锁，可以同时被多个goroutine持有，而写锁是独占锁，只能由一个goroutine来持有。读写锁通过RWMutex结构体来实现，其主要方法有：
							- RLock：获取并持有读锁，如果已经有goroutine持有写锁或正在等待获取写锁，则当前goroutine会被阻塞；
							- RUnlock：释放读锁；
							- Lock：获取并持有写锁，所以等待获取或者持有读锁和写锁的goroutine都会被阻塞；
							- Unlock：释放写锁。
						// 通过原子操作来将互斥锁的状态从未锁定（0）状态修改为锁定状态
						atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked)
						// 实现锁的加锁操作
						m.lockSlow()
					2.条件变量机制主要用于通知goroutine某个条件是否已经满足，只有当某个条件被满足时，才会释放锁，让其他等待同步的goroutine继续执行。
						1.条件变量机制通过Cond结构体来实现，其主要方法有：
							- Wait：进入条件等待，释放锁并阻塞当前goroutine，直到被唤醒；
							- Signal：唤醒一个goroutine，使其从条件等待中醒来；
							- Broadcast：唤醒所有等待同一条件的goroutine。
						w := sync.WaitGroup{}
						w.Add(1)
						w.Done()
						w.Wait()
						sync包WaitGroup内 state的高32位和低32位分别表示等待的goroutine的数量和是否已完成的标志位。
						高32位用于表示需要等待的goroutine数量，即计数器的值，该计数器代表还有多少个goroutine尚未完成并需要等待。调用Wait()时会阻塞，直至计数器的值归零。
						低32位用于表示是否已完成的标志位，该标志位用于表示WaitGroup是否已经完成。当WaitGroup内部计数器的值归零时，该标志位会被设置为已完成，表示所有等待的goroutine都已经完成，此时WaitGroup的所有等待都可以结束。
						(主要通过使用runtime_Semacquire(&wg.sema)来等待计数器归零)
						通过将低32位设置为1，可以在WaitGroup内部防止再次添加等待的goroutine，即不能对已关闭的WaitGroup对象再次添加等待的goroutine。这样可以避免在WaitGroup对象已经被销毁的情况下继续调用其方法，从而避免资源泄漏和运行时错误
				5.time
					1.time.Time
						1.time.Time表示一个具体时间点，类似于C中的time_t类型。它存储了一个64位整数来表示自UTC-1970年1月1日0时0分0秒起经过的纳秒数。time.Time有很多方法可以转化为各种形式的字符串、比较不同时间等。
						2.time.Duration表示一个时间间隔，它也是一个64位的整数，单位为纳秒。
					2.时间格式化
						time.Format()，可以将一个time.Time类型的时间转换为字符串。
							t := time.Now()
							fmt.Println(t.Format("2006-01-02 15:04:05"))
							//Output: 2021-10-01 14:30:10
					3. 时间解析
						除了将时间转换为字符串，Golang中还提供了将字符串解析为时间的函数time.Parse()。如下例：
						t, _ := time.Parse("2006-01-02 15:04:05", "2021-10-01 14:30:10")
						fmt.Println(t)
					4. 时间比较
						t1 := time.Now()
						t2 := time.Now().Add(time.Duration(1) * time.Hour)
						if t1.After(t2) / t1.Before(t2) ...
					5. 定时器
						1.延迟执行
							// 延迟1秒执行
							c := time.NewTimer(time.Second)
							<-c.C
						2.循环执行
							// 每一秒执行
							d := time.NewTicker(time.Second)
							for {
								<-d.C
							}
			2.输入输出型
				1.io
					1.io.Reader / io.Writer
						一个实现了io.Reader接口的对象可以被用来从某处读取数据，而实现了io.Writer接口的对象则可以用来向某处写入数据。一些常用的实现这两个接口的类型有File（读写文件）、strings.Reader（读取字符串）、bytes.Buffer（读写内存）等等。
					2. io.Copy
						复制操作是I/O编程中最常见的任务之一。Golang提供了一个方便的方法来复制（拷贝）源文件或者reader的内容到目标文件或者writer，即io.Copy()。
					3. io.ReadFull / io.WriteString
						io包还提供了一些常用的辅助函数，比如io.ReadFull()可以读取一个指定长度的字节流（如果读取不到指定长度的字节，将返回错误），io.WriteString()可以将一个字符串写入到一个writer中。
					4. io.Pipe
						io.Pipe()返回一对关联的*Pipe对象，可用于在不同的goroutine之间传递数据。一个*Pipe对象有两个方法，Read()和Write()。调用Read()方法会阻塞直到有数据可读；调用Write()方法会阻塞直到所有写入的数据都被读取。
				2.fmt
					// 该函数用于将格式化的字符串输出到标准输出流，常用于控制台输出。
					fmt.Printf(format string, a ...interface{})
					// 自动在字符串末尾添加一个换行符，并输出到控制台。
					fmt.Println(a ...interface{})
					// 但是不输出换行符，输出到控制台。
					fmt.Print(a ...interface{})
					// 该函数和Printf函数类似，但是不输出到控制台，而是返回一个格式化后的字符串。
					fmt.Sprintf(format string, a ...interface{})
					// 该函数用于将格式化的字符串和错误码（code）封装成一个错误类型，返回给调用者。
					fmt.Errorf(format string, a ...interface{}) error
						err := fmt.Errorf("code:%d, error:%s", 404, "Not Found")
					    if errors.Is(err, fmt.Errorf("code:%d, error:%s", 404, "Not Found")) {
					        fmt.Println("Error:", err)
					    }
					// 其中的io.Writer是一个接口，可以是各种实现了该接口的类型，例如文件、网络连接等。
					func Fprint(w io.Writer, a ...interface{}) (n int, err error)
						txt1 := "Hello"
					    txt2 := "World"
					    _, _ := fmt.Fprint(os.Stdout, txt1, ", ", txt2)
					    (fmt.Print就是调用的fmt.Fprint)
				3.log
					- func Print(v ...interface{})：打印普通日志消息
					- func Printf(format string, v ...interface{})：打印格式化的日志消息
					- func Println(v ...interface{})：打印带换行符的日志消息
					- func Fatal(v ...interface{})：打印致命错误消息并退出程序
					- func Fatalf(format string, v ...interface{})：打印格式化的致命错误消息并退出程序
					- func Fatalln(v ...interface{})：打印带换行符的致命错误消息并退出程序
					- func Panic(v ...interface{})：打印错误消息并引发panic
					- func Panicf(format string, v ...interface{})：打印格式化的错误消息并引发panic
					- func Panicln(v ...interface{})：打印带换行符的错误消息并引发panic

					log包中默认的输出流是标准错误（stderr）。可以使用SetOutput函数更改输出流。例如，要将日志消息输出到文件中，可以使用以下代码：
					可以将日志输入到文件中
						file, err := os.OpenFile("./a.txt", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 777)
						if err != nil {
							log.Fatal(err)
						}
						defer file.Close()
						log.SetOutput(file)
						log.SetFlags(log.Ldate | log.Ltime)
						log.Println("asdfasdfassad")
		6.版本控制(必会)
			1.Git
2.高级
	1.Go编程进阶(必会)
		1.原理(必会)
			1.map
				golang map底层由两个核心的结构体实现：hmap和bmap，bmap本篇用桶代替。
				type hmap struct {
					count     int // count字段是map目前的元素数目,当使用len()函数获取map长度时,返回的便是count成员的值,因此len()函数作用于map结构时,其时间复杂度为O(1)
					flags     uint8 // 标志 map 的状态, 如 map 当前正在被遍历或正在被写入
					B         uint8  // 哈希桶数目以2为底的对数,在go map中,哈希桶的数目都是2的整数次幂(这样设计的好处是可以是用位运算来计算取余运算的值,即N mod M = N & (M-1))
					noverflow uint16 // 溢出桶的数目,这个数值不是恒定精确的
					hash0     uint32 // 随机哈希种子,map创建时调用fastrand函数生成的随机数,设置的目的是为了降低哈希冲突的概率
					buckets    unsafe.Pointer // 指向当前哈希桶的指针数组,也就是指向bmap结构体的数组(每个数组下标处存储的是一个bucket)
					oldbuckets unsafe.Pointer // 当桶扩容时指向旧桶的指针
					nevacuate  uintptr        // 是当桶进行调整时指示的搬迁进度,小于此地址的buckets是以前搬迁完毕的哈希桶,
					extra *mapextra // 溢出桶的变量
				}
				// 其中bucketCnt是1 << 3得来的
				// 每个bucket中可以存储8个kv键值对，当每个bucket存储的kv对到达8个之后，会通过overflow指针指向一个新的bucket，从而形成一个链表,看bmap的结构
				type bmap struct {
					tophash [bucketCnt]uint8 // 键哈希值的高 8 位
				}
				// 这个是编译时增加的结构体内容
				type bmap struct {
				    topbits  [8]uint8 // 每个键的hash值的高八位。
				    keys     [8]keytype
				    values   [8]valuetype
				    pad      uintptr
				    overflow uintptr
				}
				type mapextra struct {
					overflow    *[]*bmap
					oldoverflow *[]*bmap
					nextOverflow *bmap
				}
				key定位过程
					1.key经过哈希计算后得到哈希值共64个bit位（64位机），计算它到底要落在哪个桶时，只会用到最后B个bit位。(如果B=5，那么桶的数量，也就是buckets数组的长度是 2^5 = 32)
						比如:10010111 | 000011110110110010001111001010100010010110010101010 │ 01010
					2.用最后的 5 个 bit 位，也就是 01010，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。
					3.再用哈希值的高 8 位，找到此 key 在 bucket 中的位置，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。
						注:buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。
						<span class="image featured"><img src="{{ 'assets/images/other/go_map_base.jpg' | relative_url }}" alt="" /></span>
					4.上图中，假定 B = 5，所以 bucket 总数就是 2^5 = 32。首先计算出待查找 key 的哈希，使用低 5 位 00110，找到对应的 6 号 bucket，使用高 8 位 10010111，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。
						(如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。)

					注：kv的存放，为什么不是k1v1，k2v2..... 而是k1k2...v1v2...，我们看上面的注释说的 map[int64]int8,key是int64（8个字节），value是int8（一个字节），kv的长度不同，如果按照kv格式存放，则考虑内存对齐v也会占用int64，而按照后者存储时，8个v刚好占用一个int64,从这个就可以看出go的map设计之巧妙。
				整体流程：
					//获取hash算法
					//计算hash值
					//如果bucket数组一开始为空，则初始化
					//定位存储在哪一个bucket中
					//得到bucket的结构体
					//获取高八位hash值
					//死循环
					//循环bucket中的tophash数组
					//如果hash不相等
					//判断是否为空，为空则插入
					//插入成功，终止最外层循环
					//到这里说明高八位hash一样，获取已存在的key
					//判断两个key是否相等，不相等就循环下一个
					//如果相等则更新
					//获取已存在的value
					//如果上一个bucket没能插入，则通过overflow获取链表上的下一个bucket
				在Go语言中，map底层实现使用了哈希表。但是在哈希表涉及到扩容时，会发生哈希冲突的情况，此时Go语言使用了红黑树来解决哈希冲突的问题。当哈希表发生冲突，且冲突的bucket中的元素数量大于8时，Go语言会将bucket中的键值对转移到红黑树中。通过红黑树的平衡性，可以有效避免hash碰撞过多时，哈希表退化为链表的情况。
			2.channel
				type hchan struct {
				    qcount   uint // chan里元素数量
				    dataqsiz uint // chan底层循环数组的长度
				    buf      unsafe.Pointer // 指向底层循环数组的指针，只针对有缓冲的channel
				    elemsize uint16 // chan中元素大小
				    closed   uint32 // chan是否被关闭的标志
				    elemtype *_type // chan中元素类型
				    // 有缓冲channel内的缓冲数组会被作为一个“环型”来使用。当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置
				    sendx    uint   // 下一次发送数据的下标位置
				    recvx    uint   // 下一次读取数据的下标位置
				    // 当循环数组中没有数据时，收到了接收请求，那么接收数据的变量地址将会写入读等待队列
				    // 当循环数组中数据已满时，收到了发送请求，那么发送数据的变量地址将写入写等待队列
				    recvq    waitq  // 读等待队列（双向链表）
				    sendq    waitq  // 写等待队列（双向链表）
				    // 保护hchan中所有字段
				    lock mutex
				}
				向chan发送数据
					// 如果 channel 是 nil
				    if c == nil {
				        // 不能阻塞，直接返回 false，表示未发送成功
				        if !block {
				            return false
				        }
				        // 当前 goroutine 被挂起
				        gopark(nil, nil, "chan send (nil chan)", traceEvGoStop, 2)
				        throw("unreachable")
				    }

				    // 省略 debug 相关……

				    // 对于不阻塞的 send，快速检测失败场景
				    //
				    // 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：
				    // 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine
				    // 2. channel 是缓冲型的，但循环数组已经装满了元素
				    if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||
				        (c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {
				        return false
				    }

				    var t0 int64
				    if blockprofilerate > 0 {
				        t0 = cputicks()
				    }

				    // 锁住 channel，并发安全
				    lock(&c.lock)

				    // 如果 channel 关闭了
				    if c.closed != 0 {
				        // 解锁
				        unlock(&c.lock)
				        // 直接 panic
				        panic(plainError("send on closed channel"))
				    }

				    // 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine
				    if sg := c.recvq.dequeue(); sg != nil {
				        send(c, sg, ep, func() { unlock(&c.lock) }, 3)
				        return true
				    }

				    // 对于缓冲型的 channel，如果还有缓冲空间
				    if c.qcount < c.dataqsiz {
				        // qp 指向 buf 的 sendx 位置
				        qp := chanbuf(c, c.sendx)

				        // ……

				        // 将数据从 ep 处拷贝到 qp
				        typedmemmove(c.elemtype, qp, ep)
				        // 发送游标值加 1
				        c.sendx++
				        // 如果发送游标值等于容量值，游标值归 0
				        if c.sendx == c.dataqsiz {
				            c.sendx = 0
				        }
				        // 缓冲区的元素数量加一
				        c.qcount++

				        // 解锁
				        unlock(&c.lock)
				        return true
				    }

				    // 如果不需要阻塞，则直接返回错误
				    if !block {
				        unlock(&c.lock)
				        return false
				    }

				    // channel 满了，发送方会被阻塞。接下来会构造一个 sudog

				    // 获取当前 goroutine 的指针
				    gp := getg()
				    mysg := acquireSudog()
				    mysg.releasetime = 0
				    if t0 != 0 {
				        mysg.releasetime = -1
				    }

				    mysg.elem = ep
				    mysg.waitlink = nil
				    mysg.g = gp
				    mysg.selectdone = nil
				    mysg.c = c
				    gp.waiting = mysg
				    gp.param = nil

				    // 当前 goroutine 进入发送等待队列
				    c.sendq.enqueue(mysg)

				    // 当前 goroutine 被挂起
				    goparkunlock(&c.lock, "chan send", traceEvGoBlockSend, 3)

				    // 从这里开始被唤醒了（channel 有机会可以发送了）
				    if mysg != gp.waiting {
				        throw("G waiting list is corrupted")
				    }
				    gp.waiting = nil
				    if gp.param == nil {
				        if c.closed == 0 {
				            throw("chansend: spurious wakeup")
				        }
				        // 被唤醒后，channel 关闭了。坑爹啊，panic
				        panic(plainError("send on closed channel"))
				    }
				    gp.param = nil
				    if mysg.releasetime > 0 {
				        blockevent(mysg.releasetime-t0, 2)
				    }
				    // 去掉 mysg 上绑定的 channel
				    mysg.c = nil
				    releaseSudog(mysg)
				    return true
				向channel写数据的过程
					1.如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒结束发送过程;
					2.如果接受队列recvq为空，且缓冲区中有空余位置将数据写入缓冲区，结束发送过程;
					3.如果接受队列recvq为空，缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读oroutine唤醒
				从一个channel读数据简单过程
					1.如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程;
					2.如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓中区中首部读出数据，把G中数据写入缓中区尾部，把G唤醒，结束读取过程:
					3.如果缓冲区中有数据， 则从缓冲区取出数据，结束读取过程;4.将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒;
			3.goroutine
			4.slice
				type slice struct {
					// 指向底层数组第一个位置的指针
					array unsafe.Pointer
					len   int
					cap   int
				}
				1.当在 slice 中添加元素时，如果当前 slice 没有足够的容量，Go 语言会创建一个新的底层数组，并将原 slice 值复制到新数组中。然后将新值附加到新底层数组中，并修改 slice 对应的指针、长度和容量。如果底层数组长度不够扩容则会重新分配一块更大的连续空间，将原来的数据拷贝到新的空间中。
				2.当 slice 被传递给函数时，只会传递指向底层数组的指针、长度和容量信息。当函数接收到 slice 后，可以随意修改 slice 中的元素，这也同样修改了底层数组中对应位置的值。因此，如果一个函数需要修改 slice 中的元素的值，它必须接收一个指向 slice 的指针
				3.空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。
			5.runtime
				1. Goroutine
					Goroutine是Go语言的协程，由runtime包提供支持。以下是一些常用的函数：
						- go：创建并启动一个新的Goroutine。
						- Gosched：将当前的Goroutine挂起，让出CPU给其他Goroutine执行。
						- NumCPU：返回当前机器的CPU数量。
						- GOMAXPROCS：设置并发执行的最大CPU数。默认值为机器的CPU数量。
				2. 内存管理
					Go语言的内存管理是由runtime包提供支持的。以下是一些常用的函数：
						- GC：手动触发垃圾收集。
						- MemProfile：生成内存分配的性能分析数据。
						- MemStats：获取内存使用情况和垃圾收集信息。
						- SetFinalizer：设置对象的析构函数，用于在对象被回收前执行一些清理操作。
				3. 错误处理
					Go语言中的错误处理是通过错误值进行的，以便在程序执行过程中遇到问题时及时处理。以下是一些常用的函数：
						- panic：抛出一个异常，导致程序中断。
						- recover：捕获panic引起的异常，并恢复程序执行。
				4. 并发控制
					Go语言中的并发控制是基于互斥锁（Mutex）和读写互斥锁（RWMutex）实现的。以下是一些常用的函数：
						- Lock：获取互斥锁，如果锁已经被占用，则阻塞等待。
						- Unlock：释放互斥锁。
						- RLock：获取读写互斥锁的读锁。
						- RUnlock：释放读写互斥锁的读锁。
						- NewCond：创建一个新的条件变量。
						- Cond.Wait：等待条件变量的信号。
				5. 其他函数和数据结构
					runtime包中还有许多其他函数和数据结构，以下是一些常用的：
						- FuncForPC：根据程序计数器（PC）获取函数信息。
						- Caller：获取当前调用栈信息。
						- GOARCH、GOOS、Version等常量：获取Go程序编译的目标架构、操作系统和版本信息。
		2.GMP模型(必会)
			<span class="image featured"><img src="{{ 'assets/images/other/go_GMP.jpg' | relative_url }}" alt="" /></span>
			1.Go语言是原生支持语言级并发的，这个并发的最小逻辑单元就是goroutine。goroutine就是Go语言提供的一种用户态线程，当然这种用户态线程是跑在内核级线程之上的。当我们创建了很多的goroutine，并且它们都是跑在同一个内核线程之上的时候，就需要一个调度器来维护这些goroutine，确保所有的goroutine都使用cpu，并且是尽可能公平的使用cpu资源。这个调度器的原理以及实现值得我们去深入研究一下。支撑整个调度器的主要有4个重要结构，分别是M、G、P、Sched，前三个定义在runtime.h中，Sched定义在proc.c中。
				G：
					表示 Goroutine。每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。当 Goroutine 被调离 CPU 时，调度器代码负责把 CPU 寄存器的值保存在 G 对象的成员变量之中，当 Goroutine 被调度起来运行时，调度器代码又负责把 G 对象的成员变量所保存的寄存器的值恢复到 CPU 的寄存器。
				M：
					OS 底层线程的抽象，它本身就与一个内核线程进行绑定，每个工作线程都有唯一的一个 M 结构体的实例对象与之对应，它代表着真正执行计算的资源，由操作系统的调度器调度和管理。M 结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的 Goroutine 以及是否空闲等等状态信息之外，还通过指针维持着与 P 结构体的实例对象之间的绑定关系。
				P：
					表示逻辑处理器。对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等。它维护一个局部 Goroutine 可运行 G 队列，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列，这可以大大减少锁冲突，提高工作线程的并发性，并且可以良好的运用程序的局部性原理。
			2.go关键字就是用来创建一个goroutine的，后面的函数就是这个goroutine需要执行的代码逻辑。go关键字对应到调度器的接口就是runtime·newproc。runtime·newproc干的事情很简单，就负责制造一块砖(G)，然后将这块砖(G)放入当前这个地鼠(M)的小车(P)中。每个新的goroutine都需要有一个自己的栈，G结构的sched字段维护了栈地址以及程序计数器等信息，这是最基本的调度信息，也就是说这个goroutine放弃cpu的时候需要保存这些信息，待下次重新获得cpu的时候，需要将这些信息装载到对应的cpu寄存器中。				
			3.当我们使用 go 关键字之后，就会调用底层的 runtime.newproc() 函数，创建 goroutine 的同时，也会初始化栈空间，上下文 等信息。
			4.程序支持最多的goroutine并行,是取决于GOMAXPROCS来确定的
			5.P的本地队列,最大仅支持256个G(也就是256个goroutine)
			6.在程序运行时创建，它是 Go 后台运行的一个系统线程池。GMP 的目的是为了支持协程（goroutine）的创建、调度和垃圾回收。
			其中:
				M0
					启动程序后的编号为0的主线程
					在全局变量runtime.m0中，不需要在heap上分配
					负责执行初始化操作和启动第一个G(可以理解为程序的main函数)
					启动第一个G之后，MO就和其他的M一样了
				G0
					每次启动一个M，都会第一个创建的gourtine，就是G0
					G0仅用于给当前的M进行负责调度的G(G0是存在M0的结构体中的)
					G0不指向任何可执行的函数
					每个M都会有一个自己的G0
					在调度或系统调用时会使用M会切换到GO,来调度
					M0的G0会放在全局空间
			7.开始执行程序
				1.创建进程
				2.创建线程M0
				3.M0创建G0(每个M都会有自己的G0,其中G0是第一个G(main函数)的调度者,并没有实际的func来执行)
				4.根据配置文件创建P(包括本地队列与全局队列)
				5.M0启动第一个G(就是main函数),并放入到到对应P的队列当中,然后按照正常从P的队列中取出mian函数并执行
				6.如果main有阻塞,则M会将mian重新放回P的队列中,再次执行
			注:
				1.G中由M新创建的G是优先加入当前P的本地队列
				2.如果G执行完毕,M会调用G0获取环境变量,再从P中的本地队列调用下个G
				3.从全局队列获取G的数量是 min(全局队列中G的数量/M的数量 + 1, 全局队列中G的数量 / 2)
				4.GOMAXPROCS是限定P的数量
				5.自旋线程的数量限制: 执行M + 自旋M <= GOMAXPROCS
				6.G0可以执行任何Goroutine，而P只能执行与自己关联的Goroutine。当Goroutine在一个P上运行时，它将成为该P的一个任务，一旦它完成或者阻塞，该P将选择另一个任务执行。
				7. G0只有一个，是程序的主线程，它负责调度和管理所有的P，包括创建和销毁P，以及在需要时向P分配G等。
				8. P是Go语言运行时系统中的一组处理器，用来执行Goroutine。P的数量由Go运行时系统自动调整，每个P都拥有自己的本地调度器（LTS），它负责调度和管理与自己关联的Goroutine。
		3.GC(必会)
		4.CGO(必会)
		5.反射(必会)
		6.并发编程(必会)
			1.goroutine调度
			2.channel调度
			3.锁
				1.mutex
				2.rwmutex
			4.waitGroup
			5.context
			6.sync
			7.原子操作 atomic
		7.测试(必会)
			1.单元测试
			2.压力测试
			3.覆盖测试
			4.性能测试
		8.数据结构与算法(必会)
		9.操作系统(必会)
			1.熟悉5种网络IO模型原理
			2.熟悉IO多路复用技术原理
			3.熟悉socket和多线程编程
		10.计算机原理与网络(必会)
			1.熟悉常见网络协议原理
			2.熟悉常见序列化协议原理
		11.缓存(必会)
			1.深入理解Redis核心数据类型使用场景和内部实现
			2.深入理解Redis线程模型
			3.熟悉持久化方式
			4.熟悉数据过期策略
			5.熟悉数据淘汰策略
			6.熟悉分布式锁实现
			7.熟悉缓存高并发场景
		12.数据库(必会)
			1.熟悉数据库存储引擎
			2.熟悉数据库索引实现原理
			3.熟悉数据库锁
			4.熟悉数据库事务实现机制
			5.熟悉数据库主从复制
			6.熟悉数据库读写分离
			7.熟悉数据库分库分表
			8.掌握数据库常用调优手段
		13.设计模式(必会)
		14.Linux(必会)
			1.熟练掌握相关命令
				1.系统命令工具
				2.基础命令工具
				3.网络参数工具
				4.磁盘参数工具
			2.熟练掌握网络编程
	2.工程化(必会)
		1.微服务(必会)
			1.go-zero
		2.web框架(必会)
			1.gin
		3.中间件(必会)
			1.日志
				2.logrus
			2.服务发现
				4.zookeeper
			3.消息队列
				6.kafka
			4.缓存
				8.redis
			5.数据库
				10.mysql
			6.搜索引擎
				12.ElasticSearch
			7.rpc
				14.gRPC
			8.链路追踪
				16.jaeger
3.资深
	1.Go源码分析(必会)
		1.runtime源码
		2.net源码
		3.io源码
		4.map源码
		5.slice源码
		6.channel源码
		7.mutex源码
		8.gc源码
	2.中间件源码分析(推荐)
		1.MySQL源码
		2.Redis源码
		3.Kafka源码
		4.Elasticsearch源码
		5.ZooKeeper源码
		6.Flink源码
		7.RabbitMq源码
		8.Etcd源码
	3.性能优化(必会)
		1.熟练掌握常用优化手段
		2.熟练掌握常见问题排查手段
			1.pprof
			2.go tool trace
			3.火焰图
			4.gdb
			5.perf
	4.系统设计(必会)
		1.拥有一定的架构设计能力
		2.分布式ID生成器
		3.电商下单减库存支付
		4.秒杀系统
		5.短链接系统
		6.微博
	5.服务稳定性(必会)
		1.限流
		2.熔断
		3.降级
		4.隔离
		5.重试
		6.超时控制
		7.监控
		8.报警
		9.预案
	6.高并发实战(必会)
		1.常见技术(必会)
			1.无状态设计
			2.多线程
			3.连接池
			4.异步化
			5.并发
			6.缓存
	2.数据库(必会)
		1.表优化
		2.索引优化
		3.读写分离
		4.分库分表
		5.集群
	3.分布式(必会)
	4.常见问题(必会)
		1.如何避免缓存”穿透”的问题？
		2.如何避免缓存”雪崩”的问题？
		3.如何避免缓存”击穿”的问题？
		4.缓存和 DB 的一致性如何保证？
	5.分布式原理与实战
		1.分布式理论(必会)
			1.CAP
			2.BASE
			3.ACID
		2.分布式事务解决方案(必会)
			1.TCC
			2.2PC/XA
			3.3PC
			4.Seata
		3.分布式协议与算法(推荐)
			1.Paxos算法
			2.Raft算法
			3.一致性哈希算法
			4.Gossip协议
			5.Quorum NWR算法
			6.PBFT算法
			7.PoW算法
			8.ZAB协议
		4.分布式缓存(必会)
			1.Redis
		5.分布式数据库(必会)
			1.TiDB
		6.分布式搜索引擎(必会)
			1.ElasticSearch
		7.分布式存储(必会)
			1.Ceph
		8.分布式文件系统(必会)
			1.Hadoop
		9.分布式队列(必会)
			1.Kafka
			2.RabbitMq
		10.分布式协调(必会)
			1.Zookeeper
			2.Etcd
			3.Consul
		11.分布式锁(必会)
			1.Redis实现
			2.Zookeeper实现
			3.MySQL实现
		12.分布式计算(必会)
			1.Spark
			2.Storm
			3.Flink
		13.容器化(必会)
			1.Docker
			2.Kubernetes
				1.深入掌握，并有一定实际经验
		14.行业砥柱(必会)
			1.开源社区-开源贡献-开源项目
			2.图像编解码
			3.直播
			4.视频编解码
			5.游戏
			6.金融
			7.云原生
4.专家
	1.架构设计(必会)
		1.领域架构设计
		2.微服务
		3.服务网格
			1.istio
		4.云原生
		5.一定的架构落地能力
			1.具备从零搭建大型分布式系统能力
			2.引领团队
			3.公司业务执行落地
			4.具备行业城市方案
	2.解决方案(必会)
		1.实际解决过问题
		2.有线上事故的处理经验
		3.深入行业，具备实施行业领先解决方案的能力
	3.开源项目(必会)
		1.主导或参与过开源项目
		2.为知名开源项目贡献过源码
	4.高并发(必会)
		1.具备应对高并发的能力
		2.对计算机、网络基础设施、数据库都需要有深入了解
	5.容器技术(必会)
		1.深入源码
		2.具备改造能力
		3.具备造轮子能力
		4.Kubernetes
		5.Docker
</pre>