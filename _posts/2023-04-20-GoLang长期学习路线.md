---
title: GoLang长期学习路线
author: Yahui
layout: go
category: Go
---

书名:《-》

<pre style="text-align: left;">
go可以做的事情:
	1.服务端开发：以前你使用C或者C++做的那些事情，用Go来做很合适，例如日志处理、文件系统、监控系统等;
	2.DevOps：运维生态中的Docker、K8s、prometheus、grafana、open-falcon等都是使用Go语言开发;
	3.网络编程：大量优秀的Web框架如Echo、Gin、Iris、beego等，而且Go内置的 net/http包十分的优秀;
	4.Paas云平台领域：Kubernetes和Docker Swarm等;
	5.分布式存储领域：etcd、Groupcache、TiDB、Cockroachdb、Influxdb等;
	6.区块链领域：区块链里面有两个明星项目以太坊和fabric都使用Go语言;
	7.容器虚拟化：大名鼎鼎的Docker就是使用Go语言实现的;
	8.爬虫及大数据：Go语言天生支持并发，所以十分适合编写分布式爬虫及大数据处理。
总结
	Go开发核心：深入理解计算机原理、计算机网络协议以及主流协议、数据结构与算法、Linux、MySql、Redis、MQ、RPC、微服务、k8s、docker、架构认识、分布式落地
1.初级
	1.计算机基础(必会)
		1.冯诺伊曼体系(必会)
			1.用二进制进行计算和存储
				高电平低电平主要应用于数字电路。体现在电路上就是只有‘有’和‘无’，没有中间值，这个有在不同电路上的电压值不相同。
			2.基本结构
				输入设备(键盘，鼠标，摄像头，网卡和硬盘等)，输出设备(键盘，鼠标，摄像头，网卡和硬盘等)，存储器(内存)，控制器，运算器。
			3.CPU
				指令由控制单元分配到逻辑单元，经过加工处理之后，再送到存储单元里等待应用程序的使用。
			4.存储器
			5.总线
			6.输入设备
			7.输出设备
		2.计算机网络(必会)
			1.网络协议
				1.物理层:
					解决硬件之间怎么通信的问题,常见的物理媒介有电缆、光纤、无线电波等,实现了相邻计算机节点之间比特流的透明传送,并尽可能地屏蔽掉具体传输介质和物理设备的差异,使其上层(数据链路层)不必关心网络的具体传输介质。
				2.数据链路层:
					接收来自物理层的位流形式的数据,并封装成帧,传送到上一层；同样,也将来自上层的数据帧,拆装为位流形式的数据转发到物理层。由于各种干扰的存在,物理链路是不可靠的,这一层在物理层提供的比特流的基础上通过差错控制、流量控制方法,使有差错的物理线路变为无差错的数据链路,即提供可靠的通过物理介质传输数据的方法。
				3.网络层:IP/ICMP/IGMP
					将网络地址翻译成对应的物理地址,通过路由选择算法,为报文（该层的数据单位,由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址,通过IP地址寻址,所以产生了IP协议。
				4.传输层:TCP/UDP
					当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。
					简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输
				5.会话层:
					建立和管理应用程序之间的通信,用户应用程序和网络之间的接口,建立通信链接,保持会话过程通信链接的畅通,同步两个节点之间的对话,决定通信是否被中断以及通信中断时决定从何处重新发送。
				6.表示层:
					不同系统之间的通信语法问题(比如windows与Linux通信),数据的编码,压缩和解压缩,数据的加密和解密,对来自应用层的命令和数据进行解释,以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。
				7.应用层:HTTP/HTTPS/FTP/SSH/SMTP/TELNET
					负责完成网络中应用程序与网络操作系统之间的联系,建立与结束使用者之间的联系,并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外,该层还负责协调各个应用程序间的工作
				<span class="image featured"><img src="{{ 'assets/images/other/osi_netmodel.png' | relative_url }}" alt="" /></span>
			2.序列化协议
				文本类序列化方式,虽然可读性比较好,但是性能较差,一般不会选择
					XML
					JSON
				二进制序列化,跨语言,多语言支持.序列化反序列化效率高,文件体积小,比json小一倍.兼容json数据格式.
					MessagePack
						import "github.com/vmihailenco/msgpack/v5"
						func main() {
						    b, err := msgpack.Marshal(&Item{Foo: "bar"})
						    if err != nil {
						        panic(err)
						    }

						    var item Item
						    err = msgpack.Unmarshal(b, &item)
						    if err != nil {
						        panic(err)
						    }
						    fmt.Println(item.Foo)
						    // Output: bar
						}
			3.七层体系结构
			4.四层体系结构
		3.操作系统(必会)
			1.进程、线程、协程的区别
				进程
					进程是程序一次动态执行的过程，是程序运行的基本单位。
					每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。
					进程占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、页表、文件句柄等）比较大，但相对比较稳定安全。协程切换和协程切换
				线程
					线程又叫做轻量级进程，是CPU调度的最小单位。
					线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。
					多个线程共享所属进程的资源，同时线程也拥有自己的专属资源。
					程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
				协程
					协程是一种用户态的轻量级线程，协程的调度完全由用户控制。
					一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。
					与其让操作系统调度，不如我自己来，这就是协程
			2.进程间常用的通信方式
				进程间常用的通信
					1.管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。通过内核缓冲区实现数据传输
					2.有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。有名管道以磁盘文件的方式存在，在系统中有对应的路径可以实现本机任意两个进程通信。管道的本质是内核维护了一块缓冲区与管道文件相关联，对管道文件的操作被内核转换成对这块缓冲区内存的操作。
					3.信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
					4.消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
					5.信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。
					6.共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
					7.套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。
				线程间常用的通信
					1.互斥量 (锁) 只有拥有互斥量的线程才能执行任务
					2.信号量 (PV)  信号量是一个计数器
					3.事件 目事件机制，允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务.
			3.5种网络IO模型
				同步IO
					阻塞 IO（blocking IO）
						默认情况下所有的 socket 都是 blocking
						当用户进程调用了 read 这个系统调用，kernel 就开始了 IO 的第一个阶段：准备数据。对于 network io 来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的数据包）这个时候 kernel 就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当 kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存，然后 kernel 返回结果，用户进程才解除 block 的状态，重新运行起来
					非阻塞 IO（non-blocking IO）
						当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回，所以，在非阻塞式 IO 中，用户进程其实是需要不断的主动询问 kernel数据准备好了没有。
					多路复用 IO（IO multiplexing）
						select
							调用 select 会把所有要管理的 socket 的 fd (文件描述符，Linux下皆为文件，简单理解就是通过 fd 能找到这个 socket)传到内核中,遍历所有 socket，看看是否有感兴趣的事件发生。如果没有一个 socket 有事件发生，那么 select 的线程就需要让出 cpu 阻塞等待，这个等待可以是不设置超时时间的死等，也可以是设置 timeout 的有超时时间的等待。
							当 socket 接收到网卡的数据后，就会去它的睡眠队列里遍历 entry，调用 entry 设置的 callback 方法，这个 callback 方法里就能唤醒 select ！
							所以 select 在每个被它管理的 socket 的睡眠队列里都塞入一个与它相关的 entry，这样不论哪个 socket 来数据了，它立马就能被唤醒然后干活！
							但是，select 的实现不太好，因为唤醒的 select 此时只知道来活了，并不知道具体是哪个 socket 来数据了，所以只能傻傻地遍历所有 socket ，看看到底是哪个 scoket 来活了，然后把所有来活的 socket 封装成事件返回
							(因为被管理的 socket fd 需要从用户空间拷贝到内核空间，为了控制拷贝的大小而做了限制，即每个 select 能拷贝的 fds 集合大小只有1024)
						poll
							poll 这玩意相比于 select 主要就是优化了 fds 的结构，不再是 bit 数组了，而是一个叫 pollfd 的玩意，反正就是不用管啥 1024 的限制了。(现在也没人用 poll，就不多说了)
						epoll
							select存在的问题
								1.比如，为什么每次 select 需要把监控的 fds 传输到内核里？不能在内核里维护个？
								2.为什么 socket 只唤醒 select，不能告诉它是哪个 socket 来数据了？
								epoll 主要就是基于上面两点做了优化。
							过程
								1.搞了个叫 epoll_ctl 的方法，这方法就是用来管理维护 epoll 所监控的哪些 socket(这个 socket 集合是用红黑树实现的)
								2.然后和 select 类似，每个 socket 的睡眠队列里都会加个 entry，当每个 socket 来数据之后，同样也会调用 entry 对应的 callback。
								3.与 select 不同的是，引入了一个 ready_list 双向链表，callback 里面会把当前的 socket 加入到 ready_list 然后唤醒 epoll。
								4.这样被唤醒的 epoll 只需要遍历 ready_list 即可
					信号驱动 IO（signal driven I/O， SIGIO）
				异步IO
					用户进程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel的角度，当它收到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了
			4.并发与并行的区别
				并发：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。
				并行：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务是同时运行。
			5.同步与异步的区别
				同步：就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。这时程序是阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 因此 简单的说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。
				异步：与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。
			6.阻塞与非阻塞的区别
				阻塞：调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
				非阻塞：调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。
			7.常见缓存淘汰算法
				LFU(Least Frequently Used)：最近最不常用算法，根据数据的历史访问频率来淘汰数据。
					1.在缓存中查找客户端需要访问的数据
					2.如果缓存命中，则将访问的数据从队列中取出，并将数据对应的频率计数加1，然后将其放到频率相同的数据队列的头部，比如原来是A(10)->B(9)->C(9)->D(8),D被访问后，它的time变成了9，这时它被提到A和B之间，而不是继续在C后面
					3.如果没有命中，表示缓存穿透，将需要访问的数据从磁盘中取出，加入到缓存队列的尾部，记频率为1，这里也是加入到同为1的那一级的最前面
					4.如果此时缓存满了，则需要先置换出去一个数据，淘汰队列尾部频率最小的数据，然后再在队列尾部加入新数据。
					缺点
						某些数据短时间内被重复引用，并且在很长一段时间内不再被访问。由于它的访问频率计数急剧增加，即使它在相当长的一段时间内不会被再次使用，也不会在短时间内被淘汰。这使得其他可能更频繁使用的块更容易被清除，此外，刚进入缓存的新项可能很快就会再次被删除，因为它们的计数器较低，即使之后可能会频繁使用。
				LRU（Least Recently User） 最近最少使用算法,根据数据的历史访问记录来进行淘汰数据
					1.在缓存中查找客户端需要访问的数据 如果缓存命中，则将访问的数据中队列中取出，重新加入到缓存队列的头部。
					2.如果没有命中，表示缓存穿透，将需要访问的数据从磁盘中取出，加入到缓存队列的尾部；
					3.如果此时缓存满了，淘汰队列尾部的数据，然后再在队列头部加入新数据。
					缺点
						缓存污染：如果某个客户端访问大量历史数据时，可能使缓存中的数据被这些历史数据替换，其他客户端访问数据的命中率大大降低。
				FIFO（First in First out），先进先出算法,最先进入的数据,最先被淘汰。
					最近刚访问的，将来访问的可能性比较大 ,如果一个数据最先进入缓存中，则应该最早淘汰掉。
				2Q（Two queues）
					有两个缓存队列，一个是FIFO队列，一个是LRU队列。当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。
		4.数据结构与算法(必会)
			1.时间/空间复杂度
				一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
				空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。
			2.熟悉常用数据结构
				1.字符串
				2.数组
				3.链表
				4.队列
				5.二叉树
				6.栈
				7.堆
			3.熟悉常用算法
				1.双指针
				2.左右指针
				3.排序
				4.二叉查找
				5.递归
				6.回溯
				7.贪心
				8.动态规划
		5.数据库(必会)
			1.关系型数据库
				1.MariaDB
				2.Mysql(必会)
				3.Oracle
			5.NoSQL
				1.Redis(必会)
				2.MongoDB
				3.LevelDB
				4.Memcache
		6.Internet(必会)
			1.互联网是如何工作的
				IP地址:标识设备和网络寻址
				IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。
				子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。子网掩码不能单独存在，它必须结合IP地址一起使用。
				MAC地址也叫物理地址、硬件地址，由网络设备制造商生产时烧录在网卡(Network lnterface Card)的EPROM(一种闪存芯片，通常可以通过程序擦写)。IP地址与MAC地址在计算机里都是以二进制表示的，IP地址是32位的，而MAC地址则是48位的
			2.HTTP是什么
				HTTP使用TCP作为传输层协议，并采用请求-响应模型来进行通信。
			3.浏览器以及浏览器如何运作
				1. 解析URL：当用户在浏览器中输入URL时，浏览器会将这个URL解析成协议名、主机名、端口号、路径等信息。
				2. 建立连接：浏览器通过解析到的主机名和端口号建立与服务器的连接。
				3. 发送请求：浏览器向服务器发送HTTP请求，请求中包括请求方法、对应的资源路径、HTTP版本、请求头信息等。
				4. 接收响应：服务器接收到请求后，会返回对应的HTTP响应码和响应体。浏览器接收到响应后会根据响应码执行相应的操作。
				5. 渲染页面：如果响应是HTML页面，浏览器会根据HTML解析出DOM树，再根据CSS解析出CSSOM树，最后将两者进行合并形成Render Tree，然后进行页面渲染。
				6. 用户交互和维护：当用户与页面进行交互时，浏览器会触发相应的事件，执行相关的JavaScript代码以更新页面内容。同时，浏览器会维护浏览历史、Cookie、缓存等信息以提高浏览器的使用体验。
			4.域名是什么
			5.hosting是什么
	2.Go编程基础(必会)
		1.开发环境(必会)
			1.go安装
				下载源码包安装
			2.go环境变量
				// 查看
				go env
				// 修改
				go env -w GOOS=windows
			3.go模块
				go mod init ⽣成 go.mod ⽂件
				go mod download 下载 go.mod ⽂件中指明的所有依赖
				go mod tidy 整理现有的依赖
				go mod graph 查看现有的依赖结构
				go mod edit 编辑 go.mod ⽂件
				go mod vendor 导出项⽬所有的依赖到vendor⽬录
				go mod verify 校验⼀个模块是否被篡改过
				go mod why 查看为什么需要依赖某模块
		2.基础(必会)
			1.字面量
			2.常量
			3.变量
			4.类型
			5.操作符
			6.表达式
			7.语句
			8.错误处理
				1.经典 Go 逻辑
					// ZooTour struct
					type ZooTour interface {
					    Enter() error
					    VisitPanda(panda *Panda) error
					    Leave() error
					}

					// 分步处理，每个步骤可以针对具体返回结果进行处理
					func Tour(t ZooTour1, panda *Panda) error {
					    if err := t.Enter(); err != nil {
					        return errors.WithMessage(err, "Enter failed.")
					    }
					    if err := t.VisitPanda(); err != nil {
					        return errors.WithMessage(err, "VisitPanda failed.")
					    }
					    // ...

					    return nil
					}
				2.屏蔽过程中的 error 的处理
					type ZooTour interface {
					    Enter() error
					    VisitPanda(panda *Panda) error
					    Leave() error
					    Err() error
					}

					func Tour(t ZooTour, panda *Panda) error {

					    t.Enter()
					    t.VisitPanda(panda)
					    t.Leave()

					    // 集中编写业务逻辑代码,最后统一处理error
					    if err := t.Err(); err != nil {
					        return errors.WithMessage(err, "ZooTour failed")
					    }
					    return nil
					}
				3. 利用函数式编程延迟运行
					type Walker interface {
					    Next MyFunc
					}
					type SliceWalker struct {
					    index int
					    funs []MyFunc
					}

					func NewEnterFunc() MyFunc {
					    return func(t ZooTour) error {
					        return t.Enter()
					    }
					}

					func BreakOnError(t ZooTour, walker Walker) error {
					    for {
					        f := walker.Next()
					        if f == nil {
					            break
					        }
					        if err := f(t); err := nil {
					          // 遇到错误break或者continue继续执行
					      }
					    }
					}
				case 1: 如果业务逻辑不是很清楚，比较推荐
				case 2: 代码很少去改动，类似标准库，可以使用
				case 3: 比较复杂的场景，复杂到抽象成一种设计模式
		3.代码组织(必会)
			1.工作区
				1.go mod中replace使用
					1.vim go.mod
						module gin_demo
						go 1.20
						require (
							k8s.io/cloud-provider v0.0.0
							...
						)
						// 这里就是将包替换为本地的包
						replace (
							k8s.io/api = ./staging/src/k8s
							...
						)
				2.go work使用
					1.使用场景
						1.Go 1.18中的工作区可以让你同时处理多个模块，而不必为每个模块编辑go.mod文件。在解决依赖关系时，工作区中的每个模块都被视为根模块。
						2.以前，如果要在一个模块中增加一个功能，并在另一个模块中使用，你需要在第一个模块中发布修改，或者编辑依赖模块的go.mod文件，为你的本地未发布的模块变化添加replace指令。为了不出错地发布，你必须在向第一个模块发布本地修改后，从依赖模块的go.mod文件中删除replace指令。
					2.使用方法
						1.go.work文件有use和replace指令，可以覆盖各个go.mod文件，所以不需要单独编辑每个go.mod文件
						2.可以通过运行go work init来创建一个工作区，并将模块目录列表作为空格分隔的参数。工作区不需要包含你正在使用的模块。init命令创建一个go.work文件，列出工作区的模块。如果你在运行go work init时没有参数，该命令会创建一个空的工作区。
						3.要向工作区添加模块，可以运行go work use [moddir] 或手动编辑go.work文件。运行go work use -r来递归添加参数目录中带有go.mod文件的目录到你的工作区。如果一个目录没有go.mod文件，或者不再存在，使用use指令的目录将会从go.work文件中删除。
						4.要在你的工作区中使用一个本地模块或特定版本作为依赖，运行go work use [path-to-module]。
						5.要替换你的模块的go.mod文件中的现有依赖关系，请使用go work replace [path-to-module]。
						6.要添加你的GOPATH或任何目录中的所有模块，运行go work use -r来递归地添加有go.mod文件的目录到你的工作区。如果一个目录没有go.mod文件，或者不再存在，使用use指令的目录将会从 go.work文件中删除。
						7.go work sync：将go.work文件中的依赖关系推回到每个工作区模块的go.mod文件中。
			2.代码包
				所有Go源码都是包得一部分。
				每个Go源文件都起始于一条package语句。
				命名最好是驼峰,不建议使用_(多一位),简短
			3.源码文件
				go build -o 指定文件目录 go文件
			4.代码块
		4.设计模式(推荐)
			1.设计模式六大原则
				1.开闭原则
					对于扩展是开放的，对于更改是封闭的。
					开闭原则被称为面向对象设计的基石，实际上，其他原则都可以看作是实现开闭原则的工具和手段。
				2.里氏替换原则
					子类可以扩展父类的功能，但是不能改变父类原有的功能。
				3.依赖倒转原则
					高层模块不应该依赖底层模块，二者都应该依赖其抽象了；抽象不依赖细节；细节应该依赖抽象、接口编程。
				4.接口隔离原则
					接口尽量细化，同时保证接口中的方法尽量的少。
				5.迪米特法则
					一个类对自己需要耦合或者调用的类知道的最少，你类内部怎么复杂，我不管，那是你的事，我只知道你有那么多公用的方法，我能调用。
				6.单一职责原则
					一个类只负责一个职责
			2.23钟常见设计模式
				1.行为型模式
				2.结构型模式
				3.创建型模式
		5.标准库(必会)
			1.功能型
				1.net
					cn, err := net.Dial("tcp", "localhost:8080")
						// cn中所包含的方法
						Read(b []byte) (n int, err error)
						Write(b []byte) (n int, err error)
						Close() error
						LocalAddr() Addr
						RemoteAddr() Addr
						SetDeadline(t time.Time) error
						SetReadDeadline(t time.Time) error
						SetWriteDeadline(t time.Time) error
					l, err := net.Listen("tcp", ":8080")
						// l中所包含的方法
						Accept() (Conn, error)
						Close() error
						Addr() Addr
				2.errors
					// error是interface类型
					type error interface {
						Error() string
					}
					// error包中New返回的是一个结构体
					func New(text string) error {
						return &errorString{text}
					}
					type errorString struct {
						s string
					}
					func (e *errorString) Error() string {
						return e.s
					}
				3.os
					1. 文件系统
						对于文件系统的访问，在os包中提供了文件操作相关的函数，例如Create和Open函数：Create函数可以创建一个文件并返回一个文件句柄，Open函数可以打开一个文件并返回一个文件句柄。这些函数在不同的操作系统上实现的方式可能不同。
					2. 环境变量
						在os包中，可以使用Environ函数来获取当前进程的环境变量。它会返回一个字符串切片，每个元素都是“键=值”的形式。可以使用Setenv函数来设置环境变量，使用Unsetenv函数来删除环境变量。
					3. 进程管理
						在os包中，StartProcess函数可以用于启动一个新的进程，并返回一个Process类型的值，该类型表示当前进程所在的进程。这个函数在不同的操作系统上的实现方式可能不同，因此Process类型的组成和相关方法可能有所不同。
					4. 信号处理
						在操作系统中，信号是一种异步事件，因此需要使用操作系统提供的相关函数和类型进行处理。在os包中，Signal函数可以用于注册信号处理函数，Wait函数可以用于等待信号的到来并进行处理。
					5. 用户和组管理
						在操作系统中，用户和组是管理系统权限和访问控制的重要部分。在os包中，User和Group类型分别表示用户和组。当前用户可以使用CurrentUser函数获取，Getegid和Geteuid函数可以获取当前用户是属于哪个组。Getgroups函数可以获取当前用户属于哪些组。
				4.sync
					1.锁机制是同步机制中最基本的一种，主要是保证多个goroutine之间对于共享数据的操作能够正确地被执行。一般有两种锁机制：互斥锁和读写锁。
						1.互斥锁被广泛应用于go语言的并发编程当中，其背后的原理就是独占锁。当某个goroutine获取到了锁，其他goroutine就需要等待，直到锁被释放，这时候才能再次尝试获取锁。互斥锁通过Mutex结构体来实现，其主要方法有：
							- Lock：获取并持有锁，如果锁已被持有，则当前goroutine就会被阻塞；
							- Unlock：释放锁，如果当前并没有任何goroutine尝试获取锁，则该操作会非常快速；
							- TryLock：尝试获取锁，如果获取到了，则返回true，否则返回false。
						2读写锁是另一种锁机制，其主要用于读多写少场景。在读写锁中，读锁是共享锁，可以同时被多个goroutine持有，而写锁是独占锁，只能由一个goroutine来持有。读写锁通过RWMutex结构体来实现，其主要方法有：
							- RLock：获取并持有读锁，如果已经有goroutine持有写锁或正在等待获取写锁，则当前goroutine会被阻塞；
							- RUnlock：释放读锁；
							- Lock：获取并持有写锁，所以等待获取或者持有读锁和写锁的goroutine都会被阻塞；
							- Unlock：释放写锁。
						// 通过原子操作来将互斥锁的状态从未锁定（0）状态修改为锁定状态
						atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked)
						// 实现锁的加锁操作
						m.lockSlow()
					2.条件变量机制主要用于通知goroutine某个条件是否已经满足，只有当某个条件被满足时，才会释放锁，让其他等待同步的goroutine继续执行。
						1.条件变量机制通过Cond结构体来实现，其主要方法有：
							- Wait：进入条件等待，释放锁并阻塞当前goroutine，直到被唤醒；
							- Signal：唤醒一个goroutine，使其从条件等待中醒来；
							- Broadcast：唤醒所有等待同一条件的goroutine。
						w := sync.WaitGroup{}
						w.Add(1)
						w.Done()
						w.Wait()
						sync包WaitGroup内 state的高32位和低32位分别表示等待的goroutine的数量和是否已完成的标志位。
						高32位用于表示需要等待的goroutine数量，即计数器的值，该计数器代表还有多少个goroutine尚未完成并需要等待。调用Wait()时会阻塞，直至计数器的值归零。
						低32位用于表示是否已完成的标志位，该标志位用于表示WaitGroup是否已经完成。当WaitGroup内部计数器的值归零时，该标志位会被设置为已完成，表示所有等待的goroutine都已经完成，此时WaitGroup的所有等待都可以结束。
						(主要通过使用runtime_Semacquire(&wg.sema)来等待计数器归零)
						通过将低32位设置为1，可以在WaitGroup内部防止再次添加等待的goroutine，即不能对已关闭的WaitGroup对象再次添加等待的goroutine。这样可以避免在WaitGroup对象已经被销毁的情况下继续调用其方法，从而避免资源泄漏和运行时错误
				5.time
					1.time.Time
						1.time.Time表示一个具体时间点，类似于C中的time_t类型。它存储了一个64位整数来表示自UTC-1970年1月1日0时0分0秒起经过的纳秒数。time.Time有很多方法可以转化为各种形式的字符串、比较不同时间等。
						2.time.Duration表示一个时间间隔，它也是一个64位的整数，单位为纳秒。
					2.时间格式化
						time.Format()，可以将一个time.Time类型的时间转换为字符串。
							t := time.Now()
							fmt.Println(t.Format("2006-01-02 15:04:05"))
							//Output: 2021-10-01 14:30:10
					3. 时间解析
						除了将时间转换为字符串，Golang中还提供了将字符串解析为时间的函数time.Parse()。如下例：
						t, _ := time.Parse("2006-01-02 15:04:05", "2021-10-01 14:30:10")
						fmt.Println(t)
					4. 时间比较
						t1 := time.Now()
						t2 := time.Now().Add(time.Duration(1) * time.Hour)
						if t1.After(t2) / t1.Before(t2) ...
					5. 定时器
						1.延迟执行
							// 延迟1秒执行
							c := time.NewTimer(time.Second)
							<-c.C
						2.循环执行
							// 每一秒执行
							d := time.NewTicker(time.Second)
							for {
								<-d.C
							}
			2.输入输出型
				1.io
					1.io.Reader / io.Writer
						一个实现了io.Reader接口的对象可以被用来从某处读取数据，而实现了io.Writer接口的对象则可以用来向某处写入数据。一些常用的实现这两个接口的类型有File（读写文件）、strings.Reader（读取字符串）、bytes.Buffer（读写内存）等等。
					2. io.Copy
						复制操作是I/O编程中最常见的任务之一。Golang提供了一个方便的方法来复制（拷贝）源文件或者reader的内容到目标文件或者writer，即io.Copy()。
					3. io.ReadFull / io.WriteString
						io包还提供了一些常用的辅助函数，比如io.ReadFull()可以读取一个指定长度的字节流（如果读取不到指定长度的字节，将返回错误），io.WriteString()可以将一个字符串写入到一个writer中。

					4. io.Pipe
						io.Pipe()返回一对关联的*Pipe对象，可用于在不同的goroutine之间传递数据。一个*Pipe对象有两个方法，Read()和Write()。调用Read()方法会阻塞直到有数据可读；调用Write()方法会阻塞直到所有写入的数据都被读取。
				2.fmt
					// 该函数用于将格式化的字符串输出到标准输出流，常用于控制台输出。
					fmt.Printf(format string, a ...interface{})
					// 自动在字符串末尾添加一个换行符，并输出到控制台。
					fmt.Println(a ...interface{})
					// 但是不输出换行符，输出到控制台。
					fmt.Print(a ...interface{})
					// 该函数和Printf函数类似，但是不输出到控制台，而是返回一个格式化后的字符串。
					fmt.Sprintf(format string, a ...interface{})
					// 该函数用于将格式化的字符串和错误码（code）封装成一个错误类型，返回给调用者。
					fmt.Errorf(format string, a ...interface{}) error
						err := fmt.Errorf("code:%d, error:%s", 404, "Not Found")
					    if errors.Is(err, fmt.Errorf("code:%d, error:%s", 404, "Not Found")) {
					        fmt.Println("Error:", err)
					    }
					// 其中的io.Writer是一个接口，可以是各种实现了该接口的类型，例如文件、网络连接等。
					func Fprint(w io.Writer, a ...interface{}) (n int, err error)
						txt1 := "Hello"
					    txt2 := "World"
					    _, _ := fmt.Fprint(os.Stdout, txt1, ", ", txt2)
					    (fmt.Print就是调用的fmt.Fprint)
				3.log
					- func Print(v ...interface{})：打印普通日志消息
					- func Printf(format string, v ...interface{})：打印格式化的日志消息
					- func Println(v ...interface{})：打印带换行符的日志消息
					- func Fatal(v ...interface{})：打印致命错误消息并退出程序
					- func Fatalf(format string, v ...interface{})：打印格式化的致命错误消息并退出程序
					- func Fatalln(v ...interface{})：打印带换行符的致命错误消息并退出程序
					- func Panic(v ...interface{})：打印错误消息并引发panic
					- func Panicf(format string, v ...interface{})：打印格式化的错误消息并引发panic
					- func Panicln(v ...interface{})：打印带换行符的错误消息并引发panic

					log包中默认的输出流是标准错误（stderr）。可以使用SetOutput函数更改输出流。例如，要将日志消息输出到文件中，可以使用以下代码：
					可以将日志输入到文件中
						file, err := os.OpenFile("./a.txt", os.O_WRONLY|os.O_CREATE|os.O_APPEND, 777)
						if err != nil {
							log.Fatal(err)
						}
						defer file.Close()
						log.SetOutput(file)
						log.SetFlags(log.Ldate | log.Ltime)
						log.Println("asdfasdfassad")
		6.版本控制(必会)
			1.Git
2.高级
	1.Go编程进阶(必会)
		1.原理(必会)
			1.map
			2.channel
			3.goroutine
			4.slice
			5.runtime
		2.GMP模型(必会)
		3.GC(必会)
		4.CGO(必会)
		5.反射(必会)
		6.并发编程(必会)
			1.goroutine调度
			2.channel调度
			3.锁
				1.mutex
				2.rwmutex
			4.waitGroup
			5.context
			6.sync
			7.原子操作 atomic
		7.测试(必会)
			1.单元测试
			2.压力测试
			3.覆盖测试
			4.性能测试
		8.数据结构与算法(必会)
		9.操作系统(必会)
			1.熟悉5种网络IO模型原理
			2.熟悉IO多路复用技术原理
			3.熟悉socket和多线程编程
		10.计算机原理与网络(必会)
			1.熟悉常见网络协议原理
			2.熟悉常见序列化协议原理
		11.缓存(必会)
			1.深入理解Redis核心数据类型使用场景和内部实现
			2.深入理解Redis线程模型
			3.熟悉持久化方式
			4.熟悉数据过期策略
			5.熟悉数据淘汰策略
			6.熟悉分布式锁实现
			7.熟悉缓存高并发场景
		12.数据库(必会)
			1.熟悉数据库存储引擎
			2.熟悉数据库索引实现原理
			3.熟悉数据库锁
			4.熟悉数据库事务实现机制
			5.熟悉数据库主从复制
			6.熟悉数据库读写分离
			7.熟悉数据库分库分表
			8.掌握数据库常用调优手段
		13.设计模式(必会)
		14.Linux(必会)
			1.熟练掌握相关命令
				1.系统命令工具
				2.基础命令工具
				3.网络参数工具
				4.磁盘参数工具
			2.熟练掌握网络编程
	2.工程化(必会)
		1.微服务(必会)
			1.go-zero
		2.web框架(必会)
			1.gin
		3.中间件(必会)
			1.日志
				2.logrus
			2.服务发现
				4.zookeeper
			3.消息队列
				6.kafka
			4.缓存
				8.redis
			5.数据库
				10.mysql
			6.搜索引擎
				12.ElasticSearch
			7.rpc
				14.gRPC
			8.链路追踪
				16.jaeger
3.资深
	1.Go源码分析(必会)
		1.runtime源码
		2.net源码
		3.io源码
		4.map源码
		5.slice源码
		6.channel源码
		7.mutex源码
		8.gc源码
	2.中间件源码分析(推荐)
		1.MySQL源码
		2.Redis源码
		3.Kafka源码
		4.Elasticsearch源码
		5.ZooKeeper源码
		6.Flink源码
		7.RabbitMq源码
		8.Etcd源码
	3.性能优化(必会)
		1.熟练掌握常用优化手段
		2.熟练掌握常见问题排查手段
			1.pprof
			2.go tool trace
			3.火焰图
			4.gdb
			5.perf
	4.系统设计(必会)
		1.拥有一定的架构设计能力
		2.分布式ID生成器
		3.电商下单减库存支付
		4.秒杀系统
		5.短链接系统
		6.微博
	5.服务稳定性(必会)
		1.限流
		2.熔断
		3.降级
		4.隔离
		5.重试
		6.超时控制
		7.监控
		8.报警
		9.预案
	6.高并发实战(必会)
		1.常见技术(必会)
			1.无状态设计
			2.多线程
			3.连接池
			4.异步化
			5.并发
			6.缓存
	2.数据库(必会)
		1.表优化
		2.索引优化
		3.读写分离
		4.分库分表
		5.集群
	3.分布式(必会)
	4.常见问题(必会)
		1.如何避免缓存”穿透”的问题？
		2.如何避免缓存”雪崩”的问题？
		3.如何避免缓存”击穿”的问题？
		4.缓存和 DB 的一致性如何保证？
	5.分布式原理与实战
		1.分布式理论(必会)
			1.CAP
			2.BASE
			3.ACID
		2.分布式事务解决方案(必会)
			1.TCC
			2.2PC/XA
			3.3PC
			4.Seata
		3.分布式协议与算法(推荐)
			1.Paxos算法
			2.Raft算法
			3.一致性哈希算法
			4.Gossip协议
			5.Quorum NWR算法
			6.PBFT算法
			7.PoW算法
			8.ZAB协议
		4.分布式缓存(必会)
			1.Redis
		5.分布式数据库(必会)
			1.TiDB
		6.分布式搜索引擎(必会)
			1.ElasticSearch
		7.分布式存储(必会)
			1.Ceph
		8.分布式文件系统(必会)
			1.Hadoop
		9.分布式队列(必会)
			1.Kafka
			2.RabbitMq
		10.分布式协调(必会)
			1.Zookeeper
			2.Etcd
			3.Consul
		11.分布式锁(必会)
			1.Redis实现
			2.Zookeeper实现
			3.MySQL实现
		12.分布式计算(必会)
			1.Spark
			2.Storm
			3.Flink
		13.容器化(必会)
			1.Docker
			2.Kubernetes
				1.深入掌握，并有一定实际经验
		14.行业砥柱(必会)
			1.开源社区-开源贡献-开源项目
			2.图像编解码
			3.直播
			4.视频编解码
			5.游戏
			6.金融
			7.云原生
4.专家
	1.架构设计(必会)
		1.领域架构设计
		2.微服务
		3.服务网格
			1.istio
		4.云原生
		5.一定的架构落地能力
			1.具备从零搭建大型分布式系统能力
			2.引领团队
			3.公司业务执行落地
			4.具备行业城市方案
	2.解决方案(必会)
		1.实际解决过问题
		2.有线上事故的处理经验
		3.深入行业，具备实施行业领先解决方案的能力
	3.开源项目(必会)
		1.主导或参与过开源项目
		2.为知名开源项目贡献过源码
	4.高并发(必会)
		1.具备应对高并发的能力
		2.对计算机、网络基础设施、数据库都需要有深入了解
	5.容器技术(必会)
		1.深入源码
		2.具备改造能力
		3.具备造轮子能力
		4.Kubernetes
		5.Docker
</pre>