---
title: MySQL内核-InnoDB存储引擎
author: Yahui
layout: mysql
category: MySQL
---


书名:《MySQL内核-InnoDB存储引擎》

<pre style="text-align: left;">
	
	Lock In Share Mode与For Update

	1.重做日志(存储引擎层产生的,物理逻辑格式日志;记录的是每个页的修改;事务进行中不断地写入)
		用来实现事务的持久性,即事务ACID中的D,重做日志分为两部分:
			1.内存中的重做日志缓存,是易失的
			2.重做日志文件,是持久的
		当事务commit(提交)时,必须将该事务的所有日志写入到重做日志文件进行持久化,待完成后事务commit操作才算完成
		日志主要分为两部分:
			1.redo log(保证事务的持久性)
				基本上是顺序写的,在数据库运行时不需要对该日志文件进行读取操作
			2.undo log(帮助事务回滚及MVCC功能)
				是需要进行随机读/写的
		innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略
			0:表示事务提交时并不强制一定要写入到重做日志,这个仅在master thread中完成,而master thread中每秒会进行一次重做日志文件的fsync操作,因此当MySQL发生宕机的时候,可能会发生最后一秒内事务丢失的情况.
			1(默认):事务必须将所有日志写入到磁盘
			2:事务提交时将重做日志写入到日志文件,但仅写入到文件系统的缓存中,不进行fsync操作.因此当MySQL宕机的时候,并不会导致事务数据的丢失,但是操作系统也宕机的时候,就会丢失那部分的数据.
		在InnoDB中,表空间第一个页(0,0)是一个比较特殊的页,因为仅在该页的FIL_HEADER中定义了FIL_PAGE_FILE_FLUSH_LSN,该值记录了数据库关闭时最后刷新页的LSN,这个过程在函数fil_write_flushed_lsn_to_data_files中完成,因此,如果数据库正常关闭的话,该值应该和重做日志中保存的检查点值相等,若发生异常情况,由于还未调用函数fil_write_flushed_lsn_to_data_files,必将导致两者之间的值不同,因此通过这个设计,InnoDB就会知道是否需要真正的恢复操作.
	2.二进制日志(数据库的上层生成的,是一种逻辑日志;记录的是根据对应的SQL语句;事务提交完成后进行一次写入)
		用来进行point-in-time(恢复到某个时间点)及主从复制环境的建立
	3.检查点(事务提交时,先将重做日志写入到文件,实际数据页刷新到磁盘的操作由检查点完成)
		检查点的作用就是将缓冲池中的页刷新到磁盘,最终达到外存和内存中的页数据一致
		宕机恢复:检查点的值为1000,重做日志刷新到的位置为1300,那么1000~1300之间就是日志回放的范围,若之前没有进行过任何checkpoint,那么所有的重做日志都需要进行回放
	4.页(默认是16KB)
		是InnoDB最小I/O单元,物理上连续的64个页可以组成一个区.除去头尾46个字节的开销,绝大部分空间用来存储数据
	5.区(默认1M)
		页是InnoDB存储引擎访问的最小单位,区是InnoDB存储引擎空间申请的最小单位.
	6.段(页和区混合管理的方式是出于对存储空间尽量节约的角度考虑)
		在InnoDB存储引擎中,每张表至少有两个段,聚集索引的叶子结点段,和非叶子节点段.
		以一个表为例,如果表中数据非常少,只需一个页就可以存放,如果表的段包含一个区,则大部分的空间会被浪费
	7.索引页
		虽然B+树可以定位到查询记录所在的页,但若要实际定位到查询的记录,还需要通过二叉查找法进行进一步的比较
	8.锁与事务
		InnoDB存储引擎在REPEATABLE READ隔离级别下,使用Next-Key Lock锁的算法,因此避免产生幻读,所以默认这个隔离级别就已经能保证隔离要求.
		通过主键进行加锁的语句,仅对聚集索引记录进行加锁
		通过副主索引记录进行加锁的语句,首先对辅助索引记录加锁,再对聚集索引进行加锁
		通过辅助索引记录加锁的语句,可能还需要对下一个记录进行加锁(为了避免幻读,如果是唯一索引,那么就不需要锁定下一个辅助索引记录,但是这仅对等值查询有效,对于非等值插入,不管辅助所以你是否包含唯一约束,都需要锁定下一个索引记录,从而避免幻读的产生)
</pre>