---
title: MySQL内核-InnoDB存储引擎
author: Yahui
layout: sql
category: SQL
---


书名:《MySQL内核-InnoDB存储引擎》

<pre style="text-align: left;">

	block(块)与page(页)在数据库中是相同的概念

	Lock In Share Mode与For Update

	1.重做日志(存储引擎层产生的,物理逻辑格式日志;记录的是每个页的修改;事务进行中不断地写入)
		用来实现事务的持久性,即事务ACID中的D,重做日志分为两部分:
			1.内存中的重做日志缓存,是易失的
			2.重做日志文件,是持久的
		当事务commit(提交)时,必须将该事务的所有日志写入到重做日志文件进行持久化,待完成后事务commit操作才算完成
		日志主要分为两部分:
			1.redo log(保证事务的持久性)
				基本上是顺序写的,在数据库运行时不需要对该日志文件进行读取操作
			2.undo log(帮助事务回滚及MVCC功能)
				是需要进行随机读/写的
		innodb_flush_log_at_trx_commit来控制重做日志刷新到磁盘的策略
			0:表示事务提交时并不强制一定要写入到重做日志,这个仅在master thread中完成,而master thread中每秒会进行一次重做日志文件的fsync操作,因此当MySQL发生宕机的时候,可能会发生最后一秒内事务丢失的情况.
			1(默认):事务必须将所有日志写入到磁盘
			2:事务提交时将重做日志写入到日志文件,但仅写入到文件系统的缓存中,不进行fsync操作.因此当MySQL宕机的时候,并不会导致事务数据的丢失,但是操作系统也宕机的时候,就会丢失那部分的数据.
		在InnoDB中,表空间第一个页(0,0)是一个比较特殊的页,因为仅在该页的FIL_HEADER中定义了FIL_PAGE_FILE_FLUSH_LSN,该值记录了数据库关闭时最后刷新页的LSN,这个过程在函数fil_write_flushed_lsn_to_data_files中完成,因此,如果数据库正常关闭的话,该值应该和重做日志中保存的检查点值相等,若发生异常情况,由于还未调用函数fil_write_flushed_lsn_to_data_files,必将导致两者之间的值不同,因此通过这个设计,InnoDB就会知道是否需要真正的恢复操作.
	2.二进制日志(数据库的上层生成的,是一种逻辑日志;记录的是根据对应的SQL语句;事务提交完成后进行一次写入)
		用来进行point-in-time(恢复到某个时间点)及主从复制环境的建立
	3.检查点(事务提交时,先将重做日志写入到文件,实际数据页刷新到磁盘的操作由检查点完成)
		检查点的作用就是将缓冲池中的页刷新到磁盘,最终达到外存和内存中的页数据一致
		宕机恢复:检查点的值为1000,重做日志刷新到的位置为1300,那么1000~1300之间就是日志回放的范围,若之前没有进行过任何checkpoint,那么所有的重做日志都需要进行回放
	4.页(默认是16KB)
		是InnoDB最小I/O单元,物理上连续的64个页可以组成一个区.除去头尾46个字节的开销,绝大部分空间用来存储数据
	5.区(默认1M)
		页是InnoDB存储引擎访问的最小单位,区是InnoDB存储引擎空间申请的最小单位.
	6.段(页和区混合管理的方式是出于对存储空间尽量节约的角度考虑)
		在InnoDB存储引擎中,每张表至少有两个段,聚集索引的叶子结点段,和非叶子节点段.
		以一个表为例,如果表中数据非常少,只需一个页就可以存放,如果表的段包含一个区,则大部分的空间会被浪费
	7.索引页
		虽然B+树可以定位到查询记录所在的页,但若要实际定位到查询的记录,还需要通过二叉查找法进行进一步的比较
	8.锁与事务
		InnoDB存储引擎在REPEATABLE READ隔离级别下,使用Next-Key Lock锁的算法,因此避免产生幻读,所以默认这个隔离级别就已经能保证隔离要求.
		通过主键进行加锁的语句,仅对聚集索引记录进行加锁
		通过辅助索引记录进行加锁的语句,首先对辅助索引记录加锁,再对聚集索引进行加锁
		通过辅助索引记录加锁的语句,可能还需要对下一个记录进行加锁(为了避免幻读,如果是唯一索引,那么就不需要锁定下一个辅助索引记录,但是这仅对等值查询有效,对于非等值插入,不管辅助所以你是否包含唯一约束,都需要锁定下一个索引记录,从而避免幻读的产生)
	9.死锁
		在死锁过程中,通常采用深度优先的算法实现,每当加锁操作需要等待时,就调用lock_deadlock_occurs函数,判断是否产生死锁,如果有则会选择回滚undo量最小的事务
	10.聚集索引
		InnoDB存储引擎将B+树索引分为聚集索引和辅助索引两种,因为InnoDB是索引组织表,意味着每张表都会有一个主键,如果没有显式创建,则会自动创建一个6字节的主键.聚集索引中的记录是根据键值顺序存放的,然而这个顺序是逻辑顺序,并不是物理上的存储顺序.因为物理存储要保证顺序的开销也许不能被用户所接受.
		聚集索引的非叶子节点存放的是(键值,地址)对.地址为指向下一层的指针,InnoDB存储引擎通过页在表空间中的偏移量来表示.
	11.辅助索引
		辅助索引的叶子结点存放的记录格式为(键值,主键值,地址),在非叶子节点中依然存在主键信息,辅助索引节点的记录不保存隐藏列xid(锁模块)与roll ptr(日志模块相关),而聚集索引叶子结点中,包含隐藏的系统列.
	12.Insert Buffer(也是一颗B+树,键值为待插入的page_no)
		是InnoDB存储引擎所独有的功能,在插入时,首先判断插入的辅助索引是否在缓冲池中,若在则直接插入,否则将插入的记录放在Insert Buffer中,然后根据算法将Insert Buffer缓存的记录通过后台线程合并回辅助索引页中,这样的好处:
			1.减少磁盘的离散读取
			2.将多次插入合并为一次操作
		Insert Buffer缓存的记录插入到原辅助索引页,这可以分为主动与被动,其顺序是先读取辅助索引页,再读取Insert Buffer页
	13.缓冲池
		InnoDB存储是基于磁盘存储的系统,并将其中的记录按照页的方式进行管理.因此可将其视为基于磁盘的数据库系统,在数据库系统中,由于CPU速度与磁盘速度之间的鸿沟,基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的性能.简单来说,当数据库读取一个页时,首先将从磁盘读到的页存放在缓冲池中,下次再读相同的页时,首先判断该页是否在缓冲池中,若在缓冲池中,该页在缓冲池中被命中,直接读取该页,否则读取磁盘上的页.
		对于数据库中页的修改操作,首先修改在缓冲池中的页,然后再以一定的频率刷新到磁盘,注意的是,页从缓冲池刷新到磁盘的才做并不是每次页发生更新时触发,而是通过成为checkpoint的机制刷新回磁盘.
		缓冲池中有一个free链表,其中保存着未被使用的内存也空间,当free链表中的页都已分配完毕,当要再申请空间时,根据LRU算法淘汰已经使用的页,通常频繁使用的页在链表的前端,但是在InnoDB中,其稍有不同,其加入了midpoint位置,最新访问的页,放在了midpoint位置(如果按照传统的,某些SQL可能会使得缓冲池中的页从链表中被刷新出,从而影响缓冲池的效率,常见的这类操作为索引或者数据的扫描操作,这类擦做需要访问表中的许多也,甚至是全部的页,而这些也通常来说仅在这次查询操作中需要,并不是活跃的热点数据,如果放在了链表的首位,那么非常可能所需要的热点数据从链表中移除,导致读取时再次访问磁盘,降低性能)
		数据库的所有读/写都是需要首先在缓冲池中完成,故缓冲池的首要任务就是将外存中的页读渠道缓冲池中,一般也成为页的物理读取
		当事务提交时,先写重做日志,再修改页,当由于发生宕机而导致数据丢失时,可通过重做日志你进行恢复,这也是事务中持久性的要求.
	14.检查点(同第3条)
		检查点主要处理以下三个问题
			1.缩短数据库的恢复时间
			2.缓冲池不够用时,将脏页刷新到磁盘
			3.重做日志不可用时,刷新脏页
		当缓冲池不够用时,根据LRU算法淘汰最近最少使用的页,若此页为脏页,那么需要强制执行checkpoint,将脏页刷新回磁盘.
		检查点发生的时间,条件及脏页的选择等都是非常复杂,但是检查点所做的事情就是将缓冲池中的脏页刷回到磁盘,不同之处在于每次刷新多少页到磁盘,每次从哪里取脏页,以及触发检查点的时间.
		存在的两种检查点
			1.发生在数据库关闭时,将所有的脏页都刷新到磁盘,这也是默认的工作方式
			2.如果实在数据库运行时也是用默认方式的话,那么数据库的可用性就会受到很大的影响,所以在InnoDB中,只刷新一部分脏页,而不是将所有的脏页刷回到磁盘
	15.事务
		事务是访问并更细数据库中各种数据项的一个程序执行单元
		事务的分类:
			1.扁平事务(应该是使用最频繁的事务)
				所有操作都处于同一层次,由begin work开始,由commit work或rollback work结束,其间的操作都是原子的,要么都执行,要么都回滚,因此扁平事务是应用程序成为原子操作的基本组成模块.
			2.带有保存点的扁平事务
			3.链事务
			4.嵌套事务
			5.分布式事务
	16.undo log
		insert undo日志通常是指事务在insert操作中产生的undo日志,因为insert的操作只对事务本身可见,对其他事物不可见(这是事务隔离性的要求),所以该日志在事务提交后直接删除.
		update undo日志是对delete和update产生的undo日志,该日志需要提供MVCC机制,因此与insert undo log record不同,不能在事务提交时立即删除,需要放入回滚链表的头部,然后等待purge线程进行最后的清理
	17.purge
		主要进行两个清理操作:
			1.清理记录.删除已经标记为delete mark的记录或者其他相关辅助索引记录
			2.清理undo记录.如undo页中所有undo记录都被删除,则删除对应的undo段
		在清理undo日志时,需要判断当前是否有其他事物正在通过undo日志进行多版本并发控制,若有,则不能立即进行清理,仅当没有任何一个用户事物使用该undo日志时,才可以进行清理
	18.master线程
		主要负责一下几项功能
			1.定期将数据写入磁盘
			2.Insert Buffer中的记录的合并
			3.检查点创建
			4.Undo数据页回收
	19.锁超时监控线程
		主要用于打印监控信息和检测事物特有的锁,当线程被锁住超过一定时间后,通过该线程来释放锁,从而避免了死锁的产生.
</pre>