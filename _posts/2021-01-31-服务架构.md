---
title: 服务架构
author: Yahui
layout: php
category: PHP
---


书名：《-》

<pre style="text-align: left;">
	1.nginx使用upstream模块配置负载均衡(名字叫swoft_nginx)(在location中配置反向代理到负载均衡的 swoft_nginx)
	2.配置服务发现
		nginx配置文件upstream模块使用upsync加载consul
		upstream swoole_consul {
			server 192.168.169.140:9001; #留一个固定服务否则nginx启动报错
			upsync 127.0.0.1:8500/v1/kv/upstreams/swoole_test upsync_timeout=6m upsync_interval=500ms upsync_type=consul strong_dependency=on;
			upsync_dump_path /redis_2004/17/conf/servers_test.conf; #从consul读取的信息生成配置文件
			include /redis_2004/17/conf/servers_test.conf; #引入这个配置文件
		}
		解释：
			127.0.0.1:8500/v1/kv/upstreams -> 连接consul的api资源地址
			swoole_test -> 相当于我们自己在consul中自定义的key
			upsync_timeout -> 超时时间6分钟
			upsync_interval -> 定时获取信息的时间
			upsync_type -> 类型
			strong_dependency=on; -> 是否依赖consul运行
			upsync_dump_path -> 拉取之后申请配置文件
	3.在nginx中配置好consul后,向consul增加swoft的集群地址,这样nginx就可以动态加载swoft
	总结:
		nginx使用upsync动态获取consul中的服务信息, strong_dependency是否依赖, 获取服务信息后, 生成一份配置文件(比如swoft_server.conf)
		1.构建3swoft,1nginx,1consul
		2.配置nginx upstream 异步访问consul服务端
		3.consul:实际在程序自动注册信息到consul (当时使用的是curl)
	3.docker-compose配置(部分代码)
		# 编排php,redis,nginx容器
		version: "3.6" # 确定docker-composer文件的版本
		services: # 代表就是一组服务 - 简单来说一组容器
		  # server
		  consul_master_server_170_30: # 这个表示服务的名称，课自定义; 注意不是容器名称
		    image: consul1.4 # 指定容器的镜像文件
		    ports: # 配置容器与宿主机的端口
		      - "8500:8500"
		    networks: # 引入外部预先定义的网段
		       consul:
		         ipv4_address: 170.200.7.30   #设置ip地址
		    container_name: consul_master_server_170_30 # 这是容器的名称
		    volumes: #配置数据挂载
		      - 挂载目录(测试可以指定同一目录(因为在同一服务器上, 集群环境可以使用git+Jenkins), 实现代码同步)
		    command: ./consul agent -server -bootstrap-expect 3 -data-dir /tmp/consul -node=consul_master_server_170_30 -bind=170.200.7.30 -ui -client=0.0.0.0
		    depends_on: # 容器启动依赖的顺序
		    	- mongod_shard_A_174_2
		    注：
		    	-server // 代表是一个服务
		    	-bootstrap-expect 3 // 只在master节点，表示启动多少个节点（可以没有）
		    	-data-dir /tmp/consul
		    	-node=consul_master_server_170_30 // 节点名称
		    	-bind=170.200.7.30 // 绑定网络的通信方式，有IP或者端口映射
		    	-ui // consul的web界面
		    	-client=0.0.0.0
		    	-join=170.200.7.30  // 绑定到哪个节点，从节点（slave）会有
	4.swoft
		可以利用注册与停止时间增加服务发现事件(官方提供的有方法(注:参数是服务的名称)),来实swoft的注册与删除
	5.docker-compose配置多个服务的问题
		问题:代码同步指定同一目录(swoft), 而swoft的配置文件是同一个,导致服务发现只能发现一个
		处理:使用服务器启动时的ip地址来配置.env文件,swoft启动读取.env文件来配置,从而实现同一套代码配置文件是多套
	6.在swoft的listener下的RegisterServiceListener中,配置check模式
		"check" => [
			"name" => "swoft.goods.server" // 这个主要是区分与其他
			"tcp" => "你的swoft宿主机地址" // 这个如果是http，可以写成http的地址(http://test.com)
			"interval" => "10s" // 如果及时性比较低,可以设置长一些,这样对服务器压力小一点
			"timeout" => "2s" // 设置超时时间
		] 这个是用到swoft-consul组件, 这样consul就会生成一个定时器,检测swoft的健康状况
		总之,利用docker-composer,增加启动命令,给shell脚本传递IP,端口,shell脚本处理传递过来的参数,进行拼接,最终写进.env文件中,(形如HOST=12.12.12.11....),swoft启动读取.env文件内容获取IP及端口(例如第6点,将swoft地址拼接到swoft-consul组件配置项中),最终达到consul定时检测通过docker-composer启动的swoft服务
	7.nginx使用lua模块（以lua使用redis为例）
		1.nginx 通过 --add-module 加载nginx-lua模块(如果是通过yum安装， 需要通过nginx -V查看版本，然后再编译安装相同版本，编译安装的时候加载模块)
		2.nginx配置文件中，加载文件（lua_package_path "****/redis.lua;;"） #在server外层
		3.nginx配置文件中，使用content_by_lua_file *****/lua_redis; #这个文件是lua操作redis的代码，在server中,或者location中
		4.获取参数
			local request_method ngx.var.request_method;
			if "GET" == request_method then
				args = ngx.req.get_uri_args();
			elseif "POST" == request_method then
				args = ngx.req.get_post_args();
			end
			params = args["sku_id"];
	8.主从同步过程
		binlog是二进制日志文件，可使用mysql自带mysqlbinlog工具查看 mysqlbinlog myql-bin.000001
		<span class="image featured"><img src="{{ 'assets/images/other/mysqlbinlog.jpg' | relative_url }}" alt="" /></span>
</pre>