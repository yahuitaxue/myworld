---
title: MySQL与数据库维护
author: Yahui
layout: sql
category: SQL
---

书名：《深入浅出MySQL:数据库开发、优化与管理维护》

<pre style="text-align: left;">
SQL执行顺序
<span class="image featured"><img src="{{ 'assets/images/other/mysqlsqlqueue.jpg' | relative_url }}" alt="" /></span>
<h1>基础部分</h1>
SQL 语句主要可以划分为以下 3 个类别。

DDL（Data Definition Languages）语句：数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。

DML（Data Manipulation Language）语句：数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）

DCL（Data Control Language）语句：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。

数据库子查询：
	用于子查询的关键字包括：in,notin,=,!=,exist,not exist;

数据库记录联合：
	UNION/UNION ALL主要区别是UNION ALL是把结果直接结合在一起，而UNION是将UNION ALL的结果再进行一次DISTINCT。
	例：SELECT a FROM table1 UNION/UNION ALL SELECT a FROM table2;

数据库DCL
	用于DBA管理系统中对象权限
	mysql> grant all privileges on *.* to ''@'%' identified by '***' with grant option;
		all privileges：表示将所有权限授予给用户。也可指定具体的权限，如：SELECT、CREATE、DROP等。
		on：表示这些权限对哪些数据库和表生效，格式：数据库名.表名，这里写“*”表示所有数据库，所有表。如果我要指定将权限应用到test库的user表中，可以这么写：test.user
		to：将权限授予哪个用户。格式："用户名"@"登录IP或域名"。%表示没有限制，在任何主机都可以登录。比如："mysqldb"@"192.168.2.%"，表示mysqldb这个用户只能在192.168.2 IP段登录
		identified by：指定用户的登录密码
		with grant option：表示允许用户将自己的权限授权给其它用户

<span class="image featured"><img src="{{ 'assets/images/other/mysqldclgrant.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqldclrevoke.jpg' | relative_url }}" alt="" /></span>
	revoke insert on 数据库.* from '用户名'@'localhost'
	<code>
	(注：此处为网上整理而来)
		1.新建用户
		　　1.1 登录MYSQL：
		　　C:\mysql\mysql-5.6.41-winx64\bin>mysql -u root -p
		    Enter password: **********

		　　1.2 创建用户：
		　　mysql> insert into mysql.user(Host,User,Password) values("localhost","demo",password("1234"));
			mysql> CREATE USER '用户名'@'%' IDENTIFIED BY '密码'
		　　这样就创建了一个名为：demo 密码为：1234 的用户。

		　　注意：此处的"localhost"，是指该用户只能在本地登录，不能在另外一台机器上远程登录。如果想远程登录的话，将"localhost"改为"%"，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。

		　　1.3 然后登录一下：
		　　mysql>exit;
		　　C:\mysql\mysql-5.6.41-winx64\bin>mysql -u demo -p
		    Enter password: **********

		2.为用户授权
		　　授权格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by "密码";

		　　2.1 登录MYSQL（有ROOT权限），这里以ROOT身份登录：
		　　C:\mysql\mysql-5.6.41-winx64\bin>mysql -u demo -p
		    Enter password: **********

		　　2.2 首先为用户创建一个数据库(testDB)：
		　　mysql>create database demoDB;

		　　2.3 授权test用户拥有testDB数据库的所有权限（某个数据库的所有权限）：
		　　 mysql>grant all privileges on demoDB.* to demo@localhost identified by '1234';
		 　　mysql>flush privileges;//刷新系统权限表
		　　格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by "密码";　

		　　2.4 如果想指定部分权限给一用户，可以这样来写:
		　　mysql>grant select,update on demoDB.* to demo@localhost identified by '1234';
		　　mysql>flush privileges; //刷新系统权限表

		　　2.5 授权test用户拥有所有数据库的某些权限： 　 
		　　mysql>grant select,delete,update,create,drop on *.* to demo@"%" identified by "1234";
		     //test用户对所有数据库都有select,delete,update,create,drop 权限。
		　 //@"%" 表示对所有非本地主机授权，不包括localhost。（localhost地址设为127.0.0.1，如果设为真实的本地地址，不知道是否可以，没有验证。）
			//对localhost授权：加上一句grant all privileges on demoDB.* to demo@localhost identified by '1234';即可。 

		3. 删除用户
		 　    C:\mysql\mysql-5.6.41-winx64\bin>mysql -u demo -p
		    Enter password: **********
		 　　mysql>Delete FROM user Where User='demo' and Host='localhost';
		 　　mysql>flush privileges;
		 　　mysql>drop database demoDB; //删除用户的数据库
		删除账户及权限：>drop user 用户名@'%';
		　　　　　　　　>drop user 用户名@ localhost; 

		4. 修改指定用户密码
		  　　C:\mysql\mysql-5.6.41-winx64\bin>mysql -u demo -p
		      Enter password: **********
		  　　mysql>update mysql.user set password=password('新密码') where User="demo" and Host="localhost";
		  　　mysql>flush privileges;
		 
		5. 列出所有数据库
		　　mysql>show database; 

		6. 切换数据库
		　　mysql>use '数据库名';

		7. 列出所有表
		　　mysql>show tables;
		 
		8. 显示数据表结构
		　　mysql>describe 表名;

		9. 删除数据库和数据表
		　　mysql>drop database 数据库名;
		　　mysql>drop table 数据表名;
	</code>

数据库类型
	整型int
		后面加小括号内指定显示宽度。例如int(5)表示宽度小于5的时候在数字前面进行填充，一般配合zerofill使用。如果不指定宽度，默认是(11)。如果插入数据大于指定宽度只要在类型范围内，也不会报错，会将实际数值保存。
	字符串型
		CHAR的长度是定义时的长度0~255
		VARCHAR的长度是可变的
		还有一个区别，CHAR会忽略字符串最后的空格，而VARCHAR则不会忽略
	枚举ENUM类型
		对1~255个成员，用一个字节存储，255~65535个成员用两个字节存储
		枚举类型忽略大小写，如果不在枚举范围内，则默认插入第一个值。
	SET类型
		与枚举型类似，区别在于SET一次可以选取多个成员，而ENUM只能选取一个。
<span class="image featured"><img src="{{ 'assets/images/other/mysqlset.jpg' | relative_url }}" alt="" /></span>
	(select 'abc'>'a','bc'>'a';)

数据库常用函数
<span class="image featured"><img src="{{ 'assets/images/other/mysqlstring.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqlnumber.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqldatetime.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqlcondition.jpg' | relative_url }}" alt="" /></span>

<h1>开发篇</h1>
<span class="image featured"><img src="{{ 'assets/images/other/mysqlengine.jpg' | relative_url }}" alt="" /></span>
MyISAM引擎中，物理文件有三个
表名.frm(表定义)
表名.MYD(表数据)
表名.MYI(表索引)
对于InnoDB，自动增长的列必须是索引，如果是组合索引，也必须是组合索引的第一列；但是对于MyISAM表，自动增长的可以是组合索引的其他列。
	(FOREIGN KEY(字段名) REFERENCES 表名(字段名))
	ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(字段) REFERENCES 表名(字段名)
<code>
	(注：此处为网上整理而来)
	FULLTEXT

	即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE INDEX创建FULLTEXT索引，要比先为一张表建立FULLTEXT然后再将数据写入的速度快很多。

	全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。在没有全文索引之前，这样一个查询语句是要进行遍历数据表操作的，可见，在数据量较大时是极其的耗时的，如果没有异步IO处理，进程将被挟持，很浪费时间，当然这里不对异步IO作进一步讲解，想了解的童鞋，自行百度。

	全文索引的使用方法并不复杂：

	创建ALTER TABLE table ADD INDEX `FULLINDEX` USING FULLTEXT(`cname1`[,cname2…]);

	使用SELECT * FROM table WHERE MATCH(cname1[,cname2…]) AGAINST ('word' MODE );

	其中， MODE为搜寻方式（IN BOOLEAN MODE ，IN NATURAL LANGUAGE MODE ，IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION / WITH QUERY EXPANSION）。

	关于这三种搜寻方式，在这里也不多做交代，简单地说，就是，布尔模式，允许word里含一些特殊字符用于标记一些具体的要求，如+表示一定要有，-表示一定没有，*表示通用匹配符，是不是想起了正则，类似吧；自然语言模式，就是简单的单词匹配；含表达式的自然语言模式，就是先用自然语言模式处理，对返回的结果，再进行表达式匹配。

	对搜索引擎稍微有点了解的同学，肯定知道分词这个概念，FULLTEXT索引也是按照分词原理建立索引的。西文中，大部分为字母文字，分词可以很方便的按照空格进行分割。但很明显，中文不能按照这种方式进行分词。那又怎么办呢？这个向大家介绍一个Mysql的中文分词插件Mysqlcft，有了它，就可以对中文进行分词，想了解的同学请移步Mysqlcft，当然还有其他的分词插件可以使用。

	HASH

	Hash这个词，可以说，自打我们开始码的那一天起，就开始不停地见到和使用到了。其实，hash就是一种（key=>value）形式的键值对，如数学中的函数映射，允许多个key对应相同的value，但不允许一个key对应多个value。正是由于这个特性，hash很适合做索引，为某一列或几列建立hash索引，就会利用这一列或几列的值通过一定的算法计算出一个hash值，对应一行或几行数据（这里在概念上和函数映射有区别，不要混淆）。在java语言中，每个类都有自己的hashcode()方法，没有显示定义的都继承自object类，该方法使得每一个对象都是唯一的，在进行对象间equal比较，和序列化传输中起到了很重要的作用。hash的生成方法有很多种，足可以保证hash码的唯一性，例如在MongoDB中，每一个document都有系统为其生成的唯一的objectID（包含时间戳，主机散列值，进程PID，和自增ID）也是一种hash的表现。额，我好像扯远了-_-!

	由于hash索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。那为什么还需要其他的树形索引呢？

	在这里就不自己总结了。引用下网上其他大神的文章

	（1）Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。 
	由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。 
	（2）Hash 索引无法被用来避免数据的排序操作。 
	由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； 
	（3）Hash 索引不能利用部分索引键查询。 
	对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 
	（4）Hash 索引在任何时候都不能避免表扫描。 
	前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 
	（5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 
	对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。

	当我们为某一列或某几列建立hash索引时（目前就只有MEMORY引擎显式地支持这种索引），会在硬盘上生成类似如下的文件：

	hash值 	存储地址    
	1db54bc745a1	77#45b5 
	4bca452157d4	76#4556,77#45cc…
	…

	hash值即为通过特定算法由指定列数据计算出来，磁盘地址即为所在数据行存储在硬盘上的地址（也有可能是其他存储地址，其实MEMORY会将hash表导入内存）。

	这样，当我们进行WHERE age = 18 时，会将18通过相同的算法计算出一个hash值==>在hash表中找到对应的储存地址==>根据存储地址取得数据。

	所以，每次查询时都要遍历hash表，直到找到对应的hash值，如（4），数据量大了之后，hash表也会变得庞大起来，性能下降，遍历耗时增加，如（5）。

	BTREE

	BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中。如二叉树一样，每次查询都是从树的入口root开始，依次遍历node，获取leaf。

	BTREE在MyISAM里的形式和Innodb稍有不同

	在 Innodb里，有两种形态：
	一是primary key形态，其leaf node里存放的是数据，而且不仅存放了索引键的数据，还存放了其他字段的数据。
	二是secondary index，其leaf node和普通的BTREE差不多，只是还存放了指向主键的信息.

	而在MyISAM里，主键和其他的并没有太大区别。不过和Innodb不太一样的地方是在MyISAM里，leaf node里存放的不是主键的信息，而是指向数据文件里的对应数据行的信息.

	RTREE

	RTREE在mysql很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。

	相对于BTREE，RTREE的优势在于范围查找.

	各种索引的使用情况

	（1）对于BTREE这种Mysql默认的索引类型，具有普遍的适用性

	（2）由于FULLTEXT对中文支持不是很好，在没有插件的情况下，最好不要使用。其实，一些小的博客应用，只需要在数据采集时，为其建立关键字列表，通过关键字索引，也是一个不错的方法，至少我是经常这么做的。

	（3）对于一些搜索引擎级别的应用来说，FULLTEXT同样不是一个好的处理方法，Mysql的全文索引建立的文件还是比较大的，而且效率不是很高，即便是使用了中文分词插件，对中文分词支持也只是一般。真要碰到这种问题，Apache的Lucene或许是你的选择。

	（4）正是因为hash表在处理较小数据量时具有无可比拟的素的优势，所以hash索引很适合做缓存（内存数据库）。如mysql数据库的内存版本Memsql，使用量很广泛的缓存工具Mencached，NoSql数据库redis等，都使用了hash索引这种形式。当然，不想学习这些东西的话Mysql的MEMORY引擎也是可以满足这种需求的。
	CREATE INDEX 索引名 ON 表名(字段名,字段名...)
	ALTER TABLE 表名 ADD INDEX 索引名 (字段名,字段名...)
	DROP INDEX 索引名 ON 表名
	ALTER TABLE 表名 DROP INDEX 索引名
		联合索引(a,b,c)索引可以支持a|a,b|a,b,c 3种组合进行查找
</code>
对于MEMORY存储引擎，在不再需要的时候，需要释放表的内存：DELETE FROM / TRUNCATE TABLE / DROP TABLE

对于MERGE存储引擎：是一组MyISAM表的组合，这些表需要结构完全一样，MERGE表本身并没有数据，对MERGE表可以进行查询，更新和删除这些实际是对MyISAM表进行的，对于插入操作，是通过INSERT_METHOD定义插入的表，可以有三个值：FIRST，LAST，不定义(或设置为NO)，表示不能对这个表进行插入操作。
<span class="image featured"><img src="{{ 'assets/images/other/mysqlmerge.jpg' | relative_url }}" alt="" /></span>
<span class="image featured"><img src="{{ 'assets/images/other/mysqlenginebetter.jpg' | relative_url }}" alt="" /></span>

CHAR与VARCHAR
<span class="image featured"><img src="{{ 'assets/images/other/mysqlcharorvarchar.jpg' | relative_url }}" alt="" /></span>

TEXT与BLOB
	BLOB用来保存二进制数据，比如图片
	TEXT只能保存字符串数据

(注：平时的删除操作，会在数据表中留下很大的空洞，会导致物理占用没必要的空间,可以使用  mysql>OPTIMIZE TABLE test; 语法进行碎片整理)
(注：可以使用合成索引(就是根据大文本字段(BLOB/TEXT)的内容建立一个散列值(可以使用MD5来生成))并把这个值存在一个新的字段中，这样就可以使用散列值查询数据)

浮点数与定点数
	浮点数表示时，单精度表示浮点数会有些许误差，所以要求精度比较高的应用中(比如货币)，最好使用定点数，而且尽量避免浮点数的比较，如果非要比较，最好使用范围比较，而不要用 "==" 来比较

时间日期
	如果只需记录年份可以使用YEAR类型，如果是日期可以使用DATE，如果是精确时间可以使用DATETIME，如果需要区分时区可以使用TIMESTAMP。
	DATETIME与TIMESTAMP显示形式是一样的，区别在于：
		对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。
		而对于DATETIME，不做任何改变，基本上是原样输入和输出。

(GBK中中文占用两个字节，UTF-8占用三个字节，使用mysql>show character set;可以查看)
(查看数据库默认字符集(show variables like 'character_set_database';)与默认校对规则(show variables like 'collation_database';))
(设置数据库默认字符集set character_set_database = utf8;)

索引的设计原则
<span class="image featured"><img src="{{ 'assets/images/other/mysqlindex.jpg' | relative_url }}" alt="" /></span>

HASH索引
	只能用于使用 = 或者 <=>(与=类似区别在于与NULL作比较的时候) 操作符的等式比较
	优化器不能通过HASH来加速ORDER BY操作
	MySQL不能确认两个值之间有多少行。如果将一个MyISAM改为HASH索引的MYMORY表，会影响一些查询效率
	只能用整个关键字来搜索一行
BTREE索引
	当使用 >,<,>=,<=,BETWEEN,!= 或者 <>,LIKE 'abc'(其中'abc'不以通配符开始)操作时，都可以使用相关列上的索引

视图：
	创建视图：
		CREATE OR REPLACE view 视图名 AS (查询结果);
		MySQL创建视图有一些限制：在FROM后不能有子查询，可以先将子查询作为一个视图，然后再根据这个视图创建下一个视图。
	查看视图：
		SHOW TABLES;
		SHOW CREATE VIEW 视图名;

存储过程
	创建存储过程
		DROP PROCEDURE IF EXISTS `存储过程名`;
		DELIMITER ;;
		CREATE DEFINER=`mysql`@`%` PROCEDURE `存储过程名`()
		BEGIN
			(DDL语句)
			...
		    DELETE FROM ... WHERE ...;
		    INSERT INTO ... SELECT ... FROM ... WHERE PRI_T...;
		    TRUNCATE TABLE  ...;
		    ...
		COMMIT;
		END
		;;
		DELIMITER ;
<span class="image featured"><img src="{{ 'assets/images/other/mysqlprocedure.jpg' | relative_url }}" alt="" /></span>

	删除存储过程
		DROP PROCEDURE 存储过程名称

	查看存储过程
		SHOW PROCEDURE STATUS (LIKE '');
		SHOW CREATE {PROCEDURE|FUNCTION} 存储过程名称
存储过程中可以声明变量(DELCARE 名 类型)
变量赋值(SET 名=表达式)
定义条件(DELCARE 条件名 CONDITION FOR 条件值，然后在下面类似PHP中case的形式声明条件名与条件值是什么)
光标(DECLARE 光标名 CURSOR FOR 查询状态(SELECT a,b FROM 表名;))
以及使用IF，CASE，LOOP，LEAVE，ITERATE，REPEAT，WHILE

事件调度器(定时触发，类似crontab，MySQL版本要在5.1版本以上)
CREATE EVENT 事件名
ON SCHEDULE AT(EVERY 5 SECOND) CURRENT_TIMESTAMP + INTERVAL 1 HOUR
DO
	UPDATE 表名 SET ......;
注：复杂的逻辑更适合程序实现

触发器
	触发器只能建立在永久表上，临时表不能创建
	触发器中不能有开始或者结束事务的语句：START TRANSACTION COMMIT ROLLBACK
	DELIMITER $$;
	CREATE TRIGGER 触发器名 AFTER(/BEFORE) INSERT(/UPDATE...) ON 触发的表名 FOR EACH ROW
	BEGIN
		(触发事件)
		INSERT INTO 表名(字段,字段,,,) VALUES (new(old更新的话，可以用到旧字段).字段,new(old).字段,,,);
	END;
	$$
	DELIMITER ;
	删除触发器
	DROP TRIGGER 触发器名称

表锁
	LOCK TABLE 表名 READ/WRITE;
	锁上以后，只是把这个表临时归为私有，等解锁以后就可以了。
	UNLOCK TABLES;

事务
	START TRANSACTION/BEGIN
	COMMIT
	ROLLBACK
	在使用START TRANSACTION/BEGIN的时候会默认执行UNLOCK TABLES

表分区
	使用SHOW VARIABLES (LIKE '%partition%')查看是否支持分区
	MySQL支持大多数的存储引擎(MyISAM，InnoDB，Memory等)分区，但不支持MERGE或CSV来创建分区。
	注：同一个分区表的所有分区存储引擎必须一致
	MySQL分区适用所有数据和索引，不能对数据而不对索引，也不能对索引不对数据，同时也不能对部分数据进行分区

	分区类型
		RANGE：基于一个给定连续区间，把数据分配到不通分区。(分区的键必须是INT或者返回是INT类型的，5.5版本以上支持非整型)
		LIST：与RNAGE类似，不同的是LIST是基于枚举型的值列表分区，RANGE是基于给定的连续范围区间分区。(分区的键必须是INT或者返回是INT类型的，5.5版本以上支持非整型)
		HASH：基于给定的分区，把数据分配到不同的分区。(分区的键必须是INT或者返回是INT类型的)
		KEY：类似HASH(???)。(可以使用其他类型的做为分区TEXT与BOLB除外)
		注：要么分区表上没有主键/唯一键，要么分区表的主键/唯一键必须包含分区键，也就是说不能使用主键/唯一键以外的其他字段

		RANGE:
<span class="image featured"><img src="{{ 'assets/images/other/mysqlpartition.jpg' | relative_url }}" alt="" /></span>
		(如果分区键超过了分区时定义的最大值，就会出现不能插入的情况，可以使用：PARTITION Pn VALUES LESS THAN MAXVALUE)
		(当需要删除分区数据的时候，可以使用ALTER TABLE 表名 DROP PARTITION 分区名;这要比使用DELETE语句更便捷)
		LIST：语法PARTITION BY LIST COLUMNS()
			PARTITION 名称 VALUES IN(字段值,字段值,字段值)
<span class="image featured"><img src="{{ 'assets/images/other/mysqlpartitionrange.jpg' | relative_url }}" alt="" /></span>
		HASH：PARTITION BY (LINEAR)(如果加上LINEAR就是线性HASH算法) HASH(字段) PARTITIONS 4;利用hash创建4个分区，按照字段与4取余计算
		因为HASH分区完成后，如果需要新增分区，则需要数据重新计算分区，很麻烦，所以可以使用线性HASH
		线性HASH：PARTITION BY LINEAR HASH(字段) PARTITIONS 4;(优点：分区维护(增、删、合并与拆分)更加便捷，缺点各个分区数据不太均衡)
<span class="image featured"><img src="{{ 'assets/images/other/mysqlpartitionhash.jpg' | relative_url }}" alt="" /></span>
		KEY：可以使用PARTITION BY KEY(必须为INT类型，可以不写，默认优先级主键->非空唯一键) PARTITIONS 4;
		在KEY中使用LINEAR与HASH相同。

	子分区
		与分区语法一样，可以使用在分区下来定义子分区
<span class="image featured"><img src="{{ 'assets/images/other/mysqlpartitionchildren.jpg' | relative_url }}" alt="" /></span>

	注意：NULL值问题，RANGE分区中NULL会被当成最小的值来处理，LIST中NULL必须出现在枚举型中，HASH/KEY中NULL会被当成0值

	RANGE分区：
		增加分区：ALTER TABLE 表名 ADD PARTITION ( PARTITIONS 分区名 VALUES LESS THAN (值));新增分区只能增加到最大值部分
		分区增加值：
			1、以新值增加新的分区
			2、修改！！相邻！！的分区，对值进行重新分配(ALTER TABLE 表名 REORGANIZE PARTITION p4,p5,p6 INTO( ... ))
<span class="image featured"><img src="{{ 'assets/images/other/mysqlreorganizepartition.jpg' | relative_url }}" alt="" /></span>
	HASH与KEY分区：
		增加分区：ALTER TABLE 表名 ADD PARTITION PARTITIONS 增加的数量;
		减少分区：ALTER TABLE 表名 COLASESCE APRTITION 减少的数量;
取消分区：
	ALTER TABLE 表名 REMOVE PARTITIONING;

<h1>优化篇</h1>
	使用SHOW STATUS LIKE 'Com_%';来查看当前session中SQL的执行频率。
	SHOW PROCESSLIST;查看在进行的线程。
	使用DESC/EXPLAIN + SQL语句 //查看执行情况
	使用DESC/EXPLAIN + PARTITIONS SQL语句 //查看执行分区

1、通过慢查询定位执行时间过长的SQL语句 (用--log-slow-queries[=file_name]选项启动mysqld的时候会执行时间超过long_query_time(MySQL配置文件my.ini)的SQL语句)
	修改配置文件(不同版本配置不太一样)
	slow_query_log    ：是否开启慢查询日志，1表示开启，0表示关闭。
	log_slow_queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log
	slow_query_log_file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log
	long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。
	log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。
	log_output：日志存储方式。log_output='FILE'表示将日志存入文件，默认值是'FILE'。log_output='TABLE'表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据<br>库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output='FILE,TABLE'。
	----------------------------------------------------------------------
	show variables like "long_query_time";默认10s/*查看慢查询时间 */
	show status like "%slow_queries%";/*查看慢查询配置情况 */
	show variables like "%slow%";/*查看慢查询日志路径 */
2、通过DESC/EXPLAIN + SQL语句 (查看SQL的执行信息)
	select_type:表示SELECT的类型
		SIMPLE：简单表，不适用表连接或者子查询
		PRIMARY：主查询
		UNION：UNION中的第二个或者后面的下旬语句
		SUBQUERY：子查询中的第一个SELECT
	table:输出结果集的表
	type:表示MySQL在列表中找到所需行的方式，或者访问类型，插件类型
		ALL(遍历全表进行匹配如：explain select * from a where 非索引列 > 9)
		index(遍历整个索引进行匹配如：explain select 索引列 from a)
		range(索引范围匹配，常见于<,<=,>,>=,between等如：explain select * from a where 索引列 > 9)
		ref(使用非唯一索引返回某个单独值的记录如：explain select * from a where 索引列 = 9)
		eq_ref(多表查询使用唯一索引使用primary key或者unique index作为关联，并且关联是只有一个对应的条件如：explain select * from 表1,表2 where 表1.id = 表2.id)
		const,system(单表中最多有一个匹配行如：explain select * from(select * from a where 主键索引或者唯一索引 = '某个值'))
		NULL(MySQL不用访问表或者索引就能得到结果如：explain select 1+2;)
		(性能由差到好)
3、通过SHOW PROFILE分析SQL
	查看是否支持profile：select @@profile;
	设置profile是否开启：set profiling = 1;
	通过show profiles;查看执行SQL;
	再通过show profiles for query 1;来查看每个状态消耗的时间
	再通过 show profile all/cpu/block io/context/switch/page faults... for query 1;来查看SQL执行的详情
4、定位到问题进行解决
	索引问题
		MySQL使用索引的典型场景：
			1、匹配全值，对索引中所有列指定具体值，即是对索引中的所有都有等值匹配的条件。
			2、匹配值的范围查询，即是对索引值能够进行范围查找。
			3、匹配最左前缀，仅仅使用索引中左边列进行查找。
				最左匹配原则是MySQL中BTREE索引使用的首要原则(如索引 alter table add index indextest(a,b,c);这个索引包含的是 (a),(a,b),(a,c),(a,b,c));
			4、要查询的列都在索引的字段中，查询效率会更高。
			5、仅使用索引中第一列，并且包含第一列开头一部分进行查找。(create index 索引名 on 表(字段1(10),字段2(20));select 字段1 from 表 where 字段1 like 'abcdefg%');
			6、能够实现索引匹配部分精确而其他部分进行范围匹配。
			7、如果索引是列名，那么使用 列名 is null 就会用到索引。
		存在索引，但是不能使用的场景：
			1、以“%”开头的LIKE查询不能使用BTREE索引。
			2、数据类型出现隐式转换的时候也不会使用索引，特别是字符串，一定要加上引号。
			3、复合索引不满足最左原理。
			4、用or分开的条件，如果or前列有索引，而后面的列没有索引，那么索引都不会生效。
5、优化方法
	1、ANALYZE TABLE 表名 查看表的SQL执行是否有问题。
	2、CHECK TABLE 表名/多个表名/视图名 查看表/视图有无问题
6、SQL优化
	1、大量数据导入
		MyISAM表：可以先关闭唯一索引:ALTER TABLE 表名 DISABLE KEYS; 在导入后再开启:ALTER TABLE 表名 ENABLE KEYS。
		InnoDB：按照主键索引的顺序进行导入。
		先关闭唯一索引，导入后再开启：SET UNIQUE_CHECKS=0/1。
	2、优化INSERT语句
		插入的时候尽量使用多值插入，不要一个插入用一个INSERT语句，减少连库时间。
	3、优化ORDER BY 语句
		尽量减少额外的排序，通过索引直接返回有序数据。
	4、优化GROUP BY 语句
		默认是对group by语句进行排序，如果没有必要，可以使用ORDER BY NULL;进行取消排序，提高效率。
	5、优化嵌套查询
		嵌套查询一般使用JOIN来进行替换。
	6、优化OR语句
	    尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描
	    可以用 union 代替 or
	    SELECT * FROM t WHERE id = 1
           UNION
        SELECT * FROM t WHERE id = 3
		or语句每个条件都要使用索引，如果没有，可以考虑增加索引。
	7、尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描
	    尽量在字段后面使用模糊查询 “测试%”
	8、尽量避免使用 in 和 not in，会导致引擎走全表扫描
	    -- 不走索引
        select * from A where A.id in (select id from B);
        -- 走索引
        select * from A where exists (select * from B where B.id = A.id);
    9、尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描
        可以给字段添加默认值 0，对 0 值进行判断。
    10、尽量避免在 where 条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描
    11、当数据量大时，避免使用 where 1=1 的条件
    12、查询条件不能用 <> 或者 !=
    13、where 条件仅包含复合索引非前置列，要按照MySQL联合索引的最左匹配原则
    14、隐式类型转换造成不使用索引
    15、order by条件要与where中条件一致，否则order by不会利用索引进行排序
        -- 不走age索引
        SELECT * FROM t order by age;
        -- 走age索引
        SELECT * FROM t where age > 0 order by age;
7、表的优化
	1、通过PROCEDURE ANALYSE();来对表进行优化。
		例：SELECT * FROM 表 PROCEDURE ANALYSE(16,255)括号里可以为空，16,255代表可以不给在16~255个字节的ENUM类型给出建议;
<span class="image featured"><img src="{{ 'assets/images/other/mysqlbetterprocedure.jpg' | relative_url }}" alt="" /></span>
	2、水平或者垂直拆分表。
	3、适当逆规范化。
		例：用户账单，数据量很大，但是规范是要把用户信息存在一张表，而账单存在另一张表，每次需要关联查询。但是如果在账单表中增加一个用户名，就可以避免关联查询。

数据库锁的问题
	<span class="image featured"><img src="{{ 'assets/images/other/mysqllock.jpg' | relative_url }}" alt="" /></span>
	<span class="image featured"><img src="{{ 'assets/images/other/mysqllockreadwrite.jpg' | relative_url }}" alt="" /></span>
	MyISAM表(只有表锁)：
		1、MyISAM表在执行查询(SELECT)前，会自动给涉及到的表添加读锁，在执行更新操作(INSERT,UPDATE,DELETE等)前会自动给表添加写锁，因此不必刻意写LOCK TABLE 表 READ/WRITE
		2、如果某一个时间点对多个表实现一致性读取，需要手动锁表与解锁。
		3、锁表的时候，需要对起别名的表也添加锁。
		4、两个进程对同一个表进行读锁与写锁，那么写锁的优先级要高
			可以修改系统参数max_write_lock_count设置表的读锁达到这个值的时候，降低写锁的优先级。
	InnoDB表：
	<span class="image featured"><img src="{{ 'assets/images/other/mysqlinnodblock.jpg' | relative_url }}" alt="" /></span>
		1、意向锁是InnoDB自动添加的，不用用户干预。
		2、执行更新操作(INSERT,UPDATE,DELETE)，会自动添加排他锁，而对于普通的SELECT，InnoDB不会加任何锁。
		3、SELECT时手动添加锁：
			共享锁(S):SELECT * FROM 表 WHERE ... LOCK IN SHARE MODE;
			排他锁(X):SELECT * FROM 表 WHERE ... FOR UPDATE;
		4、行锁是通过给索引上的索引加锁实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来记录加锁，这就意味着，如果不通过索引条件索引数据，那么将对表中所有数据进行加锁，实际效果与表锁相同。
	<span class="image featured"><img src="{{ 'assets/images/other/mysqlinnodbdifflock.jpg' | relative_url }}" alt="" /></span>
	死锁：
		两个事务都进行了行锁，又相互查询，导致两个事务都进入到等待的状态，这就是简单的死锁情况
		通常来说，死锁都是应用设计问题，需要通过业务流程，数据库对象设计，事务大小，访问数据库的SQL，绝大部分都可以避免死锁。
			1、不同的程序并发存取多个表，尽量约定以相同的顺序来访问表，这样降低死锁的机会。

MySQL并发调整
	max_connections:提高并发连接，默认是151，如果状态变量connection_max_error_connections不为零，并且一直在增长，就说明不断有连接请求因为数据库连接已经达到最大而失败，就需要扩大。Linux平台下，500~1000也不是难事，当然扩大的同时需要评估open-files-limit是否够用。
	back_log:MySQL监听TCP端口设置的积压请求大小，默认是50，最大不能超过900。
	table_open_catch:SQL执行线程可打开表缓存的数量。每个连接查询所涉及最大表数 N*max_connections 来设定。

应用优化
	1、避免同一数据做重复检索
	2、负载均衡

MySQL工具
	1、mysql(客户端连接工具)
		-u,--user=name 指定用户名
		-p,--password[=name] 指定密码
		-h,--host=name 指定服务器IP或者域名
		-P,--port=# 指定连接端口
	2、字符集选项
		--default-character-set=字符集名
	3、执行选项
		-e,--execute=name 执行SQL并退出
		例：mysql -u root -p mysql -e "select * from info"
	4、格式化选项
		-E,--vertical 将输出方式按照字段顺序竖着显示
		-s,--silent 去掉mysql中的线条框显示
	5、错误处理选项
		-f,--force 强制执行SQL
		-v,--verbose 显示更多信息
		--show-warnings 显示警告信息
	6、myisampack(MyISAM表压缩工具)压缩后变成一个只读表
		例：Linux环境进入表文件位置：myisampack 表名;
	7、mysqldump(数据导出工具)
		mysqldump [options] 数据库名 [表名] 备份单个数据库或者库中部分数据表
		mysqldump [options] --databases DB1[DB2,DB3...] 备份指定的一个或者多个数据库
			mysqldump -hlocalhost -u root -p --database test
		mysqldump [options] --all-databases; 备份所有数据库
			mysqldump -hlocalhost -u root -p --all-databases
		mysqldump -hlocalhost -P3306 -uroot -p test>test.txt

mysql热备份，给要备份的表加读锁，再进行cp备份
	<code>
	注：以下资源来自网络
	一、开启binlog日志：
	    vi编辑打开mysql配置文件
	    # vi /usr/local/mysql/etc/my.cnf
	    在[mysqld] 区块
	    设置/添加 log-bin=mysql-bin  确认是打开状态(值 mysql-bin 是日志的基本名或前缀名)；

	    重启mysqld服务使配置生效
	    # pkill mysqld
	    # /usr/local/mysql/bin/mysqld_safe --user=mysql &


	二、也可登录mysql服务器，通过mysql的变量配置表，查看二进制日志是否已开启 单词：variable[ˈvɛriəbəl] 变量

	    登录服务器
	    # /usr/local/mysql/bin/mysql -uroot -p

	    mysql> show variables like 'log_%'; 
	    +----------------------------------------+---------------------------------------+
	    | Variable_name                          | Value                                 |
	    +----------------------------------------+---------------------------------------+
	    | log_bin                                | ON                                    | ------> ON表示已经开启binlog日志
	    | log_bin_basename                       | /usr/local/mysql/data/mysql-bin       |
	    | log_bin_index                          | /usr/local/mysql/data/mysql-bin.index |
	    | log_bin_trust_function_creators        | OFF                                   |
	    | log_bin_use_v1_row_events              | OFF                                   |
	    | log_error                              | /usr/local/mysql/data/martin.err      |
	    | log_output                             | FILE                                  |
	    | log_queries_not_using_indexes          | OFF                                   |
	    | log_slave_updates                      | OFF                                   |
	    | log_slow_admin_statements              | OFF                                   |
	    | log_slow_slave_statements              | OFF                                   |
	    | log_throttle_queries_not_using_indexes | 0                                     |
	    | log_warnings                           | 1                                     |
	    +----------------------------------------+---------------------------------------+

	三、常用binlog日志操作命令
	    1.查看所有binlog日志列表
	    	mysql> show master logs;

	    2.查看master状态，即最后(最新)一个binlog日志的编号名称，及其最后一个操作事件pos结束点(Position)值
	    	mysql> show master status;

	    3.刷新log日志，自此刻开始产生一个新编号的binlog日志文件
	    	mysql> flush logs;
	    	注：每当mysqld服务重启时，会自动执行此命令，刷新binlog日志；在mysqldump备份数据时加 -F 选项也会刷新binlog日志；

	    4.重置(清空)所有binlog日志
	    	mysql> reset master;


	四、查看某个binlog日志内容，常用有两种方式：

	    1.使用mysqlbinlog自带查看命令法：
	    	注: binlog是二进制文件，普通文件查看器cat more vi等都无法打开，必须使用自带的 mysqlbinlog 命令查看
	        	binlog日志与数据库文件在同目录中(我的环境配置安装是选择在/usr/local/mysql/data中)
	    	在MySQL5.5以下版本使用mysqlbinlog命令时如果报错，就加上 “--no-defaults”选项
	    
	    	# /usr/local/mysql/bin/mysqlbinlog /usr/local/mysql/data/mysql-bin.000013
	        下面截取一个片段分析：

				...............................................................................
				# at 552
				#131128 17:50:46 server id 1  end_log_pos 665   Query   thread_id=11    exec_time=0     error_code=0 ---->执行时间:17:50:46；pos点:665
				SET TIMESTAMP=1385632246/*!*/;
				update zyyshop.stu set name='李四' where id=4              ---->执行的SQL
				/*!*/;
				# at 665
				#131128 17:50:46 server id 1  end_log_pos 692   Xid = 1454 ---->执行时间:17:50:46；pos点:692 
				...............................................................................

			注: server id 1     数据库主机的服务号；
				end_log_pos 665 pos点
				thread_id=11    线程号


	    2.上面这种办法读取出binlog日志的全文内容较多，不容易分辨查看pos点信息，这里介绍一种更为方便的查询命令：

	    	mysql> show binlog events [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];

			选项解析：
				IN 'log_name'   指定要查询的binlog文件名(不指定就是第一个binlog文件)
				FROM pos        指定从哪个pos起始点开始查起(不指定就是从整个文件首个pos点开始算)
				LIMIT [offset,] 偏移量(不指定就是0)
				row_count       查询总条数(不指定就是所有行)

			截取部分查询结果：
				*************************** 20. row ***************************
				Log_name: mysql-bin.000021  ----------------------------------------------> 查询的binlog日志文件名
				Pos: 11197 ----------------------------------------------------------> pos起始点:
				Event_type: Query ----------------------------------------------------------> 事件类型：Query
				Server_id: 1 --------------------------------------------------------------> 标识是由哪台服务器执行的
				End_log_pos: 11308 ----------------------------------------------------------> pos结束点:11308(即：下行的pos起始点)
				Info: use `zyyshop`; INSERT INTO `team2` VALUES (0,345,'asdf8er5') ---> 执行的sql语句
				*************************** 21. row ***************************
				Log_name: mysql-bin.000021
				Pos: 11308 ----------------------------------------------------------> pos起始点:11308(即：上行的pos结束点)
				Event_type: Query
				Server_id: 1
				End_log_pos: 11417
				Info: use `zyyshop`; /*!40000 ALTER TABLE `team2` ENABLE KEYS */
				*************************** 22. row ***************************
				Log_name: mysql-bin.000021
				Pos: 11417
				Event_type: Query
				Server_id: 1
				End_log_pos: 11510
				Info: use `zyyshop`; DROP TABLE IF EXISTS `type`

	    	这条语句可以将指定的binlog日志文件，分成有效事件行的方式返回，并可使用limit指定pos点的起始偏移，查询条数；
	      
	    		A.查询第一个(最早)的binlog日志：
	        		mysql> show binlog events\G; 
	    
	      		B.指定查询 mysql-bin.000021 这个文件：
	        		mysql> show binlog events in 'mysql-bin.000021'\G;

	      		C.指定查询 mysql-bin.000021 这个文件，从pos点:8224开始查起：
	        		mysql> show binlog events in 'mysql-bin.000021' from 8224\G;

	      		D.指定查询 mysql-bin.000021 这个文件，从pos点:8224开始查起，查询10条
	        		mysql> show binlog events in 'mysql-bin.000021' from 8224 limit 10\G;

	      		E.指定查询 mysql-bin.000021 这个文件，从pos点:8224开始查起，偏移2行，查询10条
	        		mysql> show binlog events in 'mysql-bin.000021' from 8224 limit 2,10\G;


	五、恢复binlog日志实验(zyyshop是数据库)
	    1.假设现在是凌晨4:00，我的计划任务开始执行一次完整的数据库备份：

			将zyyshop数据库备份到 /root/BAK.zyyshop.sql 文件中：
				# /usr/local/mysql/bin/mysqldump -uroot -p123456 -lF --log-error=/root/myDump.err -B zyyshop > /root/BAK.zyyshop.sql
				......

			由于使用了-F选项，当备份工作刚开始时系统会刷新log日志，产生新的binlog日志来记录备份之后的数据库“增删改”操作，查看一下：
				mysql> show master status;
				+------------------+----------+--------------+------------------+
				| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
				+------------------+----------+--------------+------------------+
				| mysql-bin.000023 |      120 |              |                  |
				+------------------+----------+--------------+------------------+
			也就是说， mysql-bin.000023 是用来记录4:00之后对数据库的所有“增删改”操作。


	    2.早9:00上班了，业务的需求会对数据库进行各种“增删改”操作~~~~~~~
	    	比如：创建一个学生表并插入、修改了数据等等


			导入实验数据
				mysql> insert into zyyshop.tt(`name`,`sex`,`age`,`classid`) values(...);


			查看数据
				mysql> select * from zyyshop.tt;

			中午时分又执行了修改数据操作
				mysql> update zyyshop.tt set ...;

			修改后的结果：
				mysql> select * from zyyshop.tt;
					+----+----------+-----+-----+---------+
					| id | name     | sex | age | classid |
					+----+----------+-----+-----+---------+
					|  1 | yiyi     | w   |  20 | cls1    |
					|  2 | 小二     | m   |  22 | cls3    |
					|  3 | zhangsan | w   |  21 | cls5    |
					|  4 | 李四     | m   |  20 | cls4    |
					|  5 | wangwu   | w   |  26 | cls6    |
					+----+----------+-----+-----+---------+


			假设此时是下午18:00，莫名地执行了一条悲催的SQL语句，整个数据库都没了：
				mysql> drop database zyyshop;


	    3.先仔细查看最后一个binlog日志，并记录下关键的pos点，到底是哪个pos点的操作导致了数据库的破坏(通常在最后几步)；
	    
			备份一下最后一个binlog日志文件：
				# ll /usr/local/mysql/data | grep mysql-bin
				# cp -v /usr/local/mysql/data/mysql-bin.000023 /root/

	      	此时执行一次刷新日志索引操作，重新开始新的binlog日志记录文件，理论说 mysql-bin.000023 这个文件不会再有后续写入了(便于我们分析原因及查找pos点)，以后所有数据库操作都会写入到下一个日志文件；
	      		mysql> flush logs;
	      		mysql> show master status;
	      

	    4.读取binlog日志，分析问题
	      	方式一：使用mysqlbinlog读取binlog日志：
	        	# /usr/local/mysql/bin/mysqlbinlog  /usr/local/mysql/data/mysql-bin.000023

	      	方式二：登录服务器，并查看(推荐)：
	        	mysql> show binlog events in 'mysql-bin.000023';
	        
	        以下为末尾片段：
		        +------------------+------+------------+-----------+-------------+------------------------------------------------------------+
		        | Log_name         | Pos  | Event_type | Server_id | End_log_pos | Info                                                       |
		        +------------------+------+------------+-----------+-------------+------------------------------------------------------------+
		        | mysql-bin.000023 |  922 | Xid        |         1 |         953 | COMMIT /* xid=3820 */                                      |
		        | mysql-bin.000023 |  953 | Query      |         1 |        1038 | BEGIN                                                      |
		        | mysql-bin.000023 | 1038 | Query      |         1 |        1164 | use `zyyshop`; update zyyshop.tt set name='李四' where id=4|
		        | mysql-bin.000023 | 1164 | Xid        |         1 |        1195 | COMMIT /* xid=3822 */                                      |
		        | mysql-bin.000023 | 1195 | Query      |         1 |        1280 | BEGIN                                                      |
		        | mysql-bin.000023 | 1280 | Query      |         1 |        1406 | use `zyyshop`; update zyyshop.tt set name='小二' where id=2|
		        | mysql-bin.000023 | 1406 | Xid        |         1 |        1437 | COMMIT /* xid=3823 */                                      |
		        | mysql-bin.000023 | 1437 | Query      |         1 |        1538 | drop database zyyshop                                      |
		        +------------------+------+------------+-----------+-------------+------------------------------------------------------------+

	        通过分析，造成数据库破坏的pos点区间是介于 1437--1538 之间，只要恢复到1437前就可。


	    5.现在把凌晨备份的数据恢复：
	      
	    	# /usr/local/mysql/bin/mysql -uroot -p123456 -v < /root/BAK.zyyshop.sql;

	    	注: 至此截至当日凌晨(4:00)前的备份数据都恢复了。
	        	但今天一整天(4:00--18:00)的数据肿么办呢？就得从前文提到的 mysql-bin.000023 新日志做文章了......


	    6.从binlog日志恢复数据
	      
	      	恢复语法格式：
	      		# mysqlbinlog mysql-bin.0000xx | mysql -u用户名 -p密码 数据库名

	        常用选项：
				--start-position=953                   起始pos点
				--stop-position=1437                   结束pos点
				--start-datetime="2013-11-29 13:18:54" 起始时间点
				--stop-datetime="2013-11-29 13:21:53"  结束时间点
				--database=zyyshop                     指定只恢复zyyshop数据库(一台主机上往往有多个数据库，只限本地log日志)
	            
	        不常用选项：    
				-u --user=name              Connect to the remote server as username.连接到远程主机的用户名
				-p --password[=name]        Password to connect to remote server.连接到远程主机的密码
				-h --host=name              Get the binlog from server.从远程主机上获取binlog日志
				--read-from-remote-server   Read binary logs from a MySQL server.从某个MySQL服务器上读取binlog日志

	      	小结：实际是将读出的binlog日志内容，通过管道符传递给mysql命令。这些命令、文件尽量写成绝对路径；

	      	A.完全恢复(本例不靠谱，因为最后那条 drop database zyyshop 也在日志里，必须想办法把这条破坏语句排除掉，做部分恢复)
	        	# /usr/local/mysql/bin/mysqlbinlog  /usr/local/mysql/data/mysql-bin.000021 | /usr/local/mysql/bin/mysql -uroot -p123456 -v zyyshop 

	      	B.指定pos结束点恢复(部分恢复)：
	        	@ --stop-position=953 pos结束点
	        	注：此pos结束点介于“导入实验数据”与更新“name='李四'”之间，这样可以恢复到更改“name='李四'”之前的“导入测试数据”
	        		# /usr/local/mysql/bin/mysqlbinlog --stop-position=953 --database=zyyshop /usr/local/mysql/data/mysql-bin.000023 | /usr/local/mysql/bin/mysql -uroot -p123456 -v zyyshop
	      
	        在另一终端登录查看结果(成功恢复了)：
	        	mysql> select * from zyyshop.tt;
			        +----+----------+-----+-----+---------+
			        | id | name     | sex | age | classid |
			        +----+----------+-----+-----+---------+
			        |  1 | yiyi     | w   |  20 | cls1    |
			        |  2 | xiaoer   | m   |  22 | cls3    |
			        |  3 | zhangsan | w   |  21 | cls5    |
			        |  4 | lisi     | m   |  20 | cls4    |
			        |  5 | wangwu   | w   |  26 | cls6    |
			        +----+----------+-----+-----+---------+

	      	C.指定pso点区间恢复(部分恢复)：
	        	更新 name='李四' 这条数据，日志区间是Pos[1038] --> End_log_pos[1164]，按事务区间是：Pos[953] --> End_log_pos[1195]；

	        	更新 name='小二' 这条数据，日志区间是Pos[1280] --> End_log_pos[1406]，按事务区间是：Pos[1195] --> End_log_pos[1437]；

	        c1.单独恢复 name='李四' 这步操作，可这样：
	           	# /usr/local/mysql/bin/mysqlbinlog --start-position=1038 --stop-position=1164 --database=zyyshop  /usr/local/mysql/data/mysql-bin.000023 | /usr/local/mysql/bin/mysql -uroot -p123456 -v zyyshop

           	也可以按事务区间单独恢复，如下：
	           	# /usr/local/mysql/bin/mysqlbinlog --start-position=953 --stop-position=1195 --database=zyyshop  /usr/local/mysql/data/mysql-bin.000023 | /usr/local/mysql/bin/mysql -uroot -p123456 -v zyyshop


	        c2.单独恢复 name='小二' 这步操作，可这样：
	           	# /usr/local/mysql/bin/mysqlbinlog --start-position=1280 --stop-position=1406 --database=zyyshop  /usr/local/mysql/data/mysql-bin.000023 | /usr/local/mysql/bin/mysql -uroot -p123456 -v zyyshop
	    
           	也可以按事务区间单独恢复，如下：
	           	# /usr/local/mysql/bin/mysqlbinlog --start-position=1195 --stop-position=1437 --database=zyyshop  /usr/local/mysql/data/mysql-bin.000023 | /usr/local/mysql/bin/mysql -uroot -p123456 -v zyyshop


	        c3.将 name='李四'、name='小二' 多步操作一起恢复，需要按事务区间，可这样：
	           	# /usr/local/mysql/bin/mysqlbinlog --start-position=953 --stop-position=1437 --database=zyyshop  /usr/local/mysql/data/mysql-bin.000023 | /usr/local/mysql/bin/mysql -uroot -p123456 -v zyyshop


	      	D.在另一终端登录查看目前结果(两名称也恢复了)：
	        	mysql> select * from zyyshop.tt;
			        +----+----------+-----+-----+---------+
			        | id | name     | sex | age | classid |
			        +----+----------+-----+-----+---------+
			        |  1 | yiyi     | w   |  20 | cls1    |
			        |  2 | 小二     | m   |  22 | cls3    |
			        |  3 | zhangsan | w   |  21 | cls5    |
			        |  4 | 李四     | m   |  20 | cls4    |
			        |  5 | wangwu   | w   |  26 | cls6    |
			        +----+----------+-----+-----+---------+

	      	E.也可指定时间区间恢复(部分恢复)：除了用pos点的办法进行恢复，也可以通过指定时间区间进行恢复，按时间恢复需要用mysqlbinlog命令读取binlog日志内容，找时间节点。
	        比如，我把刚恢复的tt表删除掉，再用时间区间点恢复
	        	mysql> drop table tt;

		        @ --start-datetime="2013-11-29 13:18:54"  起始时间点
		        @ --stop-datetime="2013-11-29 13:21:53"   结束时间点

		        # /usr/local/mysql/bin/mysqlbinlog --start-datetime="2013-11-29 13:18:54" --stop-datetime="2013-11-29 13:21:53" --database=zyyshop /usr/local/mysql/data/mysql-bin.000021 | /usr/local/mysql/bin/mysql -uroot -p123456 -v zyyshop

	      	总结：所谓恢复，就是让mysql将保存在binlog日志中指定段落区间的sql语句逐个重新执行一次而已。
	    </code>
MySQL权限管理
	<span class="image featured"><img src="{{ 'assets/images/other/mysqlgrantall.jpg' | relative_url }}" alt="" /></span>
	用户连接时，权限表的存取过程：
		1、先从user表中的host、user与password这三个字段中判断连接的IP、用户名和密码是否存在于表中，如果存在，则通过身份验证。
		2、如果通过身份验证，按照以下顺序得到的数据库权限：user->db->tables_priv->columns_priv
		这几个权限表中，权限范围依次递减。

		如果给用户赋予所有数据库所有表的select权限；那么在user表中，Select_priv值为Y，但是db表中没有值；就表示对所有数据库具有相同权限的用户并不需要计入db表，只用user表中的Select_priv改为Y即可，换句话说，user表中的每个权限都代表了对所有数据库都有的权限。
		如果把刚才的用户改为只在test数据库有select权限，那么在user表中Select_priv值为N，而在db表中有一条Select_priv为Y的记录。
		因此可以看出权限分配的时候是按照user->db->tables_priv->columns_priv的顺序进行权限分配，即先检查全局权限表user如果对应为Y，则对所有数据库的权限都为Y，将不再检查后面，如果为N，则到db表中检查次用户对应的具体数据库，并得到db中的权限，后面以此类推。

	创建账号：
		GRANT priv_type [, ...]
			ON [object_type] {table_name|*|*.*|db_name.*}
		TO user [IDENTIFIED BY [PASSWORD] 'password']
		[WITH GRANT OPTION] <- 是增加grant的权限

		object_type = TABLE|FUNCTION|PROCEDURE

		例：创建用户z2，可以从任何IP进行连接，权限为对test1数据库中所有表进行增删改查操作，初始密码为123
		grant select,insert,update,delete on test1.* to 'z2'@'%' identified by '123';

		权限大致为一下几个：
			ALTER: 修改表和索引。
			CREATE: 创建数据库和表。
			DELETE: 删除表中已有的记录。
			DROP: 抛弃(删除)数据库和表。
			INDEX: 创建或抛弃索引。
			INSERT: 向表中插入新行。
			REFERENCE: 未用。
			SELECT: 检索表中的记录。
			UPDATE: 修改现存表记录。
			FILE: 读或写服务器上的文件。
			PROCESS: 查看服务器中执行的线程信息或杀死线程。
			RELOAD: 重载授权表或清空日志、主机缓存或表缓存。
			SHUTDOWN: 关闭服务器。
			ALL: 所有权限，ALL PRIVILEGES同义词。
			USAGE: 特殊的 "无权限" 权限。
			
		MySQL是通过user表的host字段来进行控制，host可以是一下类型的值：
			1、主机名或者IP好，或者"localhost"指出本地主机
			2、通配符"%"和"_"
			3、与LIKE类似 "%.mysql.com" 表示匹配mysql.com域的所有主机

	查看账号权限：
		show grant for 用户名@域名 (域名可以省略，表示查找所有的)

	回收权限：
		REVOKE priv_type [, ...]
			ON [object_type] {table_name|*|*.*|db_name.*}
			FROM user [, ...]
		例：回收z2@localhost上的insert与select权限：
			revoke insert,select on *.* from z2@localhost;

	修改账号密码：
		1、shell>mysqladmin -u user_name -h host_name password "newpwd"
		2、mysql>set password for 'user_name'@'localhost' = password('newpwd')
		3、mysql>grant usage on *.* to 'user_name'@'localhost' idedtified by 'newpwd'
		4、更改数据库user表

	删除账号
		DROP USER user[, ...]
		例：drop user z2@localhost
		注：
			1、mysql安装后有些会自动创建一个空账号最好删除：drop user ''@'localhost';
			2、给root设置密码：
				root登录以后，set password=password('新密码')，没有for表示给当前用户设置。
注：绑定host的时候，域名对应的ip有可能会改，数据库就会有隐患。

MySQL常见问题：
	1、MySQL忘记root密码
		1、登录MySQL服务器
		2、kill 'cat /MySQL下data目录/***.pid'
			***.pid文件是记录MySQL运行的进程号
		3、..../bin/mysqld_safe --skip-grant-tables --user=zzx &
			Starting mysqld daemon with databases from /home/zzx/ mysql/data
		4、不使用密码连接MySQL，修改user表中的密码
		5、刷新权限表mysql>flush privileges;

<h1>架构篇</h1>
	MySQL复制：
		1、一主多从复制架构：
		<span class="image featured"><img src="{{ 'assets/images/other/mysqlcopy1.jpg' | relative_url }}" alt="" /></span>
		2、多级复制架构：
		<span class="image featured"><img src="{{ 'assets/images/other/mysqlcopy2.jpg' | relative_url }}" alt="" /></span>
		多级复制仅仅是在主库到从库中加了一个二级主库，这样可以减轻主库1的推送压力。当然，这样的活，主库到从库的延时会比一主多从架构要大。
		3、双主复制架构：(特别适用于DBA做维护需要主从切换)
		<span class="image featured"><img src="{{ 'assets/images/other/mysqlcopy3.jpg' | relative_url }}" alt="" /></span>

	异步复制搭建过程：(MySQL主从复制至少要两个MySQL服务，这些MySQL服务可以分布在不同的服务器上，也可以在同一台服务器上启动多个服务)
		注：MySQL5.5之前的复制是异步操作，主与从存在一定的延迟，就会有一个隐患：主库写入一个事务并提交成功，而从库未得到主库推送的binlog日志时主库就宕机了，从库就得不到这个事务，从而造成主从不一致。
		1、确保主从库上安装了相同版本的数据库。
		2、在主库上设置一个复制使用的账户。
			GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168....' IDEDTIFIED BY '123456';
		3、修改主数据库服务器的配置文件my.cnf，开启BINLOG，并设置server-id的值
			[mysqld]
			log-bin = /home/mysql/log/mysql-bin.log
			server-id = 1
		4、在主库上设置读锁有效，为了确保没有数据库操作，以便获得一个一致性的快照
			flush tables with read lock;
		5、得到主库上当前的二进制日志名和偏移量，为了在从数据库启动后，从这个点开始进行数据恢复
			show master status;
		6、主数据库服务器已经停止了更新操作，需要生成主数据库的备份，可以直接复制文件到从数据库服务器上，也可以使用mysqldump导出或者使用ibbackup工具进行备份。
			tar -cvf data.tar data // data是mysql下的目录，存放的是数据表的文件
		7、主数据库备份后，可以恢复写操作，剩下的操作都是在从库上执行。
			unlock tables;
		8、将主数据库的一致性备份恢复到从数据库上
		9、修改从数据库的配置文件my.cnf，增加server-id。注意，server-id的值必须是唯一的，不能与主数据库上的配置相同，如果有多个从数据库服务器，每个从数据库服务器必须有自己唯一的server-id。
			[mysqld]
			server-id = 2
		10、在从库上使用--skip-slave-start选项启动从数据库，这样不会立即启动从数据库服务上的复制进程，方便我们对从数据库的服务进行配置：
			./bin/mysqld_safe --skip-slave-start &\
			Starting mysqld daemon with databases from /home/mysql/sysdb/data
		11、对从数据库服务器做相应设置，指定复制使用的用户，主数据库服务器的IP、端口以及开始执行复制的日志文件和位置等：
			mysql>CHANGE MASTER TO
			-> MASTER_HOST='192.168....' // IP
			-> MASTER_PORT=3306 // 端口
			-> MASTER_USER='repl' // 用于远程连接的用户名
			-> MASTER_PASSWORD='123456' // 密码
			-> MASTER_LOG_FILE='mysql-bin二进制文件位置'
			-> MASTER_LOG_POS='mysql-bin二进制文件偏移量'
		12、在从库上启动slave
			mysql>start slave;
		13、执行show processlist查看slave是否执行
			mysql>show processlist \G
		14、也可以在主库上执行一个更新操作，观察从库是否同步，来测试复制服务的正确性
	可以使用一些工具，比如mysqlbinlog
	MySQL通过sync_binlog参数来控制binlog刷新到磁盘的频率：
		mysql>show variables like '%sync_binlog%';
		默认是0表示MySQL不控制binlog刷新，由文件自己控制，设置value大于0，表示每几次事务提交，MySQL调用文件系统的刷新操作，将binlog刷到磁盘。当设置为1的时候，尽最大可能保证数据安全，但是当多个是服务并发提交的时候，使得按顺序处理请求，影响MySQL的性能，所以一般设置为其他值或者是0。

	半同步复制搭建过程：(在上一节异步复制的环境上安装半同步复制插件即可)
		注：主库每次事务成功提交时，并不及时反馈给前端应用用户，而是等待其中一个从库也收到binlog事务并成功写入日志后，主库才会返回commit操作成功给客户端，保证了数据的完整性。
		1、判断MySQL是否支持动态增加插件
			select @@have_dynamic_loading;
		2、查看动态增加插件是否存在
			MySQL目录/plugin/semisync_master.so // 主库
			安装：mysql>install plugin rpl_semi_sync_master SONAME 'semisync_master.so';
			MySQL目录/plugin/semisync_slave.so // 从库
			安装：mysql>install plugin rpl_semi_sync_slave SONAME 'semisync_slave.so';
			验证：select * from mysql.plugin;
		3、主库与从库打开半同步semi-sync
			主库：
				mysql>set global rpl_semi_sync_master_enabled=1;
				mysql>set global rpl_semi_sync_master_timeout=30000;
			从库：
				mysql>set global rpl_semi_sync_slave_enabled=1;
			重启：
				mysql>STOP SLAVE IO_THREAD;
				mysql>START SLAVE IO_THREAD;
			检查半同步复制的一些状态
			mysql>show status like '%semi_sync%';
	以下是其他启动选项：
		log-slave-updates：配置从库上的更新操作是否写二进制日志，默认不打开，如果从库是作为其他的主库，需要打开。
		master-connect-retry：和主库连接丢失重试的时间间隔，默认60秒。
		read-only：用来设置从库只能接受超级用户的更新操作。
		replicate-do-db、replicate-do-table、replicate-ignore-db、replicate-ignore-table或replicate-wild-do-table来袭hi丁从主数据库复制到从数据库的数据库或者表
			例：./bin/mysqld_safe --replicate-do-table=test.testtable &

	复制常见问题：
		1、如果存在BLOG或者TEXT类型，可能出现问题，因为大文本记录无法通过网络进行传输，需要修改值：
			show variables like 'max_allowed_packet';
			SET @@global.max_allowed_packet=16777216;(16M)
		2、多台主库对一台从库会导致自增主键冲突：
			auto_increment_increment=2,auto_increament_offset=1;(1,3,5,7,9...)
			auto_increment_increment=2,auto_increament_offset=0;(0,2,4,6,8...)
		3、复制性能跟不上主库：(通过show slave status\G查看)
			1、减少表来提高性能
			2、多线程复制
				比如主库上存在2个Schema:demo和user
				设置参数slave_parallel_workers为2。
				(详情需要再查询)
		4、切换主从库(主库M出现故障，两个从库S1与S2)
			1、两个从库执行 STOP SLAVE IO_THREAD，然后检查SHOW PROCESSLIST，是否都执行了relay log中的全部更新，
			2、在S1上执行STOP SLAVE停止从服务，执行RESET MASTER以重置成主库
			3、在S2上执行STOP SLAVE停止从服务，CHANGE MASTER TO MASTER_HOST='S1'重新指定主库，再启动从库START SLAVE
			4、通知所有客户端指向S1
			5、删除新主库S1上的 master.info与relay-log.info，否则重启还会按照从库启动
			6、M服务器修复后，按照S2的方法配置成S1的从库

	高可用MMM架构：(适用于数据一致性要求不是很高，最大程度的保证业务可用性的场景)
		<span class="image featured"><img src="{{ 'assets/images/other/mysqlheighuse.jpg' | relative_url }}" alt="" /></span>
	高可用MHA架构：(MHA主要支持一主多从的架构，要求一个复制集群中至少有三台数据库服务器，一主二从，一台充当master，一台充当备用master，一台充当从库，淘宝在此基础上进行了改造，使用TMHA支持一主一从)<span class="image featured"><img src="{{ 'assets/images/other/mysqlmha.jpg' | relative_url }}" alt="" /></span>
</pre>