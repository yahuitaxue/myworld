---
title: 面试题总结
author: Yahui
layout: Other
category: Other
---

书名:《-》

<pre style="text-align: left;">
rpc微服务框架
	解决的两个问题：
		1.解决分布式系统中，服务之间的调用问题。
		2.远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。
	RPC是一种技术的概念名词
		RPC=Remote Produce Call 是一种技术的概念名词，HTTP是一种协议,RPC可以通过 HTTP 来实现,也可以通过Socket自己实现一套协议来实现.所以题目可以换一种理解,为何 RPC 还有除 HTTP 之外的实现法,有何必要，毕竟除了HTTP实现外,私有协议不具备通用性.
	Go
		官方提供一个标准 RPC库: net/rpc。
		Golang 的 rpc 支持三个级别的 RPC: TCP、HTTP、JSONRPC。但 Go 的 RPC 包只支持 Go 开发的服务器与客户端之间的交互，因为内部采用 Gob 来编码。
		Go RPC 服务端通过注册对象，使用对象的类型名暴露服务。服务端可以注册多个不同类型的对象，不能注册相同类型的多个对象。并且对象的方法需要被远程访问，必须满足以下的条件：
			方法的类型是可输出的 (the method’s type is exported)
			方法本身也是可输出的 （the method is exported）
			方法必须由两个参数，必须是输出类型或者是内建类型 (the method has two arguments, both exported or builtin types)
			方法的第二个参数必须是指针类型 (the method’s second argument is a pointer)
			方法返回类型为 error (the method has return type error)
redis过期策略和内存淘汰策略
	淘汰策略
		volatile-lru：在设置过期时间的数据中淘汰最少使用的数据。(最后一次被使用到发生调度的时间长短)
		allkeys-lru：在所有的数据中淘汰最少使用的数据。
		volatile-lfu：在设置过期时间的数据中淘汰使用频率最低的数据。(一定时间段内页面被使用的频率)
		allkeys-lfu：在所有的数据中淘汰使用使用频率最低的数据。
		volatile-random：在设置过期时间的数据中淘汰任意随机数据。
		allkeys-random：在所有的数据中随机淘汰数据。
		volatile-ttl：在设置过期时间的数据中淘汰最早过期的数据。
		noeviction：默认策略，不淘汰数据，新增或者修改数据会抛异常，但是读操作正常进行，不受影响
	过期策略
		定时过期
		惰性过期
		定期过期
sql索引优化问题
	最大化利用索引
	尽可能避免全表扫描
	减少无效数据的查询
一个update语句的执行过程
	执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
	执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
	引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
	执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
	执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。
go的profile工具？
	性能分析引用runtime/pprof包即可。
	int main() {
		create, err := os.Create("cpu.pprof")
		if err != nil {
			fmt.Println("error")
		}
		err = pprof.StartCPUProfile(create)
		if err != nil {
			fmt.Println("error")
		}
		for i := 0; i < 10; i++{
			fmt.Println(i)
			time.Sleep(time.Second)
		}
		pprof.StopCPUProfile()
	}
	生成cpu.pprof文件
	使用go tool pprof cpu.pprof分析文件内容
http和tcp有什么区别
	1.
		Http协议是建立在TCP协议基础之上的。当浏览器需要从服务器 获取网页数据的时候，会发出一次http请求。
		Http通过TCP建立起一个到服务器的通道。
	2.	
		Http是无转态的连接
		TCP是有状态的长连接

		其实很多应用并非是通过tcp 的keepalive机制探活的，因为默认的两个多小时检查时间对于很多实时系统是完全没法满足的，通常的做法是通过应用层的定时监测如PING-PONG机制（就像打乒乓球，一来一回），应用层每隔一段时间发送心跳包，如websocket的ping-pong。
	3.
		http是一个简单的请求-响应协议。
		TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。
用netstat看tcp连接的时候有关注过time_wait和close_wait吗？
	<span class="image featured"><img src="{{ 'assets/images/other/tcpfourgoodbye.jpg' | relative_url }}" alt="" /></span>
go语言的时候垃圾回收，写代码的时候如何减少小对象分配
	GC开始时将栈上可达对象全部标记为黑色（不需要二次扫描，无需STW）
	GC期间，任何栈上创建的新对象均为黑色
	被删除引用的对象标记为灰色
	被添加引用的对象标记为灰色
redis的存储结构？
	<span class="image featured"><img src="{{ 'assets/images/other/redis_base_struct.png' | relative_url }}" alt="" /></span>
	string(动态字符串)
		raw和embstr是sds动态字符串，能够节约内存。当然int 是4个字节也是可以用作32位的位图，但是其大小固定比较单一。
	双向链表
	压缩列表
		详情ziplist存储是连续的内存空间，可以做压缩。当设计计算时，ziplist明显会比双向链表的指针检索慢，因此ziplist是牺牲时间换取空间的结构。list的底层采取的是压缩列表加双向链表的存储结构
	跳表
		1.跳表结合了链表和类似二分查找的思想；
		2.有很多层结构，由原始链表和一些通过“跳跃”生成的链表组成；
		3.每一层都是一个有序的链表；
		4.最底层(Level 1)的链表包含所有元素，越上层“跳跃”的越高，元素(索引)越少；
		5.查找时从顶层向下，不断缩小搜索范围；
		6.上层链表是下层链表的子序列；
		7.每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。
	整型数组
	hash表
		dict常见称之字典(dictionary)或映射(map)，其元素以键值对形式存在。是 Redis 最重要、常用的数据结构，可以说 Redis 本质就是一个 dict。dict 是为了解决算法中的查找问题而出现的，在无冲突下理论上能达到 O(1) 查找效率。Dict 本质其实就是一个 hashtable
实现map的方法除了哈希还有哪些？
	Map通常用来存储键-值对有映射关系的数据，且key唯一不可重复，value可重复。
		HashMap
		Java中TreeMap(红黑树)
gin框架的路由是怎么处理的？
	每种请求方法管理一棵单独的树
	gin框架使用的是定制版本的httprouter，其路由的原理是大量使用公共前缀的树结构，它基本上是一个紧凑的Trie tree（或者只是Radix Tree）。具有公共前缀的节点也共享一个公共父节点。
sql索引优化方式，explain字段含义
	id：所泽标识符
	select_type：表示查询的类型
	table：输出结果集的表
	partitions：匹配的分区
	type：表示表的连接类型
		ALL(遍历全表进行匹配如：explain select * from a where 非索引列 > 9)
		index(遍历整个索引进行匹配如：explain select 索引列 from a)
		range(索引范围匹配，常见于<,<=,>,>=,between等如：explain select * from a where 索引列 > 9)
		ref(使用非唯一索引返回某个单独值的记录如：explain select * from a where 索引列 = 9)
		eq_ref(多表查询使用唯一索引使用primary key或者unique index作为关联，并且关联是只有一个对应的条件如：explain select * from 表1,表2 where 表1.id = 表2.id)
		const,system(单表中最多有一个匹配行如：explain select * from(select * from a where 主键索引或者唯一索引 = '某个值'))
		NULL(MySQL不用访问表或者索引就能得到结果如：explain select 1+2;)
	possible_keys：表示查询时，可能使用的索引
	key：表示实际使用的索引
	key_len：索引字段的长度
	ref：列与索引的比较
	rows：扫描出的行数（估算的行数）
	filtered：按表条件过滤的行百分比
	Extra：执行情况的描述和说明
gmp具体的调度策略
	go 语言的协程
		1、go 通过调度器 P，把可运行的 goroutine 分配到工作线程上
		2、P 的本地队列不超过 256 个，如果队列满了会拿出一半 G，移动到全局队列中
		3、M 线程想运行就从 P 的本地队列获取 G，P 队列为空时就尝试从全局对队列拿一批 G 放到 P 的本地队列中
	P 的数量：
		1、环境变量 $GOMAXPROCS 或者 runtime 的方法 GOMAXPROCS () 决定
	M 的数量：
		1、go 程序启动时会设置 M 的最大数量，默认 10000，但是内核很难支持这么多线程数，所以这个限制可以忽略
		2、runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量 一个 M 阻塞了会创建新的 M
	M 何时创建：
		没有足够的 M 来关联 P 并运行其中的可运行的 G。 比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。
	调度器策略
		复用线程：避免频繁的创建、销毁线程、而是对线程复用
			1、work stealing 机制
			当本线程无可运行的 G 时，尝试从其它线程绑定的 P 偷取 G，而不是销毁线程
			2、hand off 机制
			当本线程因为 G 阻塞时，该线程释放绑定的 P，把 P 转移给其它空闲的线程执行。
			并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。
			比如：GOMAXPROCS = 核数 / 2，则最多利用了一半的 CPU 核进行并行
B+树细节优势，和哈希索引的区别，是为了解决什么问题？
	1、hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。
		因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。
		而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
	2、hash索引不支持使用索引进行排序，原理同上。
	3、hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
	4、hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
	5、hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。
es内部实现原理，如何保证数据一致性，如何降低压力
	持久性：通过Replica和TransLog两种机制来共同保障。
	一致性：数据写入成功后，需完成refresh操作之后才可读，由于无法保证Primary和Replica可同时refresh，所以会出现查询不稳定的情况，这里只能实现最终一致性。
	原子性：Add和Delete直接调用Lucene的接口，进行原子操作。update操作通过Delete-Then-Add完成，在Delete操作之前会加Refresh Lock，禁止Refresh操作，等Add操作完成后释放Refresh Lock后才能被Refresh，这样就保证了Delete-Then-Add的原子性。
	隔离性：采用Version和局部锁来保证更新的是特定版本的数据。
	要保证数据写入到ElasticSerach是安全的，高可靠的，需要如下的配置：
		设置wait_for_active_shards参数大于等于2。
		设置TransLog的Flush策略为每个请求都要Flush。
	鱼与熊掌不可兼得，大家需要根据实际场景合理设置参数在可靠性和可用性之间进行折中。
分库分表联表查询有哪些方式
	按时间维度（年/月/日）
		业务跟时间关联度高
		同一时间段内业务数据量分布比较均匀
		适用于报表、统计系统相关的业务
	HASH
		HASH函数的算法是简单取模，若分库和分表使用不同拆分键进行HASH时，则根据分库键的键值直接按分库数取模，如果键值是字符串，则字符串会先被换算成哈希值再进行路由计算。若分库和分表都使用同一个拆分键进行HASH时，则根据拆分键的键值按总的分表数取模
			一个分表键够用
			适合于需要按用户ID或订单ID进行分库分表的场景
			适合于拆分键是数字、字符串类型的场景
	RANGE_HASH
		选取两个拆分键，两个拆分键的后N位需确保一致，根据任一拆分键后N位计算哈希值，然后再按分库数取模，完成路由计算。此路由方式需要自行实现分片算法
			两个拆分键有关联
			查询时有其中一个拆分键值的场景
		如果采取RANGE_HASH函数作为分库分表，则最优方案是以订单号和买家id的后N位做分库分表，后续按订单号维度、买家id维度查询都能满足，卖家维度无法查询。但是前提是订单号后几位和买家id要有关联，涉及到订单号改造的过程
	ShardingSphere
		在拆分工具选择上，这里借助ShardingSphere[官网]，ShardingSphere是一套开源的分布式数据库解决方案组成的生态圈，它们能提供数据分片、分布式事务、分布式治理等功能
	综上
		因为订单一般都是由买家发起生成的，所以我们认为优先处理买家数据和订单号数据比较合理，所以我们先采用RANGE_HASH拆分算法按买家id后N位、订单号后N位维度做分库分表，作为买家表逻辑表。再用HASH拆分函数按商家id冗余一份数据，作为卖家表逻辑表
			买家库、买家表：下单填充买家表数据，用于以订单号、以买家id查询
			卖家库、卖家表：异步冗余一份买家表数据到卖家表，用于根据卖家id查数据
go实现不重启热部署
	 使用 fresh 实现热部署
		# 安装 fresh
		$ go get github.com/pilu/fresh
		# 跳转到项目目录,例如项目名为‘myapp’
		$ cd /path/to/myapp
		# 启动
		$ fresh
	使用 gin 实现热部署
		# 安装 fresh
		$ go get github.com/codegangsta/gin
		# 验证gin是否安装成功
		$ gin -h
		# 启动
		$ gin run main.go
tcp如何保证稳定性
	滑动窗口和流速控制
		111[22233]44444
			深绿色(1)代表已经收到 ACK 的段
			浅绿色(2)代表发送了，但是没有收到 ACK 的段
			白色(3)代表没有发送的段
			紫色(4)代表暂时不能发送的段
	如果发送过程中，部分数据没能收到 ACK 会怎样呢？这就可能发生重传。
		111[12111]44444
			如果段4(2)迟迟没有收到ACK。
			这个时候滑动窗口只能右移一个位置，如下图所示：
		1111[21114]4444
			在这个过程中，如果后来段4(2)重传成功(接收到ACK)，那么窗口就会继续右移。如果段4(2)发送失败，还是没能收到ACK，那么接收方也会抛弃段5、段6、段7。这样从段4开始之后的数据都需要重发。
		快速重传
		在 TCP 协议中，如果接收方想丢弃某个段，可以选择不发 ACK。发送端超时后，会重发这个 TCP 段。而有时候，接收方希望催促发送方尽快补发某个 TCP 段，这个时候可以使用快速重传能力。
		例如段 1、段 2、段 4 到了，但是段 3 没有到。 接收方可以发送多次段 3 的 ACK。如果发送方收到多个段 3 的 ACK，就会重发段 3。这个机制称为快速重传。这和超时重发不同，是一种催促的机制。
		为了不让发送方误以为段 3 已经收到了，在快速重传的情况下，接收方即便收到发来的段 4，依然会发段 3 的 ACK（不发段 4 的 ACK），直到发送方把段 3 重传。
	注：
		1.在上面所有的图片中，窗口大小是 TCP 段的数量。实际操作中，每个 TCP 段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中窗口大小单位是字节数。
		2.窗口越大，同时可以发送、接收的数据就越多，支持的吞吐量也就越大。当然，窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。
http和http2区别
	1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
		二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示
	2.HTTP2支持多路复用
		因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求
	3.HTTP2头部压缩
		HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值
	4.HTTP2支持服务器推送
		HTTP2支持在未经客户端许可的情况下，主动向客户端推送内容
https的连接过程
	<span class="image featured"><img src="{{ 'assets/images/other/https_connect_step.jpg' | relative_url }}" alt="" /></span>
kafka如何做到高可用
	Replication：副本，是 Kafka 保证数据高可用的方式，Kafka 同一 Partition 的数据可以在多 Broker 上存在多个副本，通常只有主副本对外提供读写服务，当主副本所在 broker 崩溃或发生网络一场，Kafka 会在 Controller 的管理下会重新选择新的 Leader 副本对外提供读写服务。
分布式锁如何实现
	mysql
	redis
	ZooKeeper
		是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：
		1.创建一个目录mylock；
		2.线程A想获取锁就在mylock目录下创建临时顺序节点；
		3.获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；
		4.线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；
		5.线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。
go并发机制
	不是通过共享内存通信，而是通过通信共享内存
	通过使用 goroutine 和 channel，可以编写运行速度更快且易于理解的并发程序
线程协程区别
	线程是进程内的一个执行单元(处理器调度的基本单位)，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间
	线程与进程均可并发执行
	一个线程可以多个协程，一个进程也可以单独拥有多个协程
	线程进程都是同步机制，而协程则是异步。
	线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力
常用限流算法
	计数限流
		每次请求来的时候看看计数器的值，如果超过阈值要么拒绝。
		非常的简单粗暴，计数器的值要是存内存中就算单机限流算法。存中心存储里，例如 Redis 中，集群机器访问就算分布式限流算法。
		优点就是：简单粗暴，单机在 Java 中可用 Atomic 等原子类、分布式就 Redis incr。
		缺点就是：假设我们允许的阈值是1万，此时计数器的值为0， 当1万个请求在前1秒内一股脑儿的都涌进来，这突发的流量可是顶不住的。缓缓的增加处理和一下子涌入对于程序来说是不一样的。
	固定窗口限流算法
		首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。
		当次数少于限流阀值，就允许访问，并且计数器+1
		当次数大于限流阀值，就拒绝访问。
		当前的时间窗口过去之后，计数器清零。
		假设单位时间是1秒，限流阀值为3。在单位时间1秒内，每来一个请求,计数器就加1，如果计数器累加的次数超过限流阀值3，后续的请求全部拒绝。等到1s结束后，计数器清0，重新开始计数。
	滑动窗口限流
		滑动窗口限流解决固定窗口临界值的问题，可以保证在任意时间窗口内都不会超过阈值。
		相对于固定窗口，滑动窗口除了需要引入计数器之外还需要记录时间窗口内每个请求到达的时间点，因此对内存的占用会比较多。
		规则如下，假设时间窗口为 1 秒：
		记录每次请求的时间
		统计每次请求的时间 至 往前推1秒这个时间窗口内请求数，并且 1 秒前的数据可以删除。
		统计的请求数小于阈值就记录这个请求的时间，并允许通过，反之拒绝。
	令牌桶算法原理：
		有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。
		如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。
		系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑；
		如果拿不到令牌，就直接拒绝这个请求。
IO多路复用
	一个进程/线程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程/线程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。
为什么内存操作很快
	因为CPU的速度很快，硬盘跟不上CPU的速度，在运行时无法同步，所以无法直接对硬盘操作
	CPU也不是直接操作内存的，内存的速度虽然比硬盘快，但是也没有CPU快，所以在CPU和内存之间还有 缓存
k8s各种组件
	1、kube-apiserver：集群中所有资源的统一访问入口；
	2、kube-scheduler：将新创建的pod调度到合适的节点上
	3、kube-controller-manager：集群中所有资源对象的自动化控制中心；
	4、etcd：保存集群中的所有资源对象的数据、
	二、工作节点主要包括以下组件：
	1、kubelet：负责pod对应的容器的创建、启停等任务，同时与Master节点密切协作，实现集群管理的基本功能；
	2、kube-proxy：将对service的访问转发到后端的一组pod上；
	3、容器运行时（Container Runtime）：容器运行时是负责运行容器的软件，k8s支持许多容器运行时，常用的是docker。
gomap并发安全问题，如何解决
	map是引用类型，未初始化的map是nil
	因为map变量为 指针类型变量，并发写时，多个协程同时操作一个内存，类似于多线程操作同一个资源会发生竞争关系，共享资源会遭到破坏，因此golang 出于安全的考虑，抛出致命错误：fatal error: concurrent map writes
	在写操作的时候增加锁，删除时候除了加锁外，还需要增加断言避免出现错误
go中的锁
	开箱即用
	var rwm = sync.RWMutex
	写锁定和写解锁
	rwm.Lock()
	rwm.Unlock()
	读锁定和读解锁
	rwm.RLock()
	rwm.RUnlock()
docker底层实现原理
	底层原理就是利用Linux的cgroups和namespace，本质上就是操作系统的一个进程，cgroups主要负责资源分配，namespace主要负责容器间的隔离（包括进程和网络等等）
集群分布式
	单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。

	分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，
	在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。
etcd
	使用Go语言开发的一个开源的、高可用的分布式key-value存储系统，可以用于配置共享和服务的注册和发现
	类似项目有zookeeper和consul。
数据库分库分表，啥时候分库啥时候分表
	分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master
	服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了
层序遍历二叉树
	func showTree(t treeNode) []int {
		var tmp []int
		if t.leftNode != nil {
			left := showTree(t.leftNode.(treeNode))
			for _,v := range left {
				tmp = append(tmp, v)
			}
		}
		tmp = append(tmp, t.value)
		if t.rightNode != nil {
			right := showTree(t.rightNode.(treeNode))
			for _,v := range right {
				tmp = append(tmp, v)
			}
		}
		return tmp
	}
判断二叉树是否是镜像二叉树
中间件:kafka丢失消息和不重复消费
	consumer端丢失消息的情形比较简单：如果在消息处理完成前就提交了offset，那么就有可能造成数据的丢失。由于Kafka consumer默认是自动提交位移的，所以在后台提交位移前一定要保证消息被正常处理了，因此不建议采用很重的处理逻辑，如果处理耗时很长，则建议把逻辑放到另一个线程中去做。为了避免数据丢失，可以采用手动提交offset：（1）enable.auto.commit=false 关闭自动提交位移、（2）在消息被完整处理之后再手动提交位移

	生产者丢失消息是最复杂的情形了。生产者(Producer) 使用 send 方法发送消息实际上是异步的操作，我们可以通过 get()方法获取调用结果，但是这样也让它变为了同步操作，但是一般不推荐这么做！可以采用为其添加回调函数的形式。这个回调函数会在 Producer 收到 ack 时调用，此处就和acks参数配置[1、0、-1]密切相关了
redis底层数据结构实现
	typedef struct redisObject{
	    //类型
	    unsigned type:4;
	    //编码
	    unsigned encoding:4;
	    //对象最后一次被访问的时间
	    unsigned lru:REDIS_LRU_BITS
	    //引用计数
	    int refcount
	    //指向底层实现数据结构的指针
	    void *ptr;
	    ...
	}
对一个链表进行排序
	最佳方法：归并排序
		1.找到中间节点
		2.将中间节点断成左右两半，然后再次递归找到中间节点，再次进行分割，直到最后分割成一个一个的单个元素
		3.然后两两排序，之后四四排序…直到最后将整张链表排成一个有序链表
		这个思想和归并排序一样，归并排序的原理也是将数据分割成小部分，然后每一个小部分进行排序，让局部有序，然后整体有序
给n个数1n，随机n次，将这n个数输出
	洗牌算法
		在整个数组 [0, n-1] 中（包括最后一个元素）随机选出一个元素，将它和最后那个元素 [n-1] 交换，然后再在数组 [0, n-2] 中随机选出一个元素，将它与倒数第二个元素 [n-2] 交换…一直到最后一个元素，就完成了算法
io多路复用，select\poll\epoll的实现和区别
	用来实现多路复用的，即一个线程利用它们即可 hold 住多个 socket,线程不可被任何一个被管理的 Socket 阻塞，且任一个 Socket 来数据之后都得告知 select/poll/epoll 线程
	(注意一下内核态和用户态的交互，用户程序访问不了内核空间。)
	select
		调用 select 会把所有要管理的 socket 的 fd (文件描述符，Linux下皆为文件，简单理解就是通过 fd 能找到这个 socket)传到内核中,遍历所有 socket，看看是否有感兴趣的事件发生。如果没有一个 socket 有事件发生，那么 select 的线程就需要让出 cpu 阻塞等待，这个等待可以是不设置超时时间的死等，也可以是设置 timeout 的有超时时间的等待。
		当 socket 接收到网卡的数据后，就会去它的睡眠队列里遍历 entry，调用 entry 设置的 callback 方法，这个 callback 方法里就能唤醒 select ！
		所以 select 在每个被它管理的 socket 的睡眠队列里都塞入一个与它相关的 entry，这样不论哪个 socket 来数据了，它立马就能被唤醒然后干活！
		但是，select 的实现不太好，因为唤醒的 select 此时只知道来活了，并不知道具体是哪个 socket 来数据了，所以只能傻傻地遍历所有 socket ，看看到底是哪个 scoket 来活了，然后把所有来活的 socket 封装成事件返回
		(因为被管理的 socket fd 需要从用户空间拷贝到内核空间，为了控制拷贝的大小而做了限制，即每个 select 能拷贝的 fds 集合大小只有1024)
	poll
		poll 这玩意相比于 select 主要就是优化了 fds 的结构，不再是 bit 数组了，而是一个叫 pollfd 的玩意，反正就是不用管啥 1024 的限制了。(现在也没人用 poll，就不多说了)
	epoll
		select存在的问题
			1.比如，为什么每次 select 需要把监控的 fds 传输到内核里？不能在内核里维护个？
			2.为什么 socket 只唤醒 select，不能告诉它是哪个 socket 来数据了？
			epoll 主要就是基于上面两点做了优化。
		过程
			1.搞了个叫 epoll_ctl 的方法，这方法就是用来管理维护 epoll 所监控的哪些 socket(这个 socket 集合是用红黑树实现的)
			2.然后和 select 类似，每个 socket 的睡眠队列里都会加个 entry，当每个 socket 来数据之后，同样也会调用 entry 对应的 callback。
			3.与 select 不同的是，引入了一个 ready_list 双向链表，callback 里面会把当前的 socket 加入到 ready_list 然后唤醒 epoll。
			4.这样被唤醒的 epoll 只需要遍历 ready_list 即可
长连接和短链接(怎么实现的、区别以及应用场景)
	短链接
		(建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接)
		WEB 网站的 http 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像 WEB 网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源
	长连接
		(建立连接——数据传输…（保持连接）…数据传输——关闭连接)
		1.长连接可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，适合长连接
		2.client 与 server 之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server 早晚有扛不住的时候，这时候 server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 server 端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务
		3.数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket 创建也是对资源的浪费
		4.客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接
socket与http
	TCP套接字编程，也就是所谓的socket
	HTTP也是基于TCP socket的高层封装，通过Socket传输包协议，完成之后发送FIN结束连接
	通过比较发现http和socket完全是两个不同的概念，http是应用层的，socket是传输层和网络层的，http要基于socket实现。httpclient的默认请求超时时间为60s。
WebSocket
	WebSocket则是一个典型的应用层协议
	WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。
	过程
		Websocket是基于HTTP协议的，或者说 借用了HTTP的协议来完成一部分握手(会通知服务器使用WebSocket来进行握手)
缓存和数据库一致性的问题
	2、引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」
	3、更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，解决方案是加「分布锁」，但这种方案存在「缓存资源浪费」和「机器性能浪费」的情况
	4、采用「先删除缓存，再更新数据库」方案，在「并发」场景下依旧有不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估
	5、采用「先更新数据库，再删除缓存」方案，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据最终一致
	6、采用「先更新数据库，再删除缓存」方案，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率
hash冲突解决办法，有什么弊端
	1.链地址法
		对于相同的哈希值，使用链表进行连接。（HashMap使用此法）
		优点
			处理冲突简单，无堆积现象。即非同义词决不会发生冲突，因此平均查找长度较短；
			适合总数经常变化的情况。（因为拉链法中各链表上的结点空间是动态申请的）
			占空间小。装填因子可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计
			删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。
		缺点
			查询时效率较低。（存储是动态的，查询时跳转需要更多的时间）
			在key-value可以预知，以及没有后续增改操作时候，开放定址法性能优于链地址法。
			不容易序列化
	2.再哈希法
		提供多个哈希函数，如果第一个哈希函数计算出来的key的哈希值冲突了，则使用第二个哈希函数计算key的哈希值。
		优点
			不易产生聚集
		缺点
			增加了计算时间
	3.建立公共溢出区
		将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。
	4.开放定址法
		当关键字key的哈希地址p =H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，若p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中
		优点
			容易序列化
			若可预知数据总数，可以创建完美哈希数列
		缺点
			占空间很大。（开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间）
单链表找到中间节点
	1.先统计链表节点个数 L。如果链表节点个数是奇数则第 L/2+1 个节点 是链表的中间节点；如果链表节点个数是偶数个，则 L/2 和 L/2+1 都是中间节点。
	2.使用快慢指针的方式，快指针 fast 前进两步，慢指针 slow 前进一步，当快指针 fast 到达链表尾部时，慢指针 slow 刚好到达链表的中间。如果链表节点个数是奇数则 slow 是链表的中间节点；如果链表节点个数是偶数则 slow 和 slow->next 都是链表的中间节点。(注意，带头结点的单链表，初始情况下 fast 和 slow 都是从头结点开始的)
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针
sleep底层实现原理
	挂起进程（或线程）并修改其运行状态
	用sleep()提供的参数来设置一个定时器。
	当时间结束，定时器会触发，内核收到中断后修改进程（或线程）的运行状态。例如线程会被标志为就绪而进入就绪队列等待调度。
	可变定时器(variable timer)一般在硬件层面是通过一个固定的时钟和计数器来实现的，每经过一个时钟周期将计数器递减，当计数器的值为0时产生中断。内核注册一个定时器后可以在一段时间后收到中断。
docker和虚拟机区别
	1.虚拟机包括应⽤，必要的⼆进制和库，以及⼀个完整的⽤户操作系统,docker中宿主机共享硬件资源及操作系统可以实现资源的动态分配
	2.docker隔离性更弱，docker属于进程之间的隔离，虚拟机可实现系统级别隔离
channel和锁对比一下
	channel选择
		channel是线程安全的并且不会有数据冲突，比锁好用多了
		1.对性能要求很高的临界区
		2.视图保护某个结构内部状态
	lock.Mutex选择
		1.转让数据的所有权
		2.协作多个逻辑片段
slice/array/map区别
	array
		可以存储相同类型的元素的固定大小顺序集合。数组的每个元素在内存中都是连续存放的，每个元素都有一个下标，下标从0开始。数组长度可以省略，会自动根据{}中的元素来进行推导。没有初始化的索引，默认值是数组类型的零值。数组用于存储数据集合，但将数组视为同一类型的变量的集合通常更有用。
	slice
		Go数组的一个抽象。可以理解为动态的数组，切片是基于数组实现的，它的底层就是一个数组。对于数组的分割，便可以得到一个切片。eg:array[start:end] 可以得到包括start下标到end（不包括end下标元素） 的子数组
	map
		是一个无序的 k-v 键值对集合。 给定一个键和一个值就可以在Map对象中设置值。设置存储值后，就可以使用其键检索它对应的值了。其中 k 必须是相同类型。k 和 v 的类型可以不同。k 的类型必须支持 == 比较运算符，这样才可以判断它是否存在，并保证唯一
	array 为值类型，这意味着当数组变量被赋值时，将会获得原数组的拷贝。新数组中元素的改变不会影响原数组中元素的值。
	slice、map 为引用类型，赋值的时候是将指针复制给新的变量, 这意味着当元素被改变时，slice、map中元素的值会跟随改变。
向为nil的channel发送数据会怎么样
	会阻塞
	var ch chan int
	ch = make(chan int, 3)
	select {
	case aa := <-ch:
		fmt.Println(aa)
	case ch<-11:
		fmt.Println("有写入")
	}
MVCC原理
	指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。
	在内部实现中，InnoDB通过undo log保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。
	MVCC只在已提交读（Read Committed）和可重复读（Repeatable Read）两个隔离级别下工作，其他两个隔离级别和MVCC是不兼容的。因为未提交读，总数读取最新的数据行，而不是读取符合当前事务版本的数据行。而串行化（Serializable）则会对读的所有数据多加锁。
	MVCC的实现原理主要是依赖每一行记录中两个隐藏字段，undo log，ReadView
ACID的涵义，MYSQL是如何保证的
	原子性（Atomicity）：指事务不可分割，要么全部成功，要么全部失败，不可能存在部分成功或部分失败的情况。如果执行某一条语句失败后，将会触发之前所有执行过的语句的回滚，因此靠的是undo log。
	一致性（Consistency）：在事务执行前后，数据的完整性没有遭到破坏。一致性是mysql追求的最终目标，需要数据库层面与应用层面同时来维护。需要先满足原子性、隔离性与持久性，同时也需要应用层面做保障，即在应用层面对数据进行检验。
	隔离性（Isolation）：事务之前是隔离的，并发执行的事务之间不存在互相影响，mysql通过锁以及MVCC来保证隔离性。
	持久性（Durability）：事务一旦提交，那么对数据的操作就是永久性的，即使接下来数据库宕机也不会有影响。mysql是通过redo log来实现宕机恢复的，而binlog主要是用来误删恢复与主从复制的。
缓存失效的几种场景，以及解决方案
	1.缓存穿透
		用户不断发请求访问缓存和数据库中都没有的数据。如访问id为-1的数据或id为特别大不存在的数据。此时用户很可能是攻击者，攻击导致数据库压力过大
		解决：
			缓存空结果(加短暂过期时间)、布隆过滤器、mvc拦截器
	2.缓存雪崩
		由于设置缓存key采用相同的过期时间，缓存在某一时刻同时失效，请求全部转发带数据库。数据库压力过重导致雪崩
		解决：
			1、规避雪崩：缓存过期时间随机，防止大量数据过期现象发生
			2、分布式部署：若缓存数据库是分布式部署，将热点数据均匀分布在不同缓存数据库中
			3、设置热点数据永不过期
			4、出现雪崩：降级、熔断
			事前：尽量保证整个Redis集群的高可用性，发现机器宕机尽快补上。选择内存合适的内存淘汰策略
			事中：本地ehcache缓存 + hystrix限流&降级，避免mysql崩溃
			事后：利用redis持久化机制保存的数据尽快恢复缓存
	3.缓存击穿
		与缓存雪崩不同的是
		1、击穿是指并发查询同一条数据，缓存中不存在但数据库中存在的数据（一般是缓存时间到期）。此时由于并发用户特别多，同时没能从缓存中读取到数据，而去数据库中去取，引起数据库压力瞬间增大，造成过大压力
		2、雪崩是指不同数据同时过期，很多的数据都查不到而查询数据库
		解决方案：
			1、设置热点数据永不过期
			2、加互斥锁：业界常用的做法是使用mutex。缓存失效的时候（判断从缓存中取出来的是空值），不是立即取数据库加载，而是先使用缓存工具的某些带成功操作返回值的操作（如redis的setnx和memcache的add）去set一个mutex key，当操作返回成功时，再进行加载load db的操作并回设缓存；否则重试整个get缓存方法
gostruct能不能比较
	同类型(A struct 与 A struct)有特殊字段(如 Slice)不能比较
	不同类型(A struct 与 B struct)不能比较
select的作用
	是一种go可以处理多个通道之间的机制，看起来和switch语句很相似，但是select其实和IO机制中的select一样，多路复用通道
context包的用途
	type Context
    func WithValue(parent Context, key, val interface{}) Context

    func main() {
		type favContextKey string
		f := func(ctx context.Context, k favContextKey) {
			if v := ctx.Value(k); v != nil {
				fmt.Println("found value:", v)
				return
			}
			fmt.Println("key not found:", k)
		}
		k := favContextKey("小米")
		ctx := context.WithValue(context.Background(), k, "小米")
		f(ctx, k)
		f(ctx, favContextKey("小红"))
	}
client如何实现长连接
	TCP协议的KeepAlive机制与HeartBeat心跳包
主协程如何等其余协程完再操作
	Go提供了更简单的方法——使用sync.WaitGroup。WaitGroup，就是用来等待一组操作完成的。WaitGroup内部实现了一个计数器，用来记录未完成的操作个数.
	它提供了三个方法，Add()用来添加计数。Done()用来在操作结束时调用，使计数减一。Wait()用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回。
		var wg sync.WaitGroup
	    wg.Add(2) // 因为有两个动作，所以增加2个计数
	    go func() {
	        fmt.Println("Goroutine 1")
	        wg.Done() // 操作完成，减少一个计数
	    }()
	    go func() {
	        fmt.Println("Goroutine 2")
	        wg.Done() // 操作完成，减少一个计数
	    }()
	    wg.Wait() // 等待，直到计数为0
map如何顺序读取
	map是无序的,所以如果想要实现顺序读取,需要首先将map的key存放为slice,然后进行排序,最后在按照排序后的key输出map的值


docker容器化技术的核心技术
对k8s的基础概念的了解情况
对k8s有哪些操作呢？
k8syml文件是如何写的？
linux常用操作
查端口用什么命令？
	netstat -ntulp
lsof查不到的话用什么命令？
	获取任何被打开文件的各种信息，只需输入 lsof 就可以生成大量的信息，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。
	lsof访问的是核心文件和各种文件，所以必须以root用户的身份运行才能充分发挥其功能

数组和切片的关系和区别
	数组
		数组是值类型
	切片(底层是包含数组的结构体)
		append操作本质上是对数组扩容
		已建数组实际上无法改变大小，append操作会在底层创建一新的数组newArr(其长度按照扩容的大小)
		slice原来所包含的元素拷贝到新的数组newArr，新增的元素随着添加到newArr
		slice再重新引用到数组newArr
		需注意newArr是在底层维护的，只能通过slice访问
		切片的拷贝，使用copy方法：copy(slice01,slice)，将slice拷贝给slice01。
channel和共享内存有什么优劣势？
	(不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存)
	1.共享内存的方式进行通信
		func watch(p *int) {
			for true {
				if *p == 1 {
					fmt.Println(a...:"hello")
					break
				}
			}
		}
		func main() {
			i := 0
			go watch(&i)
			time.Sleep(time.Second)
			
			i = 1
			time.Sleep(time.Second)
		}
		// output:
		// hello
	2.通信的方式共享内存
		func watch(c chan int) {​    
			if <-c == 1 {        
				fmt.Println("hello")    
			}
		}
		​func main() {    
			c := make(chan int)
			go watch(c)​    
			time.Sleep(time.Second)​    
			c <- 1​
			time.Sleep(time.Second)
		}
		// output：
		// hello
	channel实质上是一个名为hchan的结构体
go里面interface是什么概念
相比于javac++interface有什么区别吗？
docker是基于什么来实现的
docker分层打包了解吗
docker怎么看日志
容器的cpu和内存占比
docker端口映射怎么看？
后续的技术规划是怎样的？

反问
你是这边项目的leader吗？
团队情况是什么样的？
面试的岗位是不确定的是吗？
会有月度谈话之类的吗？
您能说下您的工作经历吗？

京东云
实现lru，大概写下思路
自我介绍
项目介绍：问的比较细
devops相关
介绍下k8s的基础组件
k8s组件的职责
介绍下和k8s有关的项目
项目优化流程怎么做的？
问了很多项目细节
实时报警怎么做的
性能优化怎么做的？怎么发现问题的？怎么修复的？
项目里面你的职责主要是什么？
对linux常用命令熟悉吗
数组和切片的区别
线程和协程的区别
一个进程能创建多少线程受哪些因素的限制
golang用到哪些框架
反转单链表如何实现，口述一下
说一下上面lru算法的实现思路
你觉得java和golang有什么优势劣势？

旷视科技
快排
对docker和k8s使用多吗？使用到什么程度？
定制化开发了哪些功能？
监听pod状态变化是怎么实现的
对k8s使用了解到什么程度，组件这些
如果有一个节点不可用了，如何把pod驱逐到其他节点
kubectlapply和create有什么区别
如何更新一个k8s服务
pod里面可以有多个容器吗
pod内容器是相互隔离的吗
你们怎么去监控一个服务是否故障
容器日志是如何采集的，流程是怎么走的
dockerfile经常写，有什么常用命令
cmd和entrypoint有什么区别
介绍下在线上课的项目
对redis作为缓存使用熟悉吗？
雪崩、穿透、击穿说下以及如何解决预防
缓存淘汰机制了解吗，lru说下
golangwait.group用过吗？
go里面map是并发安全的吗？不是并发安全该如何使用？
读写锁说下
defer用的多吗？有哪些应用
异常捕获是如何做的？
常用的数据结构说下
redis跳表知道吗？
跳表和二叉检索树优劣
数组是如何实现用下标访问任意元素的
浏览器浏览网页前进后退如何实现？
如何查找一个无序数组的第K大元素

滴滴
写个二分查找
自我介绍
挑一个项目具体说下
怎么理解“不要用共享内存来通信，而是用通信来共享内存”
用过什么缓存？
redis是单线程还是多线程？
redis作为单线程，是怎么支持高并发的？
对内存操作更深入的了解过吗？
有没有想过内存操作为什么很快？
redis内存操作很快？有没有IO读写
IO读写什么时候会发生？
IO什么时候会做写入？
redis写入通信协议是什么？
redis写入操作IO操作快是因为异步
用go协程的时候也是要走IO的，go是如何处理的？
IO多路复用有看过吗？
redis的数据结构了解哪些？深入说下内部实现
跳表是一种什么结构？
扩展类型说下
hyperloglog详细说下
数据库用过哪些？
数据库引擎用什么?
怎么理解ACID这个概念
innoDB支持事务，他为什么支持事务？
看过B树B+树这些数据结构吗？理解不理解这些树的构造，是要解决什么问题？
说下对docker的理解，是解决什么问题的？
工作的时候用过什么消息中间件？
版本控制用的什么？
平时是怎么学习的？

自我介绍
你个人更偏好业务方向和基础架构方向？
挑一个对你来说有挑战的项目，说下其中的难点，是怎么解决的？
用redis在服务里面解决什么样的问题？
nodejs和go是基于什么样的考虑是用这两种语言的？
限制用户评论过去一个小时内只能评论三次，用redis实现？
mysql的存储引擎了解哪些？
mysql索引用过哪些？
了解过聚簇索引和非聚簇索引吗？
覆盖查询和回表查询了解吗？
分析sql性能好坏如何分析？
explain里面其他字段关注过吗？type字段关注过吗？
B+树和哈希索引区别是什么？
锁的类型用过哪些
什么叫悲观锁、什么叫乐观锁
乐观锁如何保证最终一致性？
事务的基本特性？解释一下
事务隔离级别有哪些？解释一下
分库分表分区有哪些差别？
分表遇到联表查询怎么分页？
shardingjdbc如何实现分页查询的？其内部偏移如何实现的？
除了用jdbc和中间件方式之外，分库分表下联表查询还有别的解决方案吗？
nginx用过吗？
大致了解nginx的哪些功能？
nginx的负载均衡是在第几层？
除了nginx的负载均衡还了解过其他负载均衡吗？
反向代理和正向代理有什么差别吗？
linux熟悉吗？
如何统计nginx日志里面的访问量最多的十个IP地址？
es用过吗？使用过哪些功能？
了解其内部实现吗？
es写入数据如何保证两边数据一致性，两边数据同时写入会越来越大？

自我介绍
对新的机会主要看哪些方面？
挑一个个人感觉比较满意，存在技术挑战的事情，说一下细节
在基础架构服务稳定性方面有什么总结吗？
如何保证服务高并发的？
细节的优化点有哪些？
golang垃圾回收机制了解吗？
mysql主键索引和非主键索引在搜索和检索过程中有什么区别吗？
事务的隔离级别有哪些？
脏读幻读说一下
mysql如何实现事务的？
mysql主从同步过程了解吗？
分库分表常用模式
一开始一个项目数据比较多，后来需要分库分表，有什么思路在不停服务的情况下做到平滑切换？
设计一个短链接服务

学而思
自我介绍
在第一家公司主要做些什么？
后端核心开发的项目是什么？
权限系统如何做？
接口权限如何做？
在线消息服务讲下
如何避免redis故障
日志监控怎么做的？如何设计的？
写入ES想过如何降低压力吗？
火焰图怎么来寻找瓶颈的？
gpm模型
如何实现一个线程安全的map
创建一个数组底层扩容
make一个slice参数怎么写？
mysql的索引结构
对b+树了解吗？
什么会影响联合索引查询效率
用栈实现队列
用栈能实现双向队列吗？
主要做哪些基础架构工作呢？

网易
自我介绍
未来的主要方向
介绍下之前的项目用到的优化点、难点
为什么不要大量使用goroutine
gpm模型
go里面goroutine创建数量有限制吗？
线程和协程有什么区别
golang支持哪些并发机制
go利用channel通信的方式
有缓冲和无缓冲channel的区别
channel实现原理
被close的channel会有什么问题
分布式锁知道哪些？用channel如何实现？
集群用channel如何实现分布式锁
并行goroutine如何实现
go用共享内存的方式实现并发如何保证安全？
go的锁是可重入的吗？
获取不到锁会一直等待吗？
那如何实现一个timeout的锁？
go切片是如何实现的
主要用redis实现哪些功能
缓存穿透如何解决
常用限流算法
令牌桶和漏桶有什么区别
不同服务之间通信有哪些方式
一次rpc要经过哪些过程
rpc框架如何做性能调优
用过哪些rpc框架
说下熔断、限流、降级、雪崩
熔断降级知道哪些开源框架吗？
docker和虚拟机有什么区别
serviceMash用来解决什么问题的？
devops相关技术有哪些

美团
自我介绍
监控软件用的什么？
为什么没用开源监控软件
现在的监控体系是什么流程？
为什么没用logstash？
非递归方式实现前序遍历二叉树

腾讯
算法lru
项目相关
go语言如何实现服务不重启热部署
go性能分析工具
tcp如何实现稳定性
http和http2区别
https如何实现的，证书是怎么获取的？
如何实现分布式锁
gpm模型
为什么gpm模型会更快？
线程协程区别
redis如何做到高可用
redis故障转移策略
kafka如何做到高可用
mysql事务的隔离级别

格步科技
自我介绍
用k8s主要做哪些功能？
链表和数组的区别，以及各种操作上的复杂度
谈下对散列表的理解，深入
对lru算法了解吗？在上面场景下使用呢？
说下你知道的排序算法
说下快排的大概的操作过程
快排的平均的时间复杂度
快排什么情况下是最慢的？
常用的数据库有哪些？
mysql的事务四个特性
mysql事务的隔离级别，分别解决了什么问题？
一条sql语句比较慢用什么方式去优化？
从浏览器上输入一个网址到浏览器加载内容，中间过程中发生了哪些事情？尽可能说知道的
nginx负载均衡策略
服务器上有大量time_wait状态，如何分析一下为什么会这样？
算法：一个奇怪的没听明白的问题
算法：括号匹配问题，说下思路

知乎
实现一个函数，有两个参数分别是升序的整数数组a和b，返回合并后的升序整数数组
待优化SQL
```
SELECTa,b,c,dFROMtb
WHEREc=4
ORDERBYa,b
索引
(c)
待优化SQL
SELECTa,b,c,dFROMtb
WHEREa=9ANDc=4
ORDERBYa,b
索引
(a,c)
待优化SQL
SELECTa,b,c,dFROMtb
WHEREb=9ANDa>4
ORDERBYa,b
索引
(a,b)
```
说下项目
视频是如何做的？
展开讲下技术点和收获
知道mysqlinnodb是什么数据结构吗？
用基础数据结构实现一个map
map会遇到一些并发安全的问题，为什么就并发不安全了？
为什么给变量一个基础类型没有并发安全问题？
如何解决这个问题？
rpc底层实现
是如何做到和本地调用一样的？
rpc服务是如何找到其他目标服务的？
redis数据结构有哪些？
了解redis数据结构底层实现吗？
跳表是怎样的数据结构
为什么跳表查询复杂度很低
redis应用场景还有哪些？
httprestful的定义规范
常见的http状态码
golang介绍下gmp模型

自我介绍
说一个觉得不错的项目
说一下项目的业务场景
命令的时间差如何保证，命令混乱了怎么办（时间戳记录在服务器可以吗？）
最近在学习什么？
你个人最近感兴趣的点是什么？
docker是解决什么问题？
k8s是解决什么问题？
为什么现在考虑换工作
你想找什么样新的工作？
下一份工作看重什么？
如果说你现在定一个目标三到五年之后想要成为什么样子？
技术和业务方面的要求是什么？
如果让你选择只做技术和只做业务你选择哪个？

网易
自我介绍
有挑战性的项目介绍下
项目优化点说一下
tcp和udp有什么区别，在基础时间和传输层有什么区别
http和tcp有什么区别
用操作系统接口写过网络接口客户端
linux一般常用哪些命令
用netstat看tcp连接的时候有关注过time_wait和close_wait吗？
fork的底层实现方式
redis如何实现事务
复杂一点的条件，比如说判断一个数字大于多少如何实现事务？
如果要从redis里面删除大量的数据要怎么做？
list里面有大量数据，删除大量数据要注意什么
go语言的时候垃圾回收，写代码的时候如何减少小对象分配
string和byte数组有什么区别？
channel有缓冲和无缓冲在使用上有什么区别？
关闭channel有什么作用？
如果一个包要依赖另一个包，这个时候如何写单元测试
知道浮点数在机器上面怎么存储的
用go实现一个协程池，大概用什么实现
lru如何实现

反问：
这是交叉面试吗？
传媒部这边主要负责网易那块儿业务
技术部这边是往go这边切吗？
往go这边切的原因是什么？

百度
自我介绍
详细说下公司里面大的系统遇到的技术难点
消息转发用的什么技术
线上流量多大？
为什么不用一些更稳定的消息队列
go里面为什么需要多协程？
知道processor大小是多少吗？
goroutine为什么会存在，为什么不使用线程？
算法：二维矩阵顺时针原地旋转90度
算法：找出字符串中不包含重复子串的最大长度
redis的存储结构？
redis单线程为什么快？
k8s里面调度的关键步骤

猿辅导
自我介绍
说一下代表你技术能力的项目
你在项目里面的职责是什么？
cicddevops做了什么说一下
redis这边做了什么？
个人对mysql和redis细节了解吗？
redis的string是怎么存储的？
了解过redis的存储方式吗？
系统日志监控怎么做的？
已经上了k8s为什么不用推荐的开源体系？
有没有什么我没有问到你想说的技术点
算法：实现lru，不考虑线程安全，可以使用所有标准库
解释下你写的算法
算法：两个数组，求两个数组的交集
为什么map是O(1)的时间复杂度
实现map的方法除了哈希还有哪些？

高德
自我介绍
选一个比较熟悉的项目讲讲
筛选日志的时候，日志格式是不一样的，你们是如何处理的？
处理日志的时候如果日志量比较大会堆积吗？怎么处理的？
日志落盘到机器上，是如何采集的？
采集服务有问题的话可能会影响报警的及时性吗？
处理日志的时候如果发现突然量变大，该如何扩容让以前堆积的日志可以消耗掉？
调研的正则库内部是怎么实现的？
go里面比较成熟的日志框架了解过没有
redis发布订阅怎么实现的？你自己要怎么实现？
redis高可用怎么做？
了解redis主从复制机制吗？
分布式锁有哪些实现方式
redis的setnx底层怎么实现的？
go协程线程进程区别
详细讲下gmp模型
了解的gc算法有哪些？
go的gc原理了解吗？
go的init函数是什么时候执行的？
多个init函数执行顺序能保证吗？
gin框架的路由是怎么处理的？
mysql索引结构
B+树和B树有什么区别
快排

新浪
自我介绍
挑一个项目介绍下亮点和难点
说下websocket是哪一层协议？
osit层
常见http状态码
各种项目问题
进程阻塞怎么处理？就是进程完全不运行了，但是pid还在
CICD主要做了什么？
用火焰图的优势？
cgo了解过引入的风险点吗？
为什么不要频繁创建和停止goroutine
channel底层是用什么实现的？
数据库加密算法是怎么设计的？设计这种东西通用规范是怎么设计的？
在第一个公司为什么离开了
时间同步问题？
ntp协议

小米
自我介绍
算法：二分查找
sql索引优化问题
mysql数据库引擎
tcp三次握手四次挥手
项目用redis的原因
go的切片扩容机制
linux里面线程和进程的区别
go使用中遇到的问题
一个update语句的执行过程
websocket请求头
消息队列这些用过吗？
微服务注册发现说一下
说一下从浏览器按下一个搜索的完整过程
gomap的底层实现
说一下同步阻塞和异步非阻塞
go的profile工具？


字节
自我介绍
forrange坑输出
gmp模型
遇到过什么语法问题
对比下node和go
为什么用redis没有用成熟的kafka这些消息队列
redis的基础数据结构和底层实现
网关层限流，限流策略
消息重试，消息幂等问题
实现一个Promise.all
go实现一个并发限制爬虫

挑一个比较突出的技术成就聊一下
websocket的稳定性是如何做的？
海外机器的延迟如何保证
为什么会选用websocket？
websocket兼容性是如何做的？
兼容性如何保证的？
如果现在选型的话会如何选？
能对比一下websocket、长连接、EventSource的优缺点吗
在前端如何处理websocket兼容性问题？
如何去设计兼容这一层？
你对前端这边了解到什么程度？
js原型链原型继承了解吗？
js变量提升作用域问题？
算法题：n*n的矩阵，按圈顺时针打印这个矩阵
写完之后做一些testcase，把需要的case都列一下

好未来
自我介绍
说一个项目的架构
go主要用搜框架
对go的中间件和工作机制有了解吗？
对数据库操作有什么了解吗
对连接池有了解吗？
go的垃圾回收机制
gmp模型
go的sync.Map了解吗
channel主要做什么事情
数据库这块儿mysql用的多吗？
存储引擎了解哪些？
对mysql索引了解哪些
redis的过期策略是什么？
微服务这边用到哪些？
算法：两个无序数组找到他们的交集
算法：分层遍历二叉树
常见的http状态码
tcp和udp区别
tcp三次握手四次挥手
业务迭代遇到过晚上上线的事情吗？
上线的时候业务中断有什么方式去规避吗？
k8spod切换策略

自我介绍
做过的项目说一下
怎么检查go问题
未来技术方向怎么选
gmp模型
切片的底层实现
go和node的差别

自我介绍
k8s如何找到一个节点上的所有pod
如何通过goclient写代码获取
日志监控怎么做的？
dockerfilecmd和entrypoint有什么区别
项目里面有自己独立负责的吗？
说下在线教室
如何保证连接的均衡？不至于所有连接连到一个地方？
调研的ocr识别是做什么？
做个题，看下这个这么写有什么问题
写个channel相关的题，并发模型，爬虫url，控制并发量
context包内部如何实现的？

自我介绍
你在第一家公司服务的用户是谁？
素质教育还是应试教育？
你在里面用技术解决什么问题？
这里面有什么你觉得做得比较好的项目？
视频用的什么服务？
信令用wss还是ws？
调度哪个用户连接哪个机器？
如果业务量大，如何让客户端能够均衡的连接服务器
wss是基于tcp的，tcp有个半连接队列，有没有遇到发了信令但是服务器没收到的情况？
自习和用户增长？
题拍拍主要做拍搜服务的，题拍拍主要做增长，后面会做微服务架构k8s等
考虑问题的时候从用户角度去考虑？用户是谁？为谁服务？
自我介绍
devops是怎么做的？
会保留一些tag、镜像之类的东西吗？
服务的属性配置用的什么？
docker是怎么做隔离的？
docker和宿主机有几种网络通信方式
k8s和pod什么关系？
k8s定义了什么标准来操纵docker
k8s有几种service类型
报警这边怎么做的？
为什么没有用ELK
go怎么实现封装继承多态
为什么go的变量申请类型是为了什么？
</pre>