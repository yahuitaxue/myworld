---
title: MySQL优化
author: Yahui
layout: mysql
category: MySQL
---

书名：《---》

<pre style="text-align: left;">

主要就是围绕这两个来的。

SHOW VARIABLES;

SHOW STATUS;

<h1>以下摘自网络</h1>
用 status信息对mysql进行具体的优化。

mysql> show global status;

　　可以列出mysql服务器运行各种状态值，另外，查询mysql服务器配置信息语句：

mysql> show variables;

一、慢查询

mysql> show variables like 'slow%';
+------------------+-------+
| variable_name　　　　 | value |
+------------------+-------+
| log_slow_queries | on　　　　 |
| slow_launch_time | 2　　　　　 |
+------------------+-------+

mysql> show global status like 'slow%';
+---------------------+-------+
| variable_name　　　　　　　 | value |
+---------------------+-------+
| slow_launch_threads | 0　　　　　 |
| slow_queries　　　　　　　　 | 4148 |
+---------------------+-------+ 

配 置中打开了记录慢查询，执行时间超过2秒的即为慢查询，系统显示有4148个慢查询，你可以分析慢查询日志，找出有问题的sql语句，慢查询时间不宜设置 过长，否则意义不大，最好在5秒以内，如果你需要微秒级别的慢查询，可以考虑给mysql打补丁：http://www.percona.com /docs/wiki/release:start，记得找对应的版本。

打开慢查询日志可能会对系统性能有一点点影响，如果你的mysql是主－从结构，可以考虑打开其中一台从服务器的慢查询日志，这样既可以监控慢查询，对系统性能影响又小。

二、连接数

经 常会遇见”mysql: error 1040: too many connections”的情况，一种是访问量确实很高，mysql服务器抗不住，这个时候就要考虑增加从服务器分散读压力，另外一种情况是mysql配 置文件中max_connections值过小：

mysql> show variables like 'max_connections';
+-----------------+-------+
| variable_name　　　 | value |
+-----------------+-------+
| max_connections | 256　　 |
+-----------------+-------+

这台mysql服务器最大连接数是256，然后查询一下服务器响应的最大连接数：

mysql> show global status like 'max_used_connections';

mysql服务器过去的最大连接数是245，没有达到服务器连接数上限256，应该没有出现1040错误，比较理想的设置是

max_used_connections / max_connections * 100% ≈ 85%

最大连接数占上限连接数的85％左右，如果发现比例在10%以下，mysql服务器连接数上限设置的过高了。

三、key_buffer_size

key_buffer_size是对myisam表性能影响最大的一个参数，下面一台以myisam为主要存储引擎服务器的配置：

mysql> show variables like 'key_buffer_size';

+-----------------+------------+
| variable_name　　　 | value　　　　　　 |
+-----------------+------------+
| key_buffer_size | 536870912 |
+-----------------+------------+

分配了512mb内存给key_buffer_size，我们再看一下key_buffer_size的使用情况：

mysql> show global status like 'key_read%';
+------------------------+-------------+
| variable_name　　　　　　　　　　 | value　　　　　　　 |
+------------------------+-------------+
| key_read_requests　　　　　　 | 27813678764 |
| key_reads　　　　　　　　　　　　　　 | 6798830　　　　　 |
+------------------------+-------------+

　　一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：

key_cache_miss_rate ＝ key_reads / key_read_requests * 100%

比 如上面的数据，key_cache_miss_rate为0.0244%，4000个索引读取请求才有一个直接读硬盘，已经很bt 了，key_cache_miss_rate在0.1%以下都很好（每1000个请求有一个直接读硬盘），如果key_cache_miss_rate在 0.01%以下的话，key_buffer_size分配的过多，可以适当减少。

mysql服务器还提供了key_blocks_*参数：

mysql> show global status like 'key_blocks_u%';
+------------------------+-------------+
| variable_name　　　　　　　　　　 | value　　　　　　　 |
+------------------------+-------------+
| key_blocks_unused　　　　　　 | 0　　　　　　　　　　　 |
| key_blocks_used　　　　　　　　 | 413543　　　　　　 |
+------------------------+-------------+

key_blocks_unused 表示未使用的缓存簇(blocks)数，key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么 增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置：

key_blocks_used / (key_blocks_unused + key_blocks_used) * 100% ≈ 80%

四、临时表

mysql> show global status like 'created_tmp%';
+-------------------------+---------+
| variable_name　　　　　　　　　　　 | value　　　 |
+-------------------------+---------+
| created_tmp_disk_tables | 21197　　　 |
| created_tmp_files　　　　　　　 | 58　　　　　　 |
| created_tmp_tables　　　　　　 | 1771587 |
+-------------------------+---------+

每次创建临时表，created_tmp_tables增加，如果是在磁盘上创建临时表，created_tmp_disk_tables也增加,created_tmp_files表示mysql服务创建的临时文件文件数，比较理想的配置是：

　 　created_tmp_disk_tables / created_tmp_tables * 100% <= 25%比如上面的服务器created_tmp_disk_tables / created_tmp_tables * 100% ＝ 1.20%，应该相当好了。我们再看一下mysql服务器对临时表的配置：

mysql> show variables where variable_name in ('tmp_table_size', 'max_heap_table_size');
+---------------------+-----------+
| variable_name　　　　　　　 | value　　　　　 |
+---------------------+-----------+
| max_heap_table_size | 268435456 |
| tmp_table_size　　　　　　 | 536870912 |
+---------------------+-----------+

只有256mb以下的临时表才能全部放内存，超过的就会用到硬盘临时表。

五、open table情况

mysql> show global status like 'open%tables%';
+---------------+-------+
| variable_name | value |
+---------------+-------+
| open_tables　　　 | 919　　　 |
| opened_tables | 1951　 |
+---------------+-------+

open_tables 表示打开表的数量，opened_tables表示打开过的表数量，如果opened_tables数量过大，说明配置中 table_cache(5.1.3之后这个值叫做table_open_cache)值可能太小，我们查询一下服务器table_cache值：

mysql> show variables like 'table_cache';
+---------------+-------+
| variable_name | value |
+---------------+-------+
| table_cache　　　 | 2048　 |
+---------------+-------+

比较合适的值为：

open_tables / opened_tables * 100% >= 85%

open_tables / table_cache * 100% <= 95%

六、进程使用情况

mysql> show global status like 'thread%';
+-------------------+-------+
| variable_name　　　　　 | value |
+-------------------+-------+
| threads_cached　　　　 | 46　　　　 |
| threads_connected | 2　　　　　 |
| threads_created　　　 | 570　　　 |
| threads_running　　　 | 1　　　　　 |
+-------------------+-------+

如 果我们在mysql服务器配置文件中设置了thread_cache_size，当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户 而不是销毁（前提是缓存数未达上限）。threads_created表示创建过的线程数，如果发现threads_created值过大的话，表明 mysql服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值，查询服务器 thread_cache_size配置：

mysql> show variables like 'thread_cache_size';
+-------------------+-------+
| variable_name　　　　　 | value |
+-------------------+-------+
| thread_cache_size | 64　　　　 |
+-------------------+-------+

示例中的服务器还是挺健康的。

七、查询缓存(query cache)

mysql> show global status like 'qcache%';
+-------------------------+-----------+
| variable_name　　　　　　　　　　　 | value　　　　　 |
+-------------------------+-----------+
| qcache_free_blocks　　　　　　 | 22756　　　　　 |
| qcache_free_memory　　　　　　 | 76764704　 |
| qcache_hits　　　　　　　　　　　　　 | 213028692 |
| qcache_inserts　　　　　　　　　　 | 208894227 |
| qcache_lowmem_prunes　　　　 | 4010916　　　 |
| qcache_not_cached　　　　　　　 | 13385031　 |
| qcache_queries_in_cache | 43560　　　　　 |
| qcache_total_blocks　　　　　 | 111212　　　　 |
+-------------------------+-----------+

mysql查询缓存变量解释：

qcache_free_blocks：缓存中相邻内存块的个数。数目大说明可能有碎片。flush query cache会对缓存中的碎片进行整理，从而得到一个空闲块。

qcache_free_memory：缓存中的空闲内存。

qcache_hits：每次查询在缓存中命中时就增大

qcache_inserts：每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。

qcache_lowmem_prunes： 缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存 很少。（上面的 free_blocks和free_memory可以告诉您属于哪种情况）

qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是 select 语句或者用了now()之类的函数。

qcache_queries_in_cache：当前缓存的查询（和响应）的数量。

qcache_total_blocks：缓存中块的数量。

我们再查询一下服务器关于query_cache的配置：

mysql> show variables like 'query_cache%';
+------------------------------+-----------+
| variable_name　　　　　　　　　　　　　　　　 | value　　　　　 |
+------------------------------+-----------+
| query_cache_limit　　　　　　　　　　　　 | 2097152　　　 |
| query_cache_min_res_unit　　　　　 | 4096　　　　　　 |
| query_cache_size　　　　　　　　　　　　　 | 203423744 |
| query_cache_type　　　　　　　　　　　　　 | on　　　　　　　　 |
| query_cache_wlock_invalidate | off　　　　　　　 |
+------------------------------+-----------+

各字段的解释：

query_cache_limit：超过此大小的查询将不缓存

query_cache_min_res_unit：缓存块的最小大小

query_cache_size：查询缓存大小

query_cache_type：缓存类型，决定缓存什么样的查询，示例中表示不缓存 select sql_no_cache 查询

query_cache_wlock_invalidate：当有其他客户端正在对myisam表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。

query_cache_min_res_unit的配置是一柄”双刃剑”，默认是4kb，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。

查询缓存碎片率 = qcache_free_blocks / qcache_total_blocks * 100%

如果查询缓存碎片率超过20%，可以用flush query cache整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。

查询缓存利用率 = (query_cache_size - qcache_free_memory) / query_cache_size * 100%

查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且qcache_lowmem_prunes > 50的话说明query_cache_size可能有点小，要不就是碎片太多。

查询缓存命中率 = (qcache_hits - qcache_inserts) / qcache_hits * 100%

示例服务器 查询缓存碎片率 ＝ 20.46％，查询缓存利用率 ＝ 62.26％，查询缓存命中率 ＝ 1.94％，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。

八、排序使用情况

mysql> show global status like 'sort%';
+-------------------+------------+
| variable_name　　　　　 | value　　　　　　 |
+-------------------+------------+
| sort_merge_passes | 29　　　　　　　　　 |
| sort_range　　　　　　　　 | 37432840　　　 |
| sort_rows　　　　　　　　　 | 9178691532 |
| sort_scan　　　　　　　　　 | 1860569　　　　 |
+-------------------+------------+

sort_merge_passes 包括两步。mysql 首先会尝试在内存中做排序，使用的内存大小由系统变量 sort_buffer_size 决定，如果它的大小不够把所有的记录都读到内存中，mysql 就会把每次在内存中排序的结果存到临时文件中，等 mysql 找到所有记录之后，再把临时文件中的记录做一次排序。这再次排序就会增加 sort_merge_passes。实际上，mysql 会用另一个临时文件来存再次排序的结果，所以通常会看到 sort_merge_passes 增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢，增加 sort_buffer_size 会减少 sort_merge_passes 和 创建临时文件的次数。但盲目的增加 sort_buffer_size 并不一定能提高速度，见 how fast can you sort data with mysql?（引自http://qroom.blogspot.com/2007/09/mysql-select-sort.html，貌似被墙）

另外，增加read_rnd_buffer_size(3.2.3是record_rnd_buffer_size)的值对排序的操作也有一点的好处，参见：http://www.mysqlperformanceblog.com/2007/07/24/what-exactly-is-read_rnd_buffer_size/

九、文件打开数(open_files)

mysql> show global status like 'open_files';
+---------------+-------+
| variable_name | value |
+---------------+-------+
| open_files　　　　 | 1410　 |
+---------------+-------+

mysql> show variables like 'open_files_limit';
+------------------+-------+
| variable_name　　　　 | value |
+------------------+-------+
| open_files_limit | 4590　 |
+------------------+-------+

比较合适的设置：open_files / open_files_limit * 100% <= 75％

十、表锁情况

mysql> show global status like 'table_locks%';
+-----------------------+-----------+
| variable_name　　　　　　　　　 | value　　　　　 |
+-----------------------+-----------+
| table_locks_immediate | 490206328 |
| table_locks_waited　　　　 | 2084912　　　 |
+-----------------------+-----------+

　 　table_locks_immediate表示立即释放表锁数，table_locks_waited表示需要等待的表锁数，如果 table_locks_immediate / table_locks_waited > 5000，最好采用innodb引擎，因为innodb是行锁而myisam是表锁，对于高并发写入的应用innodb效果会好些。示例中的服务器 table_locks_immediate / table_locks_waited ＝ 235，myisam就足够了。

十一、表扫描情况

mysql> show global status like 'handler_read%';
+-----------------------+-------------+
| variable_name　　　　　　　　　 | value　　　　　　　 |
+-----------------------+-------------+
| handler_read_first　　　　 | 5803750　　　　　 |
| handler_read_key　　　　　　 | 6049319850　 |
| handler_read_next　　　　　 | 94440908210 |
| handler_read_prev　　　　　 | 34822001724 |
| handler_read_rnd　　　　　　 | 405482605　　　 |
| handler_read_rnd_next | 18912877839 |
+-----------------------+-------------+

各字段解释参见http://hi.baidu.com/thinkinginlamp/blog/item/31690cd7c4bc5cdaa144df9c.html，调出服务器完成的查询请求次数：

mysql> show global status like 'com_select';
+---------------+-----------+
| variable_name | value　　　　　 |
+---------------+-----------+
| com_select　　　　 | 222693559 |
+---------------+-----------+

计算表扫描率：

表扫描率 ＝ handler_read_rnd_next / com_select

如果表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，增加read_buffer_size值会有一些好处，但最好不要超过8mb。


1.原子性是指事务的原子性操作，对数据的修改要么全部执行成功，要么全部失败，实现事务的原子性，是基于日志的Redo/Undo机制。
2.一致性是指执行事务前后的状态要一致，可以理解为数据一致性,使数据库从一个一致性状态变到另一个一致性状态。
3.隔离性侧重指事务之间相互隔离，不受影响，这个与事务设置的隔离级别有密切的关系。
4.持久性则是指在一个事务提交后，这个事务的状态会被持久化到数据库中，也就是事务提交，对数据的新增、更新将会持久化到数据库中。

Redo/Undo机制
    Redo/Undo机制比较简单，它们将所有对数据的更新操作都写到日志中。
    Redo log用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据；Undo log是用来记录数据更新前的值，保证数据更新失败能够回滚。
    假如数据库在执行的过程中，不小心崩了，可以通过该日志的方式，回滚之前已经执行成功的操作，实现事务的一致性。

mysql 四种隔离级别
一、将A的隔离级别设置为read uncommitted(读未提交)
    set session transaction isolation level read uncommitted;
    查看隔离级别是否设置成功
    select @@transaction_isolation （mysql版本 8.0 以后）
    select @@tx_isolation （mysql版本 8.0 之前）
    查看mysql版本 
    > status
    A：启动事务，此时数据为初始状态
     start transaction;
    B：启动事务，更新数据，但不提交
     start transaction;
    A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”
    B：回滚事务
    rollback;
    A：再次读数据，发现数据变回初始状态
    经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。
二、将客户端A的事务隔离级别设置为read committed(读已提交)(一般是对于update的操作)(大多数数据库系统的默认隔离级别)
    set session transaction isolation level read committed;
    A：启动事务，此时数据为初始状态
    B：启动事务，更新数据，但不提交
    A：再次读数据，发现数据未被修改
    B：提交事务
    A：再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”
    经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。

三、将A的隔离级别设置为repeatable read(可重复读)(一般是针对inser操作)(MySQL的默认事务隔离级别)
    A：启动事务，此时数据为初始状态
    B：启动事务，更新数据，但不提交
    A：再次读取数据，发现数据未被修改
    B：提交事务
    A：再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了
    B：插入一条新的数据，并提交
    A：再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”
    A：提交本次事务，再次读取数据，发现读取正常了
    由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。但该事务不要求与其他事务可串行化。例如，当一个事务可以找到由一个已提交事务更新的记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)。像以上的实验，就没有出现数据幻读的问题

四、将A的隔离级别设置为可串行化(Serializable)
    A：启动事务，此时数据为初始状态
    B：发现B此时进入了等待状态，原因是因为A的事务尚未提交，只能等待（此时，B可能会发生等待超时）
    A：提交事务
    B：发现插入成功
    serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。
    
注:四大等级从上到下，隔离的效果是逐渐增强，但是性能却是越来越差
</pre>