---
title: LeeCode心得
author: Yahui
layout: Other
category: Other
---

书名:《-》

<pre style="text-align: left;">
分治算法
	通常采用递归的形式,将问题分解成若干个子问题,然后再得到原问题,是一个自顶向下的过程(快速排序)
贪心算法
	并不一定是最优解,在针对问题时,总是做出当前最好的选择,也就是局部最优解(最短路径)
回溯算法
	类似穷举法,当发现不满足求解时,就回溯返回,尝试其他路径(八皇后)
	解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：
		1、路径：也就是已经做出的选择。
		2、选择列表：也就是你当前可以做的选择。
		3、结束条件：也就是到达决策树底层，无法再做选择的条件。
	如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。
	代码方面，回溯算法的框架：
		result = []
		def backtrack(路径, 选择列表):
		    if 满足结束条件:
		        result.add(路径)
		        return

		    for 选择 in 选择列表:
		        做选择
		        backtrack(路径, 选择列表)
		        撤销选择
		其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。
动态规划算法
	将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解,是一个自底向上的过程(比如斐波那契,青蛙跳)
	1.动态规划法试图只解决每个子问题一次
	2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。
1.一维数组查重
	1.循环比对当前元素与之后的每一个元素
	2.使用不能重复的数据类型(map)
	3.类似Redis的bitmap(与2类似,未实现)
2.二维数组查找
	1.二维数组找出排序规律(从四个角发现类似树的形式)
3.字符串替换
	1.自带函数
	2.源自自带函数(通过字符串的len与)
4.倒序打印链表
	1.回溯也是一种思路
	2.循环将值放入新的链表中
5.二叉树的先序/中序排列还原二叉树
	1.根据性质,还原生成过程,并进行归并
6.斐波那契数列
	1.递归速度太慢，可以考虑for循环
	2.如果考虑超出int限制，可在计算和的时候就取模，这样与最后结果取模是一个效果
7.青蛙跳台阶
	1.转化思路，与斐波那契是同样的逻辑（可用二叉树分解，更容易理解）
8.有序数组
	1.有序就要想到二分查找法
9.割绳子
	1.不用递归的想法,首先从低位开始,高位基于低位的值来处理,比如两个for循环嵌套,从低位开始循环依次存入
	2.底层原理就是让有更多的3进行相乘
10.链表引用
	1.引用的变量变化没有问题,只有当改变了引用的值,才会影响变量的值
	2.单向链表删除指定节点，可将下个节点赋值给当前节点，然后删除下个节点，这样也相当于删除指定节点
	3.反转链表，可以使用pre，cur，nex来标识
		每循环一个节点，就改变节点next为上个节点，循环完毕，指针反转完毕
		pre, cur = *head
		while(cur != NULL) {
			nex = cur->next
			cur->next = pre
			pre = cur
			cur = nex
		}
		return pre
	4.倒叙输出链表
		1.可以再定义一个链表反向存储，然后再输出
		2.可以使用递归的形式进行输出
11.二叉树层序遍历
	根据性质，每次记下下层的所有节点，然后循环记下的所有节点再次记下节点的节点...
12.海量数字查找中位数
	1.将数字转为二进制,从高到低位进行01区分,依次下去,直至找到中位数
13.字符串
	KMP字符串查找算法
		1.将目标字符串的所有子串计算出公共相同前后缀长度,标记为数组next
		2.将next数组头部增加-1(后面所有向后移动一位)
		3.进行字符串匹配,如果遇到不一致的,则找到对应next数组的值,并将目标字符串下标为该值的字符移动到匹配的位置,进行重新匹配
		(其实就是已经匹配过的,如果后面有重复的就不用从头进行匹配)
注:动态规划类问题的思路步骤
	1.暴力的深度优先搜索
	2.画出/思考出问题和子问题的关系，看有没有重复子问题
	3.如果有重复子问题，考虑增加记忆化的数据结构
	4.据此，思考动态规划的状态和递推方程
	5.实现动态规划
注:递归转循环
	1.一般来说，用非递归写递归，都需要用到一个数据结构-栈。
	2.这个好解释，递归的解法是利用了系统中提供的函数栈，非递归我们需要手动创建这么一个数据结构，但是你可能会问的是，这里为什么要用到两个栈？
	3.你可以这样认为，一个栈用来表示函数的运行进度，里面的元素表示此时该函数运行到了第几行代码，另一个栈用来记录函数的传入参数，当然你也可以把这两个栈合成一个栈，里面装的是封装好的对象。
	4.这里为了解释起来清晰直观，就用两个栈。
	5.首先，根据之前的递归解法，我们最开始是把 root 传入 helper 函数，因此这时我们也把 root 加入函数栈，另外一个表示函数进度的栈往里面添加 0，表示当前函数运行到了第 0 行，然后就是 while 循环里面的东西，while 循环一开始我们就获取当前函数的输入参数和进度，然后根据函数的进度去看需要执行哪一段代码，因为有的代码会继续往栈里面添加函数，因此，我们需要提前把函数进度往后移动，你可以对应之前的递归的代码和我标的序号，你可以看到，整个 if-else if…else 部分就表示了之前的递归函数中的代码，只不过这里我们需要根据函数的进度去判断它要执行哪一行。
	6.使用这种方法后，递归转非递归只需要往上套就行，不需要单独分析。
注:二叉树平衡过程
	在root根节点左子树的左子树上插入节点导致破坏平衡,左旋
	在root根节点右子树的右子树上插入节点导致破坏平衡,右旋
	在root根节点左子树的右子树上插入节点导致破坏平衡,根节点的左子树先左旋,根节点再右旋
	在root根节点右子树的左子树上插入节点导致破坏平衡,根节点的左子树先右旋,根节点再左旋
</pre>