---
title: Go语言Web开发
author: Yahui
layout: go
category: Go
---

书名：《-》

<pre style="text-align: left;">
	1.服务器搭建:
		1.利用系统默认
			// 处理器必须的参数
			func handler(w http.ResponseWriter, r *http.Request)  {
				_, _ = fmt.Fprintln(w, "hello,world", r.URL.Path)
			}

			func main()  {
				// 注册一个处理器函数handler和对应的模式"/",这样就是给下面的多路复用器提供路由,这样就确定请求地址是什么,处理器是哪个
				http.HandleFunc("/", handler) // 如果使用的是Handle方法,那么后面的handler必须实现ServeHttp方法,而HandleFunc默认是已经实现
				// 监听TCP地址addr,并且会使用handler参数调用Serve函数处理接收到的连接(网络地址参数为空,则默认是80端口, 处理器参数为nil默认是DefaultServeMux多路复用器)
				_ = http.ListenAndServe(":8080", nil)
			}
		2.自定义模式
			func (myHandler *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request)  {
				// 可以查看请求头里的内容
				fmt.Println(r.Header)
				// 获取指定头部信息
				fmt.Println(r.Header.Get("Accept-Encoding"))
			}

			func main()  {
				my := myHandler{}
				http.Handle("/", &my) // 与HandleFunc的区别:HandleFunc的第二个参数是已经实现了(w http.ResponseWriter, r *http.Request)的方法,Handle的第二个参数是一个处理器
				server := http.Server{
					Addr: ":8080",
					Handler: &my,
					ReadHeaderTimeout: time.Second,
				}
				_ = server.ListenAndServe()
			}
		3.获取请求参数
			1.GET请求:
				func handler(w http.ResponseWriter, r *http.Request)  {
					fmt.Println(r.URL.Query().Get("abc"))
				}
			2.POST请求:
				len := r.ContentLength
				body := make([]byte, len)
				r.Body.Read(body)
				fmt.Println(string(body))

				err := r.ParseForm()
				// 可以获取URL及表单中的所有参数(当然,也可以直接调用r.FormValue("name"),省去了上面r.ParseForm())
				fmt.Println(r.Form.Get("name"))
				// 只可以获取表单中的参数(当然,也可以直接调用r.PostFormValue("name"),省去了上面r.ParseForm())
				fmt.Println(r.PostForm.Get("name"))
			3.提示客户端
				func handler(w http.ResponseWriter, r *http.Request)  {
					// 给客户端提示
					w.Write([]byte("upload success"))
					// 设置客户端相应的参数
					w.Header().Set("content-type", "application/html")
					a := User{
						Name: "haha",
						Age: 100,
					}
					j, _ := json.Marshal(a)
					_, _ = w.Write(j)
					// 也可以修改响应的编码
					w.WriteHeader(404)
				}
	2.数据库操作
		1.插入/修改/删除
			insertSqlStr := "insert into 表明(字段1,字段2,字段3) values(?,?,?)"
			// 如果使用预编译,则Exec需要注意
			inStmt, err2 := Db.Prepare(insertSqlStr)
			_, err3 := inStmt.Exec("1", 2, 3)
			// 如果不使用预编译,则Exec需要注意
			_, err3 := Db.Exec(insertSqlStr, "1", 2, 3)
		2.查询(一条)
			cateTemp := &Cate{}
			re := Db.QueryRow(selectSqlStr)
			err := re.Scan(&cateTemp.id, &cateTemp.filestr, &cateTemp.add_time, &cateTemp.siteroot)
			if err != nil {
				fmt.Println(err)
			}
			fmt.Println(cateTemp)
		2.查询(多条)
			re, err5 := Db.Query(selectSqlStr)
			if err5 != nil {
				fmt.Println(err5)
			}
			cate := make([]*Cate, 0)
			for re.Next() {
				cateTemp := &Cate{}
				err6 := re.Scan(&cateTemp.id, &cateTemp.filestr, &cateTemp.add_time, &cateTemp.siteroot)
				if err6 != nil {
					fmt.Println(err6)
				}
				cate = append(cate, cateTemp)
			}
			for _, v := range cate{
				fmt.Println(v)
			}
	3.加载模板引擎
		.go文件
		func handler(w http.ResponseWriter, r *http.Request)  {
			t, _ := template.ParseFiles("./index.html")
			_ = t.Execute(w, "传递的内容")
		}
		// 加载多个文件,选择其中的一个渲染
			t:= template.Must(template.ParseFiles("./index.html", "./index2.html"))
			_ = t.ExecuteTemplate(w, "index2.html", "111")
		.html文件
			内容:{{.}} // 此处的.就是传过来的"传递的内容"
</pre>