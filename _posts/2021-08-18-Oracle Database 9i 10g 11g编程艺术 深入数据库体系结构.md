---
title: Oracle Database 9i 10g 11g编程艺术 深入数据库体系结构
author: Yahui
layout: sql
category: SQL
---

书名:《Oracle Database 9i 10g 11g编程艺术 深入数据库体系结构》

<pre style="text-align: left;">
	----------------------------------以下引自(动力节点Oracle入门教程)-----------------------------------
	PL/SQL:
		1.Oracle数据库对SQL语句的扩展.在普通SQL语句的使用上增加了编程语言的特点,所以PL/SQL把数据操作和查询语句组织在PL/SQL代码的过程性单元中,通过逻辑判断、循环等操作实现复杂的功能或者计算.
		2.声明部分(用declare开头),执行部分(以 begin开头)和异常处理部分(以exception开头),其中执行部分是必须的,其他两个部分可选.
			在begin部分可以使用declare部分声明的变量
			(可以进行嵌套)
			DECLARE
			BEGIN
			EXCEPTION
				DECLARE
				BEGIN
				EXCEPTION
				END;
			END;
		3.存储过程和PLSQL有什么区别？
			PLSQL只能调用一次，而存储过程可以存放在数据库服务器中，我们可以通过存储过程名多次调用。
		4.存储过程参数问题
			IN类型:传递给子程序,参数可以是常量,表达式,或者初始化的变量
			OUT类型:返回到调用环境,参数未初始化的变量,必须是一个变量
			IN-OUT类型:传递给子程序返回到调用环境,参数为初始化的变量,必须是一个变量
		5.触发器
			CREATE OR REPLACE TRIGGER 触发器名称
				-- 也可以多个比如:INSERT OR UPDATE
				BEFORE INSERT ON 表名
				-- 行级触发器加上下面这句
				FOR EACH ROW
			DECLARE
				-- 声明变量V_ID
				SELECT ID INTO V_ID FROM 表 WHERE 条件
			BEGIN
				-- :NEW.nick_name可以表示新插入的数据nick_name这一字段,对应的还有OLD
				IF()
				THEN
					-- 提示一条用户自定义的错误信息,通过这个信息,终端用户的的操作
					RAISE_APPLICATION_ERROR(20500,'错误提示信息');
				END_IF;
			END;

			DDL触发器语法
				CREATE OR REPLACE TRIGGER 触发器名称
					-- 也可以多个比如:INSERT OR UPDATE
					AFTER LOGON ON 库名
				BEGIN
					-- 可以向日志表存储登录信息
					INSERT INTO ....
				END;
	----------------------------------以上引自(动力节点Oracle入门教程)-----------------------------------
	1.自治事务(PRAGMA AUTONOMOUS_TRANSACTION)
		在Oracle中，一个事务是从执行第一个数据管理语言(DML)语句开始，直到执行一个COMMIT语句，提交保存这个事务，或者执行一个ROLLBACK语句，放弃此次操作结束。
		事务的“要么全部完成，要么都没完成”的本性会使将错误信息记入数据库表中变得很困难，因为当事务失败重新运行时，用来编写日志条目的INSERT语句还未完成。
		针对这种困境，Oracle提供了一种便捷的方法，即自治事务。自治事务从当前事务开始，在其自身的语境中执行。它们能独立地被提交或重新运行，而不影响正在运行的事务。正因为这样，它们成了编写错误日志表格的理想形式。在事务中检测到错误时，您可以在错误日志表格中插入一行并提交它，然后在不丢失这次插入的情况下回滚主事务。
	2.多版本控制
		一个条目放在重做日志中,Oracle会在这里存储足够多的信息来重做或"前滚"事务
			对于插入,这个条目就是插入的行
			对于删除,则是一个消息(要删除的文件X,块Y,行槽Z中的行)
		另一个条目是撤销条目,写至一个undo段,如果事务失败,需要撤销事务外,Oracle还会用它撤销读数据块时对块做出的改变,也就是说会把块回复到查询开始时的状态,这样的话,就能够通过一个锁正确的读取数据,不仅可以得到正确一致的答案,也不会锁定任何数据
		<span class="image featured"><img src="{{ 'assets/images/other/OracleMVCC.jpg' | relative_url }}" alt="" /></span>
	注:
		定义:
			数据库:物理操作系统文件或磁盘的集合,使用Oracle的自动存储管理或RAW分区时,数据库可能不作为操作系统中单独的文件.
			实例:一组Oracle后台进程/线程以及一个共享内存区,这些内存由同一个计算机上运行的线程/进程所共享,这里可以维护易失的,非持久性内容.就算没有磁盘存储,数据库实例也能存在.
		两者关系:
			数据库可以由多个实例装载和打开,而实例可以在任何时间点装载和打开已数据库.实际上,准确的讲,实例在其整个生存期中最多能装载和打开一个数据库.
	3.文件
		实例相关
			1.参数文件(大多.ora文件):Oracle实例在哪里可以找到控制文件,并且制定某些初始化参数,这些参数定义了某种内存结构有多大等的设置.
				1.在集群环境中,为了从使用各个PFILE转换为所有实例都共享的一个公共的SPFILE,需要把各个PFILE合并为如下一个文件
					*.cluster_dabase_instances=2 //集群中所有实例共享的参数设置都是以*.开头
					...
					011G2.instance_number=2 //单个实例特有的参数设置都以实例名为前缀
					...
			2.跟踪文件:服务器进程对某种异常错误条件做出相应时创建的诊断文件,服务器遇到问题时,会生成一个包含大量诊断信息的跟踪文件.
			3.警告文件:与跟踪文件类似,包含期望时间的有关信息,并且通过一个集中式文件,在这个文件中,可以看到数据库的'编年史',包括日志开关;可能出现的内部错误,表空间何时创建,离线及恢复为在线等等.
		数据库文件
			4.数据文件:是数据库的主要文件,其中包括数据表,索引和所有其他的段
			5.临时文件:这些文件用于完成基于磁盘的排序和临时存储
				Oracle使用临时文件存储大规模排序操作和散列操作的中间结果
			6.控制文件:数据文件,临时文件和重做日志文件在哪里,还会支出与文件状态有关的其他元数据.
				一个小文件(64MB左右),包括Oracle需要的其他文件的一个目录,参数文件告知实例控制文件的位置, 控制文件则告知实例数据库和在线重做日志文件的位置.
			7.重做日志文件(redo log):就是事务文件
				1.系统崩溃后的实例恢复
				2.通过备份恢复数据文件之后恢复介质
				3.备用数据库处理
				4.输入到流中,这是一个重做日志挖掘过程,用于实现信息共享
			8.密码文件:通过网络完成管理活动的用户进行认证.
		从10g开始又新增了两个文件
			9.修改跟踪文件:有利于对Oracle数据建立真正的增量备份,修改跟踪文件不一定非得放在闪回恢复区,不过它只与数据库备份和恢复有关,所以我们将在介绍闪回恢复区时再讨论这个文件
			10.闪回日志文件:存储数据库块的前映象,以便完成新增加的FLASHBACK DATABASE命令
				用于将数据库返回(恢复)到该时间点之前的状态
		其他文件
			11.转储文件:由Export(导出)数据库实用程序生成,并由Import(导入)数据库实用程序使用
			12.数据泵文件:Oracle数据泵导出进程生成,并由数据泵导入进程使用,外部表也可以创建和使用这种文件格式
			13.平面文件:这些无格式文件可以在文本编辑器中查看,通常会使用这些文件项数据库中加载数据
	4.段
		表空间中主要的组织结构,占用存储空间的数据库对象,如表,索引,回滚段等.
		1.创建表时,会创建一个表段
		2.创建分区表时,则每个分区都会创建一个段
		3.创建索引时,就会创建一个索引段.
		占用存储空间的每一个对象最后都会存储在一个段中(此外还有回滚段,临时段,聚簇段,索引段等)
	5.区段
		段本身又由一个或多个区段组成.区段是文件找那个一个逻辑上连续分配的空间(磁盘上不一定连续).
	6.块
		区段又进一步由块组成,块时Oracle中最小的空间分配单位.
	7.内存结构
		1.系统全局区(SGA)
			1.Java池:为数据库总运行的JVM分配的一段固定大小的内存.
			2.大池:共享服务器连接使用大池作为会话内存,并执行特性使用大池作为消息缓冲区.
			3.共享池:共享池包括共享游标,存储过程,状态对象,字段缓存和大量其他数据.
			4.流池:Oracle专用内存池,是数据库中的一个数据共享工具.
			5.空池:这个池没有名字,是-块缓冲区,重做日志和固定SGA区专用的内存.
		2.进程全局区(PGA)
			操作系统进程或线程专用的内存,不允许系统中的其他进程或线程访问
		3.用户全局区(UGA)
			与特定的会话相关联,有可能在SGA中,也有可能在PGA中,这取决于是用共享服务器还是用专用服务器来连接数据库.如果用共享服务器就在SGA中分配,如果专用服务器,就在PGA中
		自动PGA内存管理
			1.解决易用性
			2.解决手动分配是一种"以一概全"的方法
			3.内存控制
	8.锁
		1.悲观锁
			使用FOR UPDATE NOWAIT锁定这一行,当然,在另一个会话执行对这一行的UPDATE时,就会挂起,被阻塞
		2.乐观锁(把所有锁定都延迟到即将执行更新之前才做)
			这种锁定在所有环境下都行得通,但是如果执行更新的用户"失败"的可能性会加大,这个用户在工薪数据时,发现数据已经修改过,所以必须从头再来.
			1.通过systimestamp字段类型/获取某个字段的散列值(这种对某个比较长的字段不是很推荐)/带主键或唯一约束INSERT,判断是否修改过来保持数据一致性
		注:(如果向一个表增加一个乐观锁,比较推荐是使用ORA_HASH,毕竟不用新增列就可以实现)
			在工作中,悲观锁工作的会相比好一些(在其他数据库可能并不是这样的),它需要与数据库有一条状态的连接,如客户/服务器连接,因为无法跨连接持有锁,所以正常情况悲观锁不太现实.不过如今大多数应用,建议采用乐观锁控制并发,要在整个事务期间保持连接,这个代价有点大.
		3.阻塞
			1.INSERT阻塞
				带主键或唯一约束的相同插入会出现这个情况
			2.UPDATE/DELETE阻塞(代码中出现丢失更新/就是代码存在BUG问题)
				1.验证自动你查询数据之后数据未被修改
				2.锁住行(防止UPDATE/DELETE被阻塞)
				不论是悲观锁还是乐观锁都可以利用SELECT FOR UPDATE NOWAIT查询来验证行未被修改,悲观锁会在用户有意修改那一刻使用这条语句,乐观锁则在数据库中更新数据时使用这条语句,这样就能解决阻塞与数据完整性问题.
		4.死锁(主要是外键原因)
			1.更新了父表的主键
			2.删除了父表中的一行
		5.锁类型
			1.DML锁:允许并发执行数据修改,可能是特定数据行上的锁,或者是锁定表中所有行的表级锁
				1.TX锁(事务锁)
					事务发起第一个修改时(或通过SELECT FOR UPDATE),会得到一个TX锁,且一直会有这个锁,直到事务提交或者回滚
					(如果数据库有一个传统的基于内存的锁管理器,对一行锁定的过程一般如下)
					1.找到想要锁定的一行
					2.在所管理器中排队(所管理器是串行化)
					3.锁定列表
					4.搜索列表,查看别人是否已经锁了这一行
					5.在列表中创建一个新的条目,表明你已经锁定了这一行
					6.对列表解锁.
					(已经锁定了这一行,提交修改时过程如下)
					1.再次排队
					2.锁住锁的列表
					3.在这个列表中搜索,并释放所有的锁
					4.对列表解锁.
					注:得到的锁越多, 这个操作所花的时间就越多,修改数据前和修改数据后耗费的时间都会增加.
					(Oracle锁定并不是这样的,过程如下)
					1.找到想锁定的那一行的地址
					2.到达那一行
					3.锁定这一行-在这行的位置,而非某个大列表(如果这一行已经锁定,则等待锁主它的事务结束,除非使用了NOWAIT选项)
				2.TM锁(用于确保修改表的内容时,表结构不会改变)
					如果更新了一个表,会得到这个表的一个TM锁,这样防止另一个用户在该表上执行DROP或ALTER命令,另一个用户就会得到一个(resource busy and acquire with NOWAIT specified错误)
			2.DDL锁:保护对象结构定义,总会提交,因为DDL一开始就提交
				在DDl操作中,会自动为对象加一个DDL锁,从而保护这些对象不会被其他会话所修改
				1.排他DDL锁:防止其他会话得到自己的DDL锁或TM锁,也就是在DDL操作期间,可以查询一个表,但是无法以任何方式修改这个表
				2.共享DDL锁:这些锁会保护所引用对象结构,使之不会被其他修改,但是允许修改数据.
				3.可中断解析锁:这些允许一个对象向另外某个对象注册其依赖性,如果在被依赖的对象上执行DDL,Oracle会查看已经对该对象注册了依赖性的对象列表,并使这些对象无效.
			3.内部锁和闩:保护内部数据结构
	9.并发与多版本控制
		多版本控制有一个相当惊喜的连带效果,数据的读取器绝不会被数据的写入器所阻塞,也就是说,写不会阻塞读,这是Oracle与其他数据库之间的一个根本区别,在Oracle中,如果一个查询只是读取信息,那么永远不会被阻塞,也不会与其他会话发生死锁,不可能得到数据库中不存在的答案.
		1.事务隔离级别
			1.脏读:读未提交
			2.不可重复读:T1时间读取某一行,在T2时间重新读取这一行时已经被修改,与幻读比,查询不光能看到已经提交的行,还可以看到新插入的行
			3.幻读:与不可重复读类似,不同之处在于不可重复读主要针对UPDATE与DELETE,而幻读主要针对INSERT
			4.SERIALIZABLE:(使用undo段按事务开始时数据的原样来重建数据,而不是按语句开始时的样子重建)不代表事务有某种串行顺序并且总能得到相同的结果,但其实不能保证事务总按串行方式顺序执行,而是好像是此时数据库汇中只有它一个事务一样.
	10.事务
		注:
			Oracle中不需要用专门的语句来'开始事务',事务会在修改数据的第一条语句处隐式开启(也是得到TX锁的第一条语句),也可以使用SET TRANSACTION或DBMS_TRANSACTION包来显示开始一个事务,这也是与其他许多数据库不同之处.使用COMMIT与ROLLBACK结束一个事务
		1.COMMIT:结束你的事务,并使已做的修改成为永久性的
		2.ROLLBACK:回滚会结束事务,并撤销所有未提交的修改.
		3.SAVEPOINT:在事务中创建一个标记点,一个事务可以有多个事务点
		4.ROLLBACK TO SAVEPOINT:与SAVEPOINT一起使用,可以把事务回滚到标记点,而不必回滚到此标记点之前的任何工作.
		5.SET TRANSACTION:允许设置不同的事务属性,如事务的隔离级别是只读还是可读写,也可以指示事务使用某个特定的undo段(不推荐使用,推荐使用手动和自动undo管理)
		注:
			每条SQL语句执行之后会立即验证其完整性约束,而不是在这个存储过程完成后才检查它,为什么不是再SQL执行期间验证,因为一条语句再执行期间可能会使表中数据不一致,但是完成后最终结果是对的:
			1.create table t (x int unique);
			2.insert into t values (1);
			3.insert into t values (2);
			4.commit
			5.update t set x = x+1;
			这样,如果是在执行期间验证,那么在2执行后就会出现两条x值为2的数据,违反了x unique的属性.
		注:
			在B+树中,不会建立完全为空的索引条目,也就是说,如果所有列都为空,那么索引中不会包含该表中任何行的相应条目.
			如果列上有个不可延迟约束,这个限制就会去除
		注:
			Oracle中,事务总是隐式的,没有'自动提交',除非应用专门实现,都是在必要时才提交,而在此之前不能提交,锁与阻塞等问题并不是决定事务大小的关键,数据完整性才是确定事务大小的根本(与其他数据库有点相反)
		注:
			UPDATE语句正在生成undo信息,只能用一个很小的undo表空间(大小为10M),如果在undo段中回绕,因为undo段要以一种循环方式使用,每次提交时,都允许Oracle覆盖前面生成的undo数据.
		注:
			Oracle会完成所有数据库中的提交,或者都不提交,使用了一个2PC来做到这一点,2PC是一个分布式协议,如果一个修改影响到多个不同的数据库,2PC允许原子性的提交这个修改.
			1.不能在数据库链接上发出COMMIT,也就是说不能发出COMMIT@remote_site,只能从发起事务的那个站点提交
			2.不能在数据库链接上完成DDL,DDL会提交,只能从发起事务的那个站点提交
			3.不能在数据库链接上发出SAVEPOINT,简单说,不能在数据库链接上发出事务控制语句,所有事务控制都由最初打开数据库链接的会话继承得来,对于事务汇总的分布式实例,不能有不同的事务控制.
		自治事务:
			允许你创建一个事务中的事务,它能独立于其父事务提交或回滚,可以挂起当前执行的事务开始一个新事务,完成一些工作,然后提交或回滚,所有这些都不影响当前所执行事务的状态.(使用情况比较少,比如记录错误日志)
	11.数据:
		redo(重做):
		undo(归档):实际就是填满的"旧"在线重做日志文件的副本.
			回滚只是一种逻辑上"将数据库恢复原状态"的操作,数据部并不会完全恢复原状,只是逻辑上相同而已.
		二者协作:
			系统崩溃,在启动时,Oracle会读取重做日志,发现针对这个事务的一些重做日志条目.给定系统的当前状态,利用重做日志文件中对应插入的redo条目,回滚时因为这个事务从未提交,因此会将其回滚,获取刚刚在缓冲区缓存中前滚得到的undo,并将这些undo应用到数据和索引块,使数据和索引块"恢复"为插入前的样子.
			注:
				首先前滚,把系统放到失败点上,然后回滚尚未提交的所有工作,这样会再次同步数据文件,重放已经进行的工作,撤销尚未完成的所有工作.
				如果已经刷新到磁盘上,会把undo信息应用到缓冲区缓存中的数据和索引块上,再对其应用undo,恢复为原来的值,并刷新输出到数据文件.
		commit操作:
			(并不是说事务越大,commit时越耗时,commit通常是一个非常快的操作,因为没有太多的工作去做,不受事务大小的影响)
			开销两个因素
				1.与数据库的往返通信.
				2.提交等待redo写入磁盘.
			commit/rollback之前的操作内容:
				1.SGA中生成了undo块
				2.SGA生成了已修改数据块
				3.SGA中生成了对应前两项缓存redo
				4.前三项花费时间过长,可能某些数据已经刷新输出到磁盘
				5.已经得到所需的全部锁
			commit之后的操作内容:
				1.为事务生成一个SCN(Oracle使用 第一种简单的计时机制,用于保证事务的顺序,并支持失败的恢复,还用于保证数据库中的读一致性和检查点,可以把它看做一个钟摆,每次有人提交时SCN就会增1)
				2.LGWR(写入日志)将余下的缓存重做日志写入磁盘,把SCN记录到在线重做日志文件中(这一步是真正的commit),如果出现这一步,即是已经提交.
				3.释放锁
				4.以一种快速的模式访问并"清理"缓冲区缓存.
		rollback操作:
			(这点与commit不同,回滚的开销很大,因为需要大量的时间去做工作,还需要大量的时间去撤销这些工作)
			rollback之后的操作内容:
				1.撤销已做的所有修改(具体:从undo段读回数据,然后实际上逆向执行前面所做的操作,并将undo条目标记为已用,如果先前插入了一行,rollback会将其删除,如果更新了一行,回滚就会取消更新,如果删除了一行,回滚将把它再次插入)
				2.会话所持有的所有锁都将释放,如果有人在排队等待我们的持有的锁会被唤醒
		临时表:
			1.对永久表的insert生成大量redo,而对临时表几乎没有生成任何redo.对临时表的insert只会生成很少的undo数据,而对于临时表只会为undo数据建立日志.
			2.永久表的update生成的redo大约是临时表更新所生成redo的两倍,因为要保存update的大约一半(就是"前映象"),而对于临时表,不必要保存"后映象".
			3.对delete的undo很大,而对于已经修改块的redo很小,所以对临时表来说delete与对永久表的delete几乎相同.
			注:如果insert语句再临时表上的redo比永久表是哪个还多,那大多是数据库的问题.
	12.数据库表
		1.表类型
			1.堆组织表:普通的标准数据库表(执行create table语句时,默认得到的表类型就是).
			2.索引组织表:按照索引结构索引,数据根据主键有序存储.
				最关键的是要适当的分配数据,哪些数据存储在索引块上,哪些数据存储在溢出段上,如果结构只建立一次,而且要频繁读取,就应该尽可能的把数据放在索引块上,如果频发修改结构,则必须对两方面有所权衡,要么数据放在索引块上,要么频繁的重新组织所以汇总的数据.
			3.索引聚簇表:由一个或多个表组成的组,这些表物理地存储在相同的数据块上,有相同聚簇键值的所有行会相邻的物理存储,聚簇键使用B+树索引建立
				利用聚簇表可以物理的"预联结"数据,使用聚簇可以把多个表上的相关数据存储在同一个数据库块上,聚簇有助于完成总是把数据联结在一起或者访问相关数据集的读密集型操作.
			4.散列聚簇表:与聚簇表类似,但是将键使用散列分部到数据块上.(如果需要频繁的通过键的相等性比较来读取数据,就很合适)
				1.一开始就分配空间,根据HASHKEYS和SIZE来计算,立即分配空间,并完成格式化.
				2.散列聚簇中的HASHKEY数是固定大小的,除非重建聚簇,否则不能改变散列表的大小.
			5.有序散列聚簇表:类似散列聚簇表,根据某个键值散列,而与该键相关的一系列记录以某种有序顺序到达,并按照这种有序顺序处理(客户在订单输入系统中下订单,这些订单会按先进先出的方式获取和处理,这种就比较合适)
			6.嵌套表:维护的父/子关系中的子表.嵌套表的工作类似SCOTT中个EMP和DEPT,EMP是DEPT的子表,因为EMP表有个指向DEPT的外键DEPTNO.
			7.临时表:存储事务期间或会话期间的"草稿"数据,其他会话也看不到当前表.
			8.对象表:基于某种对象类型创建.
			9.外部表:这些表中的数据并不存储在数据库本身中,而是放在数据库之外,放在平常的操作系统文件中.
		2.无论那种类型的表,都有以下基本信息
			1.一个表最多有大致1000列
			2.表的行数几乎是无限的,不过可能会遇到另外某个限制,使得这种"无限"并不实际
			3.表中的列有多少种排列,表就可以有多少个索引
			4.及时在一个数据库汇总也可以有无限多个表,不过同样的道理,实际的限制会使数据库汇总的表在一个河里的范围内.
	13.索引(B表示的是平衡Balance)
		1.B+树索引
			就是"传统"索引
			注:
				1.索引中不存在非唯一条目,在一个非唯一索引中,会把rowid作为一个额外的列追加到键上,使得键唯一.数据首先按索引键值排序,然后按rowid升序排序.
		2.索引组织表(IOT)
			数据要按照主键的顺序存储和排序,对应用来说,表现的与"传统"表并无二致,需要SQL来正确的访问IOT.IOT对信息获取,空间系统和OLAP应用最为有用
		3.B+树聚簇索引
			这是"传统"的稍作变化,用于对聚簇键建立索引,传统的B+树键都指向一行,而B+树聚簇不同,一个聚簇键指向一个块,其中包含与这个聚簇键相关的多行.
		4.降序索引
			允许数据在索引结构中按照"从大到小(降序)"的顺序,而不是按照"从小到大(升序)"的顺序排序.
			注:
				1.有一组列,其中一些按照升序排,另外一些按照降序排,此时这种降序索引就能排上用场,Oracle就不能再使用(列1,列2)上的索引对数据排序,它可以往前读到按列1降序的数据,但现在还需要"继续读"来按列2升序排序的书序,此时Oracle的做法就是把所有的行收集起来,然后排序.但是现在如果使用降序索引,这样最后并没有额外的排序步骤.
		5.反向键索引
			这也是B+树,只不过键中的字节会"翻转",利用反向键索引, 如果索引中填充的是递增的值,索引条目在索引中可以得到更均匀的分部.例如:987500,987501,987502......这些是单调递增的,如果使用一个传统的B+树索引,这些值就可能在同一个右侧块上,利用反向键,就变成005789,105789,205789,这样索引的插入就会分布到多个块上
			注:
				1.能用常规索引的地方不一定能用反向键索引,比如where x>5这样,就不能使用X上的反向键索引,但是如果是串联索引(在(X,Y)上),则可以使用反向键索引,因为Oracle是存储的其实是(REVERSE(X) || REVERSE(Y))就可以使用where x=1
		6.位图索引
			通常索引条目是一对一的关系,一个索引条目就指向一行,而在位图索引中,一个索引条目则使用一个位图同时指向多行,位图索引适用于高度重复而且通常只读的数据(比如在100万行表中,某个字段只有几个值可以取)这样就很适合位图索引
			注:
				1.用一个所以键条目存储指向多行的指针,这与B+树结构不同,在B+树结构中,索引键与表中的行存在着对应关系,在位图索引中可能很少的索引条目,每个索引条目指向多行.而B+树中,一个索引条目就指向一行.对于相异基数低的数据最为合适(也就是说,与整个数据集的基数相比,这个数据只有很少几个不同的值),对此做出量化是不太可能的,很难定义低相异基数到底是多大
				2.位图索引在读密集的环境中很好的工作,但是对于写密集的环境则极不适用,因为一个位图索引键条目指向多行,如果一个会话修改了有索引的数据,那么在大多数情况下,这个索引条目指向的所有行都会被锁定,Oracle无法锁定一个位图索引条目的单独一位,而是会被锁定.
		7.位图联结索引
			索引结构(而不是表)总的数据提供了一种逆规范化的方法,例如简单的EMP和DEPT表,如果统计"有多少人位于北京的部门工作?"这样EMP有一个指向DEPT的外键,要想统计LOC值为BeiJing的部门中的员工人数,通常需要表联结,将LOC列联结到MEP记录来解决,使用位图联结索引,可以在EMP表中对LOC列建立索引来解决问题
			注:
				1.create bitmap index emp_bm_idx on emp(d.dname) form emp e,dept d where e.deptno = d.deptno
				2.这样数据库不会访问DEPT表,因为DNAME列现在是指向EMP表中的行的索引中
		8.基于函数的索引
			这些就是B+树索引或位图索引,它将一个函数计算得到的结果存储在行的列中,而不是存储数据本身
			注:
				1.create index emp_upper_idx on emp(uppper(ename)) -- 创建了一个大小写无关的索引;
		注:
			1.视图是一个存储查询,优化器还是会对基表进行查询,所以对视图建立索引实际上就是对基表建立索引
			2.B+树索引不会存储完全为NULL的条目,位图和聚簇索引则不同,充分利用这一点,在全部允许有null值的列上建立唯一约束(当心多个全为null的行)
			3.外键没有索引可能会造成死锁,效率也会低很多,比如删除主表1,那么如果外键对应的主表2没有索引就会对主表2进行全表扫描,而这种扫描完全是不必要的,如果删除主表1多行,同样主表2也会扫描多次
		索引失效的情况:
			1.B+树索引没有使用到索引最前列(不满足最左原则)
			2.select count(*) from 表1 查询,因为索引可能建立一些允许NULL的值的列上,由于索引对完全为NULL的行不会建立相应的索引,索引通过索引统计的条数可能不是表中的实际行数,所以会进行全表扫描
			3.字段上使用了函数,因为建立索引的是原数据,而不是函数结果的数据,所以有必要的话,可以增加一个函数结果的列并加上索引(同样也是包括隐式转换,比如数值与字符串)
			4.select count(*) from 表1 where x < 15000 优化器不一定会使用索引,如果强制使用x上的索引的话,可能并不一定会加快速度,可以进行测试(耗用时间和I/O次数来评判)
		索引空间重用问题
			1.比如1-10000加载一个表,然后隔行删除数据,那么就会有5000个空洞,重新插入数据,只有当数据能在空洞中放下时,这些空间才会得到重用.
		索引空间回收问题
			1.一旦插入了可以重用空间的行,索引块上的空间就会立即重用
			2.索引块为空时,会送索引结构中取出它,并在以后重用
		最有差别的元素应该在最前面
			1.理论上是这样的,但是还是取决于索引的使用情况来定
	14.数据类型
		1.char与varchar比较时,就发生了隐式转换,比如varchar的尾部没有空格,select * from 表1 where char_column = varchar_column就查不到结果,但是如果trim(char_column)或者rpad(varchar_column,20)就可以.
		2.日期类型的区别
			datetime 8 bytes YYYY-MM-DD HH:MM:SS   1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
			timestamp 4 bytes YYYY-MM-DD HH:MM:SS   1970-01-01 00:00:01 ~ 2037-12-31 23:59:59
			date 3 bytes YYYY-MM-DD   1000-01-01 ~ 9999-12-31
		3.LOB类型
			1.CLOB(对应MySQL中的text类型):字符LOB,用于存储大量个文本信息,如XML或者纯文本,需要字符集转换,从数据库的字符集到客户的字符集之间转换
			2.NCLOB:也是一种字符LOB,采用的是数据库的国家字符集,而不是数据库的默认字符集
			3.BLOB:二进制LOB,用于存储大量的二进制信息,如文档,图片等能想到的任何其他数据
			4.BFILE:二进制文件LOB,这是一个文件的指针,存储的是操作系统中某个文件的一个指针,这个文件在数据库之外维护,不是数据库的一部分.
	15.分区
		1.partition by(关键字)
		2.索引分区
			1.局部索引
				每个表分区都有一个索引分区,而且只索引该表分区
				create index local_prefix on table (a,b) / (b) local;
				1.局部前缀索引(a,b)
				2.局部非前缀索引(b)
			2.全局分区索引
				索引按区间分区,一个索引分区可能指向任何表分区
				create index partitioned_index on partitioned(id) GLOBAL partition by range(id) (partition part_1 values less than (1000),....)
				注:
					删除一个分区时,必须删除可能指向该分区的所有全局索引条目
					使用索引来获取数据时,并不会自动的获取有序的数据,要以某种有序来获取数据,唯一的办法就是使用order by进行有序查询
	16.并行执行
		1.DML(PDML)
			命令:alter session enable parallel dml
			1.操作期间不支持触发器(因为触发器可能会向更新增加大量开销,而使用PDML就是为了更快一些,这是矛盾的)
			2.不支持某些声明方式的引用完整性约束(因为表中的每一片/部分会在单独的会话中作为单独的事务进行修改)
			3.在提交或回滚之前,不能访问用PDML修改的表
			4.不支持高级复制(因为高级复制基于触发器)
			5.不支持延迟约束
			6.如果表是分区的,PDML只可能在有位图索引或LOB列的表上执行,而且并行度取决于分区数,在这种情况下,无法在分区内并行执行一个操作,因为每个分区只有一个并行执行服务器来处理
			7.执行PDML时不支持分布式事务
			8.不支持聚簇表
		2.DDL(PDDL)
			命令:alter table 表 parallel;
		注:
			有长时间运行的语句或过程,并且有充足的可用资源就可以使用并行执行
	17.数据加载与卸载
		两种操作模式
			1.传统路径:SQLLDR会利用SQL插入我们的加载数据
			2.直接路径:SQLLDR不适用SQL,而是直接格式化数据库块,这样就绕过了整个SQL引擎和undo生成,同时还可能避开redo的生成,需要在一个没有任何数据的数据库总充分加载数据的最快方法.
</pre>