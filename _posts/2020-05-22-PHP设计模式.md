---
title: PHP设计模式
author: Yahui
layout: php
category: PHP
---


书名：《PHP设计模式》

文字描述及图片部分多数摘自-菜鸟教程(https://www.runoob.com/design-pattern)

<pre style="text-align: left;">
一.适配器模式-结构型模式（在需要转化一个对象的接口用于另一个对象时,实现Adapter对象不仅是最佳做法,还能减少很多麻烦）。
	意图：将一个类的接口转换成期望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
	主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
	何时使用： 
		1、系统需要使用现有的类，而此类的接口不符合系统的需要。 
		2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 
		3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）
	如何解决：继承或依赖（推荐）。
	关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。
	使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
	<span class="image featured"><img src="{{ 'assets/images/other/designmodeladapter.jpg' | relative_url }}" alt="" /></span>
	代码示例:
		interface A {
		    public function defun();
		}
		class A1 implements A {
		    public function defun() {
		        echo '这是A';
		    }
		}

		interface B {
		    public function zhongfun();
		}
		class B1 implements B {
		    public function zhongfun () {
		        echo '这是B';
		    }
		}
		// deal方法只针对A
		class deal {
		    public $sock;
		    public function __construct ($s) {
		        $this->sock = $s;
		    }
		    public function printfun () {
		        $this->sock->defun();
		    }
		}
		// 现在B也要用deal方法,所以要用到适配器进行处理
		class adapter implements A {
		    public $sock;
		    public function __construct ($s) {
		        $this->sock = $s;
		    }
		    public function defun() {
		        $this->sock->zhongfun();
		    }
		}
		$a = new A1();
		$aa = new deal($a);
		$aa -> printfun();

		$b = new B1();
		// 使用适配器进行处理,来适配deal方法
		$bb = new adapter($b);
		$bbb = new deal($bb);
		$bbb -> printfun();
	优点： 
		1、可以让任何两个没有关联的类一起运行。
		2、提高了类的复用。
		3、增加了类的透明度。
		4、灵活性好。
	缺点：
		1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。
		2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。
	注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。

二.建造者模式-创建型模式 (消除其他对象的创建过程,在某个对象的构造和配置方法改变时可以尽可能的减少重复改代码)
	意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
	主要解决：主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
	何时使用：一些基本部件不会变，而其组合经常变化的时候。
	如何解决：将变与不变分离开。
	关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。
	使用场景：
		1、需要生成的对象具有复杂的内部结构。
		2、需要生成的对象内部属性本身相互依赖。
		<span class="image featured"><img src="{{ 'assets/images/other/designmodelbuilder.jpg' | relative_url }}" alt="" /></span>
	代码实例：
		class product {
		    public $attrA;
		    public $attrB;
		    public function setAttrA($paramA) {
		        $this -> attrA = $paramA;
		    }
		    public function setAttrB($paramB) {
		        $this -> attrB = $paramB;
		    }
		}
		// 以往需要每个值进行赋值,product修改比较麻烦
		$paramArr = ['a' => 1, 'b' => 2];
		$product = new product();
		$product -> setAttrA($paramArr['a']);
		$product -> setAttrb($paramArr['b']);

		// 使用建造者模式,统一调用,修改起来比较方便
		class builder {
		    public $obj;
		    public function __construct () {
		        $this -> obj = new product();
		    }
		    public function set($paramArr) {
		        $this ->obj -> setAttrA($paramArr['a']);
		        $this ->obj -> setAttrb($paramArr['b']);
		    }
		    public function get() {
		        return $this -> obj;
		    }
		}

		$paramArr = ['a' => 1, 'b' => 2];
		$product = new builder();
		$product -> set($paramArr);
		var_dump((array)$product -> get());
	优点： 
		1、建造者独立，易扩展。
		2、便于控制细节风险。
	缺点：
		1、产品必须有共同点，范围有限制。
		2、如内部变化复杂，会有很多的建造类。
	注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。

三.数据访问对象模式-(低级的数据访问API或操作从高级的业务服务中分离出来)
	数据访问对象模式的参与者:
		数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。
		数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。
		模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。
	使用场景：
		1、减少重复和抽象化数据。
    <span class="image featured"><img src="{{ 'assets/images/other/designmodeldata.jpg' | relative_url }}" alt="" /></span>
	代码示例:
		abstract class baseDAO {
		    private $connect;
		    protected $user;
		    protected $pass;
		    protected $host;
		    protected $database;
		    protected $table;
		    protected function __construct() {
		        $this -> __connectToDb();
		    }
		    private function __connectToDb () {
		        // $this -> connect = mysql_connect($this -> host, $this -> user, $this -> pass);
		        // mysql_select_db($this -> database, $this -> connect);
		        echo 'mysql connect ' . $this -> host . ' , ' . $this -> user . ' , ' . $this -> pass . "\r\n";
		    }
		    public function update($condition, $where) {
		        $sql = 'UPDATE '. $this -> table . ' SET ';
		        foreach ($condition as $ckey => $cvalue) {
		            $sql .= $ckey . ' = ' . $cvalue . ',';
		        }
		        $sql = trim($sql, ',') . ' WHERE ';
		        foreach ($where as $wkey => $wvalue) {
		            $sql .= $wkey . ' = ' . $wvalue . ' AND ';
		        }
		        $sql = trim($sql);
		        $sql = trim($sql, 'AND');
		        // mysql_query($sql, $this -> connect);
		        echo $sql;
		    }
		}

		class product extends baseDAO {
		    public function __construct () {
		        $this -> user = 'user1';
		        $this -> pass = 'pass1';
		        $this -> host = 'host1';
		        $this -> database = 'database1';
		        $this -> table = 'product';
		        parent :: __construct();
		    }
		}

		$condition = ['product_id' => 1, 'sku' => 'L1123123'];
		$where = ['stock' => 100, 'name' => '商品A'];
		$producList = new product();
		$producList -> update($condition, $where);

四.装饰器模式-结构型模式(创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能)
	意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
	主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
	何时使用：在不想增加很多子类的情况下扩展类。
	如何解决：将具体功能职责划分，同时继承装饰者模式。
	关键代码： 
		1、Component 类充当抽象角色，不应该具体实现。
		2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。
	应用实例：
		1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。
		2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。
	优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
	缺点：多层装饰比较复杂。
	使用场景：
		1、扩展一个类的功能。
		2、动态增加功能，动态撤销。
	<span class="image featured"><img src="{{ 'assets/images/other/designmodeldecorator.jpg' | relative_url }}" alt="" /></span>
	代码示例:
		class demo {
		    public $data;
		    public function __construct () {
		        $this -> data = [];
		    }
		    public function set($params) {
		        foreach ($params as $pkey => $pvalue) {
		            $this -> data [$pkey] = $pvalue;
		        }
		    }
		    public function get() {
		        $str = '';
		        foreach ($this -> data as $gkey => $gvalue) {
		            $str .= $gkey . '=>' . $gvalue . "<br/>";
		        }
		        return $str;
		    }
		}

		$arr = ['a' => 'a', 'b' => 'b', 'c' => 'c'];
		// $d = new demo();
		// $d -> set($arr);
		// echo $d -> get();
		// 现在要返回键值都是大写
		class track {
		    private $obj;
		    public function __construct(demo $demo) {
		        $this -> obj = $demo;
		    }
		    public function deal() {
		        $re = [];
		        foreach ($this ->obj -> data as $dkey => $dvalue) {
		            $re[strtoupper($dkey)] = strtoupper($dvalue);
		        }
		        return $re;
		    }
		}

		$d = new demo();
		$d -> set($arr);
		$re = new track($d);
		$d -> data = $re -> deal();
		echo $d -> get($arr);
	注意事项：可代替继承。

五.代理模式-结构型模式(被代理方(B)与代理方(A)的接口完全一致,类似"中介")
	意图：为其他对象提供一种代理以控制对这个对象的访问。
	主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
	何时使用：想在访问一个类时做一些控制。
	如何解决：增加中间层。
	关键代码：实现与被代理类组合。
	应用实例： 
		1、Windows 里面的快捷方式。 
		2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 
		3、买火车票不一定在火车站买，也可以去代售点。 
		4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。
	优点：
		1、职责清晰。 
		2、高扩展性。 
		3、智能化。
	缺点： 
		1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
		2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
	使用场景：
		为简化编程（或无法操作B），不直接把请求交给被代理方（B），而把请求交给代码方（A），由代理方与被代理方进行通信，以完成请求。
		按职责来划分，通常有以下使用场景： 
			1、远程代理。 
			2、虚拟代理。 
			3、Copy-on-Write 代理。 
			4、保护（Protect or Access）代理。 
			5、Cache代理。 
			6、防火墙（Firewall）代理。 
			7、同步化（Synchronization）代理。 
			8、智能引用（Smart Reference）代理。
	<span class="image featured"><img src="{{ 'assets/images/other/designmodeldecorator.jpg' | relative_url }}" alt="" /></span>
	代码示例:
		interface base {
		    public function say();
		}

		class a implements base {
		    public function say() {
		        echo '服务接口' . '</br>';
		    }
		}
		class b implements base {
		    public $obj;
		    public function __construct($obj) {
		        $this -> obj = $obj;
		    }
		    public function say () {
		        echo '代理模式接口' . '</br>';
		        $this -> obj -> say();
		    }
		}
		$obj = new a();
		$obj -> say();
		$real = new b($obj);
		$real -> say();
	注意事项： 
		1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
		2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

六.委托模式-行为型模式(通过分配或委托至其他对象,委托设计模式能够去除核心对象的判决和复杂的功能性)
	核心：可以理解为静态代理和策略模式一种特殊的组合。
	注: 不要将委托模式视为条件语句的直接竞争者,这是非常重要的,相反,委托设计模式通过不需要条件语句就可以调用正确功能行的方式来帮助构成体系结构,条件语句最好驻留在实际方法中,并且在方法中完成对业务规则的处理.
	代码示例:
		class base {
		    private $data;
		    public function __construct() {
		        $this -> data = [];
		    }
		    public function set($song) {
		        $this -> data = $song;
		    }
		    public function dealA() {
		        foreach ($this -> data as $dkey => $dvalue) {
		            echo 'A is dealing...' . '<br/>';
		        }
		    }
		    public function dealB() {
		        foreach ($this -> data as $dkey => $dvalue) {
		            echo 'B is dealing...' . '<br/>';
		        }
		    }
		}
		$song = ['a', 'b'];
		// $b = new base();
		// $b -> set($song);
		// if (true) {
		//     $b -> dealA();
		// } else {
		//     $b -> dealB();
		// }
		class realDealA{
		    public function getPlayList ($song) {
		        foreach ($song as $akey => $avalue) {
		            echo 'A is dealing...' . '<br/>';
		        }
		    }
		}
		class realDealB{
		    public function getPlayList ($song) {
		        foreach ($song as $bkey => $bvalue) {
		            echo 'B is dealing...' . '<br/>';
		        }
		    }
		}
		class playList {
		    public $str;
		    public function __construct ($type) {
		        $this -> str = 'realDeal' . $type;
		    }
		    public function get($arr) {
		        $obj = new $this -> str;
		        $obj -> getPlayList($arr);
		    }
		}
		$c = new playList('a');
		$c -> get($song);
		$c = new playList('b');
		$c -> get($song);
	注意事项： 
		1、和代理模式的区别：代理模式注重过程,委托模式注重结果。

七.外观模式-结构型模式(通过在必需的逻辑和方法的集合前创建简单的外观接口,外观设计模式隐藏了来自调用对象的复杂性)
    意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
    主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
    何时使用：
        1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。
        2、定义系统的入口。
    如何解决：客户端不与系统耦合，外观类与系统耦合。
    关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
    应用实例：
        1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。
        2、JAVA 的三层开发模式。
    <span class="image featured"><img src="{{ 'assets/images/other/designmodelmaker.jpg' | relative_url }}" alt="" /></span>
    代码示例:
        class base {
            public $name;
            public $disc;
            public $work;
            public function __construct($name, $disc, $work) {
                $this -> name = $name;
                $this -> disc = $disc;
                $this -> work = $work;
            }
        }
        class setUpper extends base{
            public function getName() {
                echo strtoupper($this -> name);
            }
            public function getDisc() {
                echo strtoupper($this -> disc);
            }
            public function getWork() {
                echo strtoupper($this -> work);
            }
        }
        $name = 'i am name';
        $disc = 'i am disc';
        $work = 'i am work';
        $a = new setUpper($name, $disc, $work);
        $a -> getName();
        $a -> getDisc();
        $a -> getWork();
        // 外观类
        class outLook {
            public $obj;
            public function __construct($arr) {
                $this -> obj = new setUpper($arr['name'], $arr['disc'], $arr['work']);
            }
            public function getUpper() {
                $this -> obj -> getName();
                $this -> obj -> getDisc();
                $this -> obj -> getWork();
            }
        }
        $b = ['name' => 'i am name', 'disc' => 'i am disc', 'work' => 'i am work'];
        $a = new outLook($b);
        $a -> getUpper();
    优点：
        1、减少系统相互依赖。
        2、提高灵活性。
        3、提高了安全性。
    缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。
    使用场景：
        1、为复杂的模块或子系统提供外界访问的模块。
        2、子系统相对独立。
        3、预防低水平人员带来的风险。
    注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。 

八.工厂模式-创建型模式(提供获取某个对象的新实例的一个接口,同时使调用代码避免确定实际实例化基类的步骤)
    意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
    主要解决：主要解决接口选择的问题。
    何时使用：我们明确地计划不同条件下创建不同实例时。
    如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
    关键代码：创建过程在其子类执行。
    应用实例：
        1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。
        2、Hibernate 换数据库只需换方言和驱动就可以。
    优点： 
        1、一个调用者想创建一个对象，只要知道其名称就可以了。
        2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
        3、屏蔽产品的具体实现，调用者只关心产品的接口。
    缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。
    使用场景：
        1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
        2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。
        3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。
    <span class="image featured"><img src="{{ 'assets/images/other/designmodelfactory.jpg' | relative_url }}" alt="" /></span>
    代码示例:
        interface base {
            public function drow();
        }
        class circle implements base {
            public function drow() {
                echo 'circle - drow';
            }
        }
        class rectangle implements base {
            public function drow() {
                echo 'rectangle - drow';
            }
        }
        // 创建工厂类
        class factory {
            public $type;
            public function __construct($type) {
                $this -> type = $type;
            }
            public function drow() {
                if ($this -> type == 'circle') {
                    return new circle();
                } elseif ($this -> type == 'rectangle') {
                    return new rectangle();
                }
                return null;
            }
        }
        $type = 'rectangle';
        $obj = new factory($type);
        $obj -> drow() -> drow();
    注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
 
九.解释器模式-行为型模式(用于分析一个实体的关键元素,并且针对每个元素都提供自己的解释或相应的动作)
    意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。
    主要解决：对于一些固定文法构建一个解释句子的解释器。
    何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
    如何解决：构建语法树，定义终结符与非终结符。
    关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。
    应用实例：编译器、运算表达式计算。
    <span class="image featured"><img src="{{ 'assets/images/other/designmodelexpression.jpg' | relative_url }}" alt="" /></span>
    代码示例:
            interface Expression {
                public function interpret();
            }
            class TerminalExpression implements Expression {
                public $data;
                public function __construct($data) {
                    $this -> data = $data;
                }
                public function interpret() {
                    foreach ($this -> data AS $dataValue) {
                        if ($dataValue == strtoupper($dataValue)) {
                            echo $dataValue . 'is all upper';
                        } elseif ($dataValue == strtolower($dataValue)) {
                            echo $dataValue . 'is all lower';
                        } else {
                            echo $dataValue . 'is all normal';
                        }
                    }
                }
            }
            class AndExpression implements Expression {
                public $data;
                public function __construct($arr) {
                    $this -> data = $arr;
                }
                public function interpret() {
                    $a = [];
                    foreach ($this -> data AS $dataKey => $dataValue) {
                        $a[] = $dataKey . $dataValue;
                    }
                    return $a;
                }
            }
            $arr = ['a' => 'a', 'b' => 'B', 'c' => 'C', 'D' => 'D'];
            $obja = new AndExpression($arr);
            $objb = new TerminalExpression($obja ->interpret());
            $objb -> interpret();
    优点：
        1、可扩展性比较好，灵活。
        2、增加了新的解释表达式的方式。
        3、易于实现简单文法。
    缺点：
        1、可利用场景比较少。
        2、对于复杂的文法比较难维护。
        3、解释器模式会引起类膨胀。
        4、解释器模式采用递归调用方法。
    使用场景：
        1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。
        2、一些重复出现的问题可以用一种简单的语言来进行表达。
        3、一个简单语法需要解释的场景。
    注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。

十.迭代器模式-(帮助构造特定对象,那些对象能够提供单一标准接口循环或迭代任何类型的可计数数据)
    意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
    主要解决：不同的方式来遍历整个整合对象。
    何时使用：遍历一个聚合对象。
    如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。
    关键代码：定义接口：hasNext, next。
    应用实例：JAVA 中的 iterator。
    <span class="image featured"><img src="{{ 'assets/images/other/designmodeliterator.jpg' | relative_url }}" alt="" /></span>
    代码示例:
        interface IListCollection {
            public function getIterator();
        }
        interface aIterator {
            public function MoveNext();
            public function GetCurrent();
            public function Next();
            public function Reset();
        }
        // 数据
        class ConcreteList implements IListCollection {
            public $collection;
            public function __construct() {
                $this -> collection = [2, 4, 6, 8];
            }
            public function GetIterator() {
                return new ConcreteIterator($this -> collection);
            }
            public function Length () {
                return count($this -> collection);
            }
        
            public function GetElement($index) {
                return $this -> collection[$index];
            }
        }
        // 遍历操作
        class ConcreteIterator implements aIterator
        {
            private $_list;
            private $_index;
            public function __construct($list) {
                $this -> _list = $list;
                $this -> _index = 0;
            }
            public function MoveNext() {
                if ($this -> _index < count($this -> _list))
                {
                    return true;
                }
                return false;
            }
            public function GetCurrent() {
                return $this -> _list[$this -> _index];
            }
        
            public function Reset() {
                $this -> _index = 0;
            }
        
            public function Next() {
                if ($this -> _index < count($this -> _list)) {
                    $this ->_index ++;
                }
            }
        }
        class Program
        {
            static function Main() {
                $list = new ConcreteList();
                $iterator = $list -> GetIterator();
                while ($iterator -> MoveNext()) {
                    $i = $iterator -> GetCurrent();
                    echo $i;
                    $iterator -> Next();
                }
            }
        }
        $a = new Program();
        $a -> Main();
    优点：
        1、它支持以不同的方式遍历一个聚合对象。
        2、迭代器简化了聚合类。
        3、在同一个聚合上可以有多个遍历。
        4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。
    缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
    使用场景：
        1、访问一个聚合对象的内容而无须暴露它的内部表示。
        2、需要为聚合对象提供多种遍历方式。
        3、为遍历不同的聚合结构提供一个统一的接口。
    注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。

十一.中介者模式-行为模式(用户开发一个对象,这个对象能够在类似对象相互之间不直接交互的情况下传送或调解对这些对象的集合的修改)
    意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。
    何时使用：多个类相互耦合，形成了网状结构。
    如何解决：将上述网状结构分离为星型结构。
    关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。
    应用实例：
        1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。
        2、机场调度系统。
        3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。
    <span class="image featured"><img src="{{ 'assets/images/other/designmodelroom.jpg' | relative_url }}" alt="" /></span>
    代码示例:
        class cd {
            public $title;
            public $band;
            public $obj;
            public function __construct($obj = null) {
                $this -> obj = $obj;
            }
            public function rename ($band) {
                if (!is_null($this -> obj)) {
                    $this -> obj -> change($this, ['band' => $band]);
                }
                $this -> band = $band;
                $this -> save();
            }
            public function save() {
                echo 'title -> ' . $this -> title . ' band -> ' . $this -> band;
            }
        }
        class mp3 {
            public $title;
            public $band;
            public $obj;
            public function __construct($obj = null) {
                $this -> obj = $obj;
            }
            public function rename ($band) {
                if (!is_null($this -> obj)) {
                    $this -> obj -> change($this, ['band' => $band]);
                }
                $this -> band = $band;
                $this -> save();
            }
            public function save() {
                echo 'title -> ' . $this -> title . ' band -> ' . $this -> band;
            }
        }
        class music {
            public $contents;
            public function __construct() {
                $this -> contents = ['cd', 'mp3'];
            }
            public function change($obj, $arr) {
                foreach ($this-> contents AS $cvalue) {
                    if ($obj instanceof $cvalue) {
                        $o = new $cvalue;
                        $o -> title = $obj -> title;
                        $o -> band = $obj -> title;
                        foreach ($arr AS $arrkey => $arrvalue) {
                            $o -> $arrkey = $arrvalue;
                        }
                        $o -> save();
                    }
                }
            }
        }
        $title = 'this is title';
        $band = 'this is band';
        $o = new music();
        $cd = new cd($o);
        $cd -> title = $title;
        $cd -> band = $band;
        $cd -> rename('this is new band');
    优点：
        1、降低了类的复杂度，将一对多转化成了一对一。
        2、各个类之间的解耦。
        3、符合迪米特原则。
    缺点：中介者会庞大，变得复杂难以维护。
    使用场景：
        1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。
        2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。
    注意事项：不应当在职责混乱的时候使用。

十二.观察者模式-行为型模式(能够更便利的创建查看目标对象状态的对象,并且提供与核心对象非耦合的制定功能性)
    意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
    主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。
    何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。
    如何解决：使用面向对象技术，可以将这种依赖关系弱化。
    关键代码：在抽象类里有一个 ArrayList 存放观察者们。
    应用实例：
        1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。
        2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。
    <span class="image featured"><img src="{{ 'assets/images/other/designmodelobserver.jpg' | relative_url }}" alt="" /></span>
    代码示例：
        interface base {
            public function notice();
        }
        class bird implements base {
            public function notice() {
                echo 'this is bird notice';
            }
        }
        class tiger implements base {
            public function notice() {
                echo 'this is tiger notice';
            }
        }
        interface action{
            public function add($type);
            public function del($type);
            public function notict();
        }
        class doAction implements action{
            private $type = [];
            public function add($type) {
                $this -> type[] = $type;
            }
            public function del($type) {
                foreach ($this -> type AS $thisTypeKey => $thisTypeVale) {
                    if ($thisTypeVale == $type) {
                        unset($this -> type[$thisTypeKey]);
                    }
                }
            }
            public function notict() {
                foreach ($this -> type AS $thisTypeValue) {
                    $obj = new $thisTypeValue;
                    $obj -> notice();
                }
            }
        }
        $o = new doAction();
        $o -> add('bird');
        $o -> add('tiger');
        //$o -> del('tiger');
        $o -> notict();
    优点：
        1、观察者和被观察者是抽象耦合的。
        2、建立一套触发机制。
    缺点：
        1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
        2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
        3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
    使用场景：
        一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
        一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
        一个对象必须通知其他对象，而并不知道这些对象是谁。
        需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。
    注意事项：
        1、JAVA 中已经有了对观察者模式的支持类。
        2、避免循环引用。
        3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。
</pre>